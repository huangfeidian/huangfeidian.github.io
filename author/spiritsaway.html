<!DOCTYPE html>
<html lang="chinese (simplified)">
<head>
        <meta charset="utf-8" />
        <title>SpiritsAway - SpiritsAway</title>
        <link rel="stylesheet" href="/theme/css/main.css" />

        <!--[if IE]>
            <script src="https://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">SpiritsAway </a></h1>
                <nav><ul>
                    <li><a href="/pages/about.html">about</a></li>
                    <li><a href="/category/ai.html">AI</a></li>
                    <li><a href="/category/algorithm.html">Algorithm</a></li>
                    <li><a href="/category/code.html">Code</a></li>
                    <li><a href="/category/compiler.html">Compiler</a></li>
                    <li><a href="/category/cpp.html">CPP</a></li>
                    <li><a href="/category/math.html">Math</a></li>
                </ul></nav>
        </header><!-- /#banner -->

            <aside id="featured" class="body">
                <article>
                    <h1 class="entry-title"><a href="/asio-implementation.html">Asio Implementation</a></h1>
<footer class="post-info">
        <abbr class="published" title="2016-03-17T23:44:00+08:00">
                Published: 周四 17 三月 2016
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/spiritsaway.html">SpiritsAway</a>
        </address>
<p>In <a href="/category/cpp.html">CPP</a>.</p>
<p>tags: <a href="/tag/cpp.html">CPP</a> </p>
</footer><!-- /.post-info --><h1>Asio 介绍</h1>
<p>[Asio]{http://think-async.com/Asio}是一个建立在[Boost]{http://www.boost.org/}所提供的相关组件之上的异步的网络库，可以运行在<code>Win/Linux/Unix</code>等各种平台之上。不过随着C++11的发布，其对于Boost的依赖也越来越少，作者又做了一个不依赖于boost的版本。对于Asio所提供的功能以及整体架构，可以从下图中可窥一斑：</p>
<p><img alt="Asio构建描述" src="{attach}image\Asio\overview.png"></p>
<h1>网络IO模型</h1>
<p>在W. Richard Stevens 的Unix Network Programming中，谈到了5种IO模型：</p>
<ul>
<li>
<p>阻塞 blocking ,当前线程发出IO请求后阻塞在等待IO就绪，然后再发去数据复制请求，然后再阻塞在等待数据拷贝完成；</p>
</li>
<li>
<p>非阻塞 non-blocking，不停的调用recv_some 或send_some，每次都能progress一点，最后仍然会在data copy这里阻塞在系统调用上；</p>
</li>
<li>
<p>IO多路复用 IO multiplexing，基本类似于blocking，只不过一个线程可以同时处理多个socket的请求，也就是所谓的线程复用了；</p>
</li>
<li>
<p>异步 asynchronouse，线程提交IO请求之后直接返回，系统在执行完IO请求并复制到用户提供的数据区之后再通知完成</p>
</li>
<li>
<p>信号驱动 singal-driven，没啥用，不说了</p>
</li>
</ul>
<p>总的来说，这几种IO模型下，线程的运行状态如下图：</p>
<p><img alt="IO模型" src="{attach}image\Asio\IO.jpg"></p>
<p>在三个主流的操作系统平台中，都采用了各自的主流IO模型。Windows上采用的的是IOCP,Linux上采用的是Epoll,Unix上采用的是kqueue。Asio通过一个中间层来实现在各个不同的平台上调用不同的底层实现。所以，为了更好的理解Asio，首先需要了解这几种不同的IO多路复用的机制。在此我只对IOCP和Epoll做一些介绍，kqueue因为不熟所以忽略。</p>
<h2>IOCP</h2>
<p>IOCP的全称是<code>IO Completion Port</code>，中文名叫做I/O完成端口。其模型简要来说就是：客户向操作系统提交IO任务，操作系统执行客户所发出的各项IO请求，在完成IO请求之后操作系统将对应的IO任务提交到完成队列中，同时一个线程池不断的监听该完成队列中是否有消息。具体的完成之后的业务逻辑依赖于线程池中的具体代码，系统提供的主要功能是这个完成队列。</p>
<p>在Windows，与IOCP关联最紧密的API主要有三个，分别是<code>CreateIoCompletionPort, GetQueuedCompletionStatus, PostQueueCompeltionStatus</code>。</p>
<p><code>CreateIoCompletionPort</code>的作用是建立一个IO完成端口，其函数签名如下：</p>
<div class="highlight"><pre><span></span><span class="n">HANDLE</span>   <span class="nf">CreateIoCompletionPort</span>   <span class="p">(</span>   
      <span class="n">HANDLE</span>   <span class="n">FileHandle</span><span class="p">,</span>                                 <span class="c1">//   handle   to   file   </span>
      <span class="n">HANDLE</span>   <span class="n">ExistingCompletionPort</span><span class="p">,</span>           <span class="c1">//   handle   to   I/O   completion   port   </span>
      <span class="n">ULONG_PTR</span>   <span class="n">CompletionKey</span><span class="p">,</span>                 <span class="c1">//   completion   key   </span>
      <span class="n">DWORD</span>   <span class="n">NumberOfConcurrentThreads</span>   <span class="c1">//   number   of   threads   to   execute   concurrently   </span>
  <span class="p">);</span>
</pre></div>


<p>这个函数需要注意的是：他同时承担着建立完成端口和将设备绑定到完成端口这两个任务。当这个函数用于建立一个新的完成端口时，其参数调用是这样的：</p>
<div class="highlight"><pre><span></span><span class="n">CreateIoCompletionPort</span><span class="p">(</span><span class="n">INVALID_HANDLE_VALUE</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>


<p>这里的<code>INVALID_HANDLE_VALUE</code>的值其实是-1。简而言之呢，如果我们给他的都是一些无效的值，则这个函数会创建一个新的完成端口。最后一个参数是代表的是允许应用程序同时执行的线程数量。需要注意的是，这个参数并不是我们线程池中线程的数量，而是完成端口允许的活动线程的数量。如果设置为0，就是说有多少个处理器，就允许同时多少个线程运行，这样就可以避免频繁的上下文切换。至于真正执行任务的线程池，需要我们自己设置线程数量，folklore说一般设置为<code>2*cpu+2</code>个工作线程。</p>
<p>如果我们想将一个IO设备绑定到现有的完成端口之上，则需要以另外的形式调用CreateIoCompletionPort。当前我们需要处理网络事件，因此需要将socket作为HANDLE和一个完成键（对你有意义的一个32位值，也就是一个指针， 操作系统并不关心你传什么）传进去。</p>
<div class="highlight"><pre><span></span><span class="n">CreateIoCompletionPort</span><span class="p">(</span><span class="n">ioHandle</span><span class="p">,</span> <span class="n">iocp</span><span class="p">,</span> <span class="p">(</span><span class="n">ULONG_PTR</span><span class="p">)</span><span class="n">fn</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>


<p>每当你向端口关联一个设备时，系统向该完成端口的设备列表中加入一条信息纪录。   </p>
<p>一个函数来做两件事这种设计很不好！</p>
<p><code>GetQueuedCompletionStatus</code>是用来处理IO完成事件的，其函数签名如下：</p>
<div class="highlight"><pre><span></span><span class="n">BOOL</span> <span class="n">WINAPI</span> <span class="nf">GetQueuedCompletionStatus</span><span class="p">(</span>  
  <span class="n">__in</span>   <span class="n">HANDLE</span>          <span class="n">CompletionPort</span><span class="p">,</span>    <span class="c1">// 这个就是我们建立的那个唯一的完成端口   </span>
  <span class="n">__out</span>  <span class="n">LPDWORD</span>         <span class="n">lpNumberOfBytes</span><span class="p">,</span>   <span class="c1">//这个是操作完成后返回的字节数   </span>
  <span class="n">__out</span>  <span class="n">PULONG_PTR</span>      <span class="n">lpCompletionKey</span><span class="p">,</span>   <span class="c1">// 这个是我们建立完成端口的时候绑定的那个自定义结构体参数   </span>
  <span class="n">__out</span>  <span class="n">LPOVERLAPPED</span>    <span class="o">*</span><span class="n">lpOverlapped</span><span class="p">,</span>     <span class="c1">// 这个是我们在连入Socket的时候一起建立的那个重叠结构   </span>
  <span class="n">__in</span>   <span class="n">DWORD</span>           <span class="n">dwMilliseconds</span>     <span class="c1">// 等待完成端口的超时时间，如果线程不需要做其他的事情，那就INFINITE就行了   </span>
   <span class="p">);</span>
</pre></div>


<p>GetQueuedCompletionStatus使调用线程挂起，放入到等待线程队列中，直到指定的端口的I/O完成队列中出现了一项或直到超时。</p>
<ul>
<li>
<p>当有任务成功时，返回TRUE，dwCompletionKey返回调用CreateIOCompletionPort将I/O设备（比如文件，套接字等等）句柄关联到完成端口时提供的dwCompletionKey参数,lpOverlapped返回异步调用时提供的lpOverlapped参数，nBytesTransferred返回写入或读取的字节数。</p>
</li>
<li>
<p>当没有任务完成，也没有任务出现错误时，返回FALSE。lpOverlapped被设置为nil。调用GetLastError可以得到更详细的原因，如果GetLastError返回WAIT_TIMEOUT,表明超时了，如果是其他错误，可以查MSDN上的系统错误码，了解原因。</p>
</li>
<li>
<p>如果有任务失败了，返回FALSE。dwCompletionKey和lpOverlapped的设置情况跟第一种结果一样。GetLastError返回任务失败的原因。对于Winsock2的WSARecv调用，如果GetLastError返回ERROR_NETNAME_DELETED，表示连接被通讯的另一方复位或者异常中断了，比如对方死机，此时应关闭套接字。对于Winsock2的ConnectEx调用，如果GetLastError返回ERROR_CONNECTION_REFUSED，表示远端主机没有在这一端口进行监听；如果返回ERROR_HOST_UNREACHABLE，表示网络不通。</p>
</li>
</ul>
<p>这里的线程等待队列其实不是一个队列，而是一个栈，后进先出。这样如果反复只有一个I/O操作而不是多个操作完成的话，内核就只需要唤醒同一个线程就可以了，而不需要轮着唤醒多个线程，节约了资源，而且可以把其他长时间睡眠的线程换出内存，提到资源利用率。</p>
<p>PostQueueCompeltionStatus是用来通知完成端口的线程退出的函数，其函数签名如下：</p>
<div class="highlight"><pre><span></span><span class="n">BOOL</span> <span class="n">WINAPI</span> <span class="nf">PostQueuedCompletionStatus</span><span class="p">(</span>  
   <span class="n">__in</span>      <span class="n">HANDLE</span> <span class="n">CompletionPort</span><span class="p">,</span>  
   <span class="n">__in</span>      <span class="n">DWORD</span> <span class="n">dwNumberOfBytesTransferred</span><span class="p">,</span>  
   <span class="n">__in</span>      <span class="n">ULONG_PTR</span> <span class="n">dwCompletionKey</span><span class="p">,</span>  
   <span class="n">__in_opt</span>  <span class="n">LPOVERLAPPED</span> <span class="n">lpOverlapped</span>  
<span class="p">);</span>
</pre></div>


<p>这个函数的参数几乎和GetQueuedCompletionStatus()的一模一样，都是需要把我们建立的完成端口传进去，然后后面的三个参数是 传输字节数、结构体参数、重叠结构的指针。可以理解为一个是完成队列的push操作，一个是完成队列的pop操作。我们在push是加上一些标志性的参数，使得工作线程在检查结果时遇到这些参数就直接退出工作。因此，对于每一个工作线程，我们都需要push一次，即调用PostQueuedCompletionStatus一次：</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m_nThreads</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>  
<span class="p">{</span>  
      <span class="n">PostQueuedCompletionStatus</span><span class="p">(</span><span class="n">m_hIOCompletionPort</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">DWORD</span><span class="p">)</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>  
<span class="p">}</span>
</pre></div>


<p>综上，一个使用IOCP的接收服务器的整体工作流程可以以下图概括：</p>
<p><img alt="IOCP流程" src="{attach}image\Asio\IOCP_workflow.png"></p>
<h2>Epoll</h2>
<p>在谈到epoll时，不得不谈他的演化史，即select-poll-epoll。这三者都是linux上的多路复用机制，通过监听描述符的就绪态来通知程序进行读写。其工作流程见下图：</p>
<p><img alt="Select流程" src="{attach}image\Asio\select.png"></p>
<p>select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间，正如前面提到的IOCP。</p>
<p>在调用select时，我们需要提供三个fd_set，分别代表可读、可写、可错三个感兴趣的文件描述符列表。调用时我们需要将这些fd_set 考入内核空间，然后对于每个fd都调用其poll方法来查看其是否就绪。如果有就绪的fd则直接返回，否则当前线程休眠直到timeout，timeout唤醒之后再扫描一遍fd_set查看是否有就绪fd，然后直接返回。返回时需要把fd_set从内核拷贝到用户空间中。</p>
<p>poll相对与select的改进就是不再采用三个fd_set，而是采取了一个单独的pollfd来存储所有涉及到的文件描述符以及每个描述符上感兴趣的事件。可以说是拷贝的数据量减少了,但是select所拥有的缺点poll仍然完美的继承了下来：</p>
<ul>
<li>
<p>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大;</p>
</li>
<li>
<p>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大;</p>
</li>
<li>
<p>select支持的文件描述符数量太小了，默认是1024。</p>
</li>
</ul>
<p>而epoll的改进则更彻底一些，他提供了三个函数<code>epoll_create,epoll_ctl,epoll_wait</code>。<code>epoll_create</code>是创建一个epoll句柄；<code>epoll_ctl</code>是注册要监听的事件类型；<code>epoll_wait</code>则是等待事件的产生。在具体的执行机制上，epoll做了如下改进：</p>
<ul>
<li>
<p>每次注册新的事件到epoll句柄中时（在<code>epoll_ctl</code>中指定<code>EPOLL_CTL_ADD</code>），会把所有的fd拷贝进内核，而不是在<code>epoll_wait</code>的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。</p>
</li>
<li>
<p>epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在<code>epoll_ctl</code>时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。<code>epoll_wait</code>的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用<code>schedule_timeout()</code>实现睡一会，判断一会的效果。</p>
</li>
<li>
<p>epoll所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048，具体数目可以<code>cat /proc/sys/fs/file-max</code>察看,一般来说这个数目和系统内存关系很大。</p>
</li>
</ul>
<h1>Asio 异步模型</h1>
<p>Asio使用的是Proactor（前摄器）模型，其模型图见下:
<img alt="Proactor模型" src="{attach}image\Asio\proactor.png"></p>
<p>这里需要解释一下各个部分代表着什么:</p>
<ul>
<li>
<p>Asynchronous Operation:异步操作，调用后直接返回，不阻塞；</p>
</li>
<li>
<p>Asynchronous Operation Processor:异步操作执行单元，用来执行异步操作，异步操作执行完成之后将对应的完成事件放入完成事件队列</p>
</li>
<li>
<p>Completion Event Queue:存储完成事件的队列</p>
</li>
<li>
<p>Asynchronous Event Demultiplexer:异步事件多路复用单元，等待Completion Event Queue出现完成事件，然后返回一个完成事件</p>
</li>
<li>
<p>Proactor:调用异步事件多路复用单元来获得一个完成事件，然后分发这个完成事件所关联的完成操作句柄（回调函数）到具体的执行单元中</p>
</li>
<li>
<p>Initiator：初始化器，用来提供初始的异步操作。</p>
</li>
</ul>
<p>在windows上，这个模型很容易的就可以映射到IOCP之上：</p>
<ul>
<li>
<p>asynchrounous Operation Processor:这个是系统自己处理，我们直接将异步操作映射到操作系统自带的异步api即可委托给操作系统执行；</p>
</li>
<li>
<p>completion Event Queue: 这个完成事件队列也是由windows自己管理好了，我们只需要用GetQueuedCompletionStatus即可获得一个完成事件；</p>
</li>
<li>
<p>Asynchronous Event Demultiplexer:这部分是由Asio调用GetQueuedCompletionStatus来获得完成事件以及相应的完成操作句柄。</p>
</li>
</ul>
<p>而在Linux/Unix上情况则不同了，因为这两个平台系统所提供的操作是同步的，其模型是Reactor模型，只能通知IO操作是否可以开始进行，而不能通知IO操作的完成。所以，Asio需要进行如下处理：</p>
<ul>
<li>
<p>Asynchronous Operation Processor： 当通过select/epoll/kqueue实现的reactorr通知某项IO操作可以进行时，这个processor执行这个异步操作，然后将完成事件和完成操作挂在到完成事件队列上；</p>
</li>
<li>
<p>Completion Event Queue : 一个以链表形式存在的完成操作句柄队列；</p>
</li>
<li>
<p>Asynchronous Event DemultiPlexer：这个是由Asio实现的一个等待机制，主要是通过条件变量来进行等待</p>
</li>
</ul>
<h1>io service</h1>
<p>在Asio中，最重要的类就是io_service类，继承自nocopyable。这个类是一个接口类，主要提供了下面的几个操作：</p>
<ul>
<li>
<p>run</p>
</li>
<li>
<p>poll</p>
</li>
<li>
<p>stop</p>
</li>
<li>
<p>dispatch</p>
</li>
<li>
<p>post</p>
</li>
</ul>
<p>同时这个类只有三个成员：</p>
<div class="highlight"><pre><span></span><span class="k">private</span><span class="o">:</span>
<span class="cp">#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)</span>
  <span class="n">detail</span><span class="o">::</span><span class="n">winsock_init</span><span class="o">&lt;&gt;</span> <span class="n">init_</span><span class="p">;</span>
<span class="cp">#elif defined(__sun) || defined(__QNX__) || defined(__hpux) || defined(_AIX) \</span>
<span class="cp">  || defined(__osf__)</span>
  <span class="n">detail</span><span class="o">::</span><span class="n">signal_init</span><span class="o">&lt;&gt;</span> <span class="n">init_</span><span class="p">;</span>
<span class="cp">#endif</span>

  <span class="c1">// The service registry.</span>
  <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">service_registry</span><span class="o">*</span> <span class="n">service_registry_</span><span class="p">;</span>

  <span class="c1">// The implementation.</span>
  <span class="n">impl_type</span><span class="o">&amp;</span> <span class="n">impl_</span><span class="p">;</span>
</pre></div>


<p>而这些操作最后都会委托到io_service 内的成员<code>impl_type&amp; impl</code>去执行，也就是说采取的是pimpl模式。至于这个<code>impl_type</code>，是io_service所定义的一个类型别名：</p>
<div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="n">detail</span><span class="o">::</span><span class="n">io_service_impl</span> <span class="n">impl_type</span><span class="p">;</span>
</pre></div>


<p>他的具体类型是与平台相关的：</p>
<div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">detail</span> <span class="p">{</span>
<span class="cp">#if defined(BOOST_ASIO_HAS_IOCP)</span>
  <span class="k">typedef</span> <span class="k">class</span> <span class="nc">win_iocp_io_service</span> <span class="n">io_service_impl</span><span class="p">;</span>
  <span class="k">class</span> <span class="nc">win_iocp_overlapped_ptr</span><span class="p">;</span>
<span class="cp">#else</span>
  <span class="k">typedef</span> <span class="k">class</span> <span class="nc">task_io_service</span> <span class="n">io_service_impl</span><span class="p">;</span>
<span class="cp">#endif</span>
  <span class="k">class</span> <span class="nc">service_registry</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">//</span>
</pre></div>


<p>至于<code>init_</code>成员，是用来做各个平台的各项网络初始化和销毁工作的，简单来说就是一个RAII类型。</p>
<p>而关于<code>service_registry_</code>类型，则没有那么简单了，首先我们看一下io_service的构造函数里这个成员是怎么使用的</p>
<div class="highlight"><pre><span></span><span class="n">io_service</span><span class="o">::</span><span class="n">io_service</span><span class="p">()</span>
  <span class="o">:</span> <span class="n">service_registry_</span><span class="p">(</span><span class="k">new</span> <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">service_registry</span><span class="p">(</span>
        <span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">impl_type</span><span class="o">*&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">)())),</span>
    <span class="n">impl_</span><span class="p">(</span><span class="n">service_registry_</span><span class="o">-&gt;</span><span class="n">first_service</span><span class="o">&lt;</span><span class="n">impl_type</span><span class="o">&gt;</span><span class="p">())</span>
<span class="p">{</span>
<span class="p">}</span>
</pre></div>


<p>这里的<code>static_cast&lt;impl_type*&gt;(0)</code>只是为了参数类型推导用的。通过分析service_registery的实现，可以看出他世纪只能就是一个管理service的链表，impl_type也是一个service类型。每种service都有一个唯一id。在调用 use_service<ServiceType>(io_service&amp;) 时，service_registry会查找链表，如果有对应类型的服务，就返回该类型服务实例的指针；否则就创建一个新的对象，并加入到链表末端，再返回此新创建的实例；通过这种形式，io_service确保每种类型的服务都只有一个实例存在。</p>
<p>对于不同的操作我们有不同的对应的service子类，所以加入某个特定的service的最佳时机便是对应操作的启动者的构造期，具体代码见下：</p>
<div class="highlight"><pre><span></span><span class="k">explicit</span> <span class="nf">basic_io_object</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">io_service</span><span class="o">&amp;</span> <span class="n">io_service</span><span class="p">)</span>
<span class="o">:</span> <span class="n">service</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">use_service</span><span class="o">&lt;</span><span class="n">IoObjectService</span><span class="o">&gt;</span><span class="p">(</span><span class="n">io_service</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">service</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">implementation</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>在构造过程中，使用<code>use_service</code>的返回值来初始化该service成员；我们知道，<code>use_service</code>会在<code>io_service</code>所维护的service链表中查找该类型，如果没有，就创建一个新的service实例；在此，就可以确保<code>resolve_service&lt;tcp&gt;</code>的实例已经被创建出来了，该服务就可以工作了。</p>
<p>这里还需要提到的一点是：<code>resolver</code>自己会创建一个<code>IOCP</code>，因为windows并没有提供<code>resolver</code>的重叠IO操作，这个<code>resolver</code>还会创建自己的线程来执行。但是会回调两次，一次是在<code>resolver</code>的线程中，其回调操作就是把结果发送到主线程的<code>IOCP</code>之中去，在主线程之中取出之后才会调用用户提供的回调函数。</p>
<h1>io objects</h1>
<p>这里的io objects是承载具体IO功能的对象，常见的有acceptor/resolver/timer/socket等。在Asio中主要的io object的关系图如下：</p>
<p><img alt="IO Objects关系图" src="{attach}image\Asio\io_objects.jpg">
具体的类型及其功能包括：</p>
<ul>
<li>
<p><code>basic_deadline_timer</code> 提供定时器功能，可以同步等待，也可以异步等待。 </p>
</li>
<li>
<p><code>basic_waitable_timer</code> 和<code>basic_deadline_timer</code>具有同样的功能，主要区别为该定时器可以和C++ 11中引入的chrono库协作。 </p>
</li>
<li>
<p><code>basic_signal_set</code> 支持信号相关的操作，异步方式等待单个或者多个信号的发生。 </p>
</li>
<li>
<p><code>basic_socket_acceptor</code> 作为服务器进行侦听，接收连接请求。 </p>
</li>
<li>
<p><code>basic_serial_port</code> 对串口操作进行支持。 </p>
</li>
<li>
<p><code>basic_resolver</code> 地址解析类。 </p>
</li>
<li>
<p><code>basic_stream_socket</code> 提供同步、异步方式的基于流的socket操作。 </p>
</li>
<li>
<p><code>basic_datagram_socket</code> 提供同步、异步方式的基于数据报文的socket操作。 </p>
</li>
<li>
<p><code>basic_raw_socket</code>提供同步、异步方式的基于raw数据的socket操作 </p>
</li>
<li>
<p><code>basic_seq_packet_socket</code>提供同步、异步方式的基于有序包的socket操作 </p>
</li>
<li>
<p><code>basic_socket_streambuf</code> ? </p>
</li>
<li>
<p><code>basic_object_handle</code> 对windows handle的封装，可以以异步或者同步方式等待 </p>
</li>
<li>
<p><code>basic_random_access_handle</code>对windows 可随机访问的handle的封装，可以以异步或者同步方式等待 </p>
</li>
<li>
<p><code>basic_stream_handle</code>对windows面向流handle的封装，可以以异步或者同步方式等待 </p>
</li>
<li>
<p><code>basic_descriptor</code> 对POSIX描述符进行封装。</p>
</li>
</ul>
<p>最重要的一点：所有这些io object的构造函数，都要求有一个<code>io_service&amp;</code> 作为参数，使用这一参数，这些<code>io_object</code>对象知道了自己的归属，之后自己所要派发出去的同步、异步操作请求，都将通过自己所在的这个<code>io_service</code>对象来完成。这也就说明了，为什么创建<code>io_service</code>对象是整个Asio程序的第一步。</p>
<p>在使用时，我们并不直接使用这些basic 模板，而是使用这些basic模板的特化类型的别名，例如resolver</p>
<div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="n">basic_resolver</span><span class="o">&lt;</span><span class="n">tcp</span><span class="o">&gt;</span> <span class="n">resolver</span><span class="p">;</span>
</pre></div>


<p>这个用法在stl中很常见，例如cout/cin/string等都是一些basic模板的特化别名。</p>
<p>事实上，这些basic模板所做的也只是作为一些接口类，其具体任务都会被层层转接到asio::detail::service上。以resolver为例，当我们调用<code>async_resolve</code>时，会继续调用下一层的service</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">ResolveHandler</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">async_resolve</span><span class="p">(</span><span class="k">const</span> <span class="n">query</span><span class="o">&amp;</span> <span class="n">q</span><span class="p">,</span> <span class="n">BOOST_ASIO_MOVE_ARG</span><span class="p">(</span><span class="n">ResolveHandler</span><span class="p">)</span> <span class="n">handler</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">// If you get an error on the following line it means that your handler does</span>
<span class="c1">// not meet the documented type requirements for a ResolveHandler.</span>
<span class="n">BOOST_ASIO_RESOLVE_HANDLER_CHECK</span><span class="p">(</span>
    <span class="n">ResolveHandler</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="n">iterator</span><span class="p">)</span> <span class="n">type_check</span><span class="p">;</span>

<span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">service</span><span class="p">.</span><span class="n">async_resolve</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">implementation</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span>
    <span class="n">BOOST_ASIO_MOVE_CAST</span><span class="p">(</span><span class="n">ResolveHandler</span><span class="p">)(</span><span class="n">handler</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>


<p>这里的this-&gt;service 的类型是asio::ip::resolver_service，然而asio::ip::resolver_service并不算真正的执行者，他下面还有一层：</p>
<div class="highlight"><pre><span></span><span class="c1">/// Asynchronously resolve a query to a list of entries.</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">ResolveHandler</span><span class="o">&gt;</span>
<span class="n">BOOST_ASIO_INITFN_RESULT_TYPE</span><span class="p">(</span><span class="n">ResolveHandler</span><span class="p">,</span>
  <span class="kt">void</span> <span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="p">,</span> <span class="n">iterator_type</span><span class="p">))</span>
<span class="n">async_resolve</span><span class="p">(</span><span class="n">implementation_type</span><span class="o">&amp;</span> <span class="n">impl</span><span class="p">,</span> <span class="k">const</span> <span class="n">query_type</span><span class="o">&amp;</span> <span class="n">query</span><span class="p">,</span>
  <span class="n">BOOST_ASIO_MOVE_ARG</span><span class="p">(</span><span class="n">ResolveHandler</span><span class="p">)</span> <span class="n">handler</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">async_result_init</span><span class="o">&lt;</span>
  <span class="n">ResolveHandler</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="p">,</span> <span class="n">iterator_type</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">init</span><span class="p">(</span>
    <span class="n">BOOST_ASIO_MOVE_CAST</span><span class="p">(</span><span class="n">ResolveHandler</span><span class="p">)(</span><span class="n">handler</span><span class="p">));</span>

<span class="n">service_impl_</span><span class="p">.</span><span class="n">async_resolve</span><span class="p">(</span><span class="n">impl</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">init</span><span class="p">.</span><span class="n">handler</span><span class="p">);</span>

<span class="k">return</span> <span class="n">init</span><span class="p">.</span><span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p>然而，这里并不是终点，可以看出这里还有一层。这里的<code>service_impl_</code>的类型是<code>service_impl_type</code>，由这个类型名可以看出这个类型又是由宏定义的<code>typedef</code>，其真实类型是：</p>
<div class="highlight"><pre><span></span><span class="cp">#if defined(BOOST_ASIO_WINDOWS_RUNTIME)</span>
  <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">winrt_resolver_service</span><span class="o">&lt;</span><span class="n">InternetProtocol</span><span class="o">&gt;</span>
    <span class="n">service_impl_type</span><span class="p">;</span>
<span class="cp">#else</span>
  <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">resolver_service</span><span class="o">&lt;</span><span class="n">InternetProtocol</span><span class="o">&gt;</span>
    <span class="n">service_impl_type</span><span class="p">;</span>
<span class="cp">#endif</span>
</pre></div>


<p>这样我们继续跟踪<code>boost::asio::detail::resolver_service&lt;InternetProtocol&gt;</code>的<code>async_resolve</code></p>
<div class="highlight"><pre><span></span><span class="c1">// Asynchronously resolve a query to a list of entries.</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Handler</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">async_resolve</span><span class="p">(</span><span class="n">implementation_type</span><span class="o">&amp;</span> <span class="n">impl</span><span class="p">,</span>
  <span class="k">const</span> <span class="n">query_type</span><span class="o">&amp;</span> <span class="n">query</span><span class="p">,</span> <span class="n">Handler</span><span class="o">&amp;</span> <span class="n">handler</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">// Allocate and construct an operation to wrap the handler.</span>
<span class="k">typedef</span> <span class="n">resolve_op</span><span class="o">&lt;</span><span class="n">Protocol</span><span class="p">,</span> <span class="n">Handler</span><span class="o">&gt;</span> <span class="n">op</span><span class="p">;</span>
<span class="k">typename</span> <span class="n">op</span><span class="o">::</span><span class="n">ptr</span> <span class="n">p</span> <span class="o">=</span> <span class="p">{</span> <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="n">handler</span><span class="p">),</span>
  <span class="n">boost_asio_handler_alloc_helpers</span><span class="o">::</span><span class="n">allocate</span><span class="p">(</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">op</span><span class="p">),</span> <span class="n">handler</span><span class="p">),</span> <span class="mi">0</span> <span class="p">};</span>
<span class="n">p</span><span class="p">.</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">v</span><span class="p">)</span> <span class="n">op</span><span class="p">(</span><span class="n">impl</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">io_service_impl_</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span>

<span class="n">BOOST_ASIO_HANDLER_CREATION</span><span class="p">((</span><span class="n">p</span><span class="p">.</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;resolver&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">impl</span><span class="p">,</span> <span class="s">&quot;async_resolve&quot;</span><span class="p">));</span>

<span class="n">start_resolve_op</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">p</span><span class="p">);</span>
<span class="n">p</span><span class="p">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里的op是一个临时封装类，执行的时候最终还是由<code>start_resolve_op</code>:</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">resolver_service_base</span><span class="o">::</span><span class="n">start_resolve_op</span><span class="p">(</span><span class="n">operation</span><span class="o">*</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">start_work_thread</span><span class="p">();</span>
  <span class="n">io_service_impl_</span><span class="p">.</span><span class="n">work_started</span><span class="p">();</span>
  <span class="n">work_io_service_impl_</span><span class="p">.</span><span class="n">post_immediate_completion</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>前两个操作都是one shot 的执行，即如果之前的操作已经启动了thread和work的话，则相当于什么都没干。所以最终是post这个op到<code>io_service</code>上了。</p>
<h1>Operation</h1>
<p>在前面的resolver分析中，我们知道了最后的执行者是Operation，但是Operation最后是怎么与<code>io_service</code>服务的并没有说明。我们先来看Operation的类型定义：</p>
<div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">boost</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">asio</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">detail</span> <span class="p">{</span>

<span class="cp">#if defined(BOOST_ASIO_HAS_IOCP)</span>
<span class="k">typedef</span> <span class="n">win_iocp_operation</span> <span class="n">operation</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">typedef</span> <span class="n">task_io_service_operation</span> <span class="n">operation</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="p">}</span> <span class="c1">// namespace detail</span>
<span class="p">}</span> <span class="c1">// namespace asio</span>
<span class="p">}</span> <span class="c1">// namespace boost</span>
</pre></div>


<p>想必大家都已经开始呵呵了吧，在Asio里面要习惯这种事情啊。简单来说，在IOCP平台下，Operation的类型是<code>win_iocp_operation</code>；而在linux/unix平台下，Operation的类型是<code>task_io_service_operation</code>。</p>
<p>在Asio中，主要有如下的一些operation类型，这里标红色的是与IOCP有关的，白色的是与select/epoll/kqueue有关的。</p>
<p><img alt="IO objects 类图" src="{attach}image\Asio\operations.jpg"></p>
<h2>windows IO Operation</h2>
<p>在<code>win_iocp_operation</code>中，主要的内部函数及数据成员有如下几个：</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">complete</span><span class="p">(</span><span class="n">win_iocp_io_service</span><span class="o">&amp;</span> <span class="n">owner</span><span class="p">,</span>
<span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">,</span>
<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">bytes_transferred</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">func_</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owner</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">ec</span><span class="p">,</span> <span class="n">bytes_transferred</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">destroy</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">func_</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func_type</span><span class="p">)(</span>
<span class="n">win_iocp_io_service</span><span class="o">*</span><span class="p">,</span> <span class="n">win_iocp_operation</span><span class="o">*</span><span class="p">,</span>
<span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">);</span>

<span class="n">win_iocp_operation</span><span class="p">(</span><span class="n">func_type</span> <span class="n">func</span><span class="p">)</span>
<span class="o">:</span> <span class="n">next_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
<span class="n">func_</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">reset</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">win_iocp_operation</span><span class="o">*</span> <span class="n">next_</span><span class="p">;</span>
<span class="n">func_type</span> <span class="n">func_</span><span class="p">;</span>
</pre></div>


<p>从这几个核心成员可以看出，整个<code>win_iocp_operation</code>是一个侵入式的链表，封装了一个<code>func_</code>。从这个<code>func_</code>的类型签名就可以看出这非常像我们使用Asio时的回调函数，但又有一些区别。这个<code>func_</code>的初始化是在<code>win_iocp_operation</code>的各个子类的构造函数中进行的，同样以<code>resolver_op</code>为例:</p>
<div class="highlight"><pre><span></span><span class="n">resolve_op</span><span class="p">(</span><span class="n">socket_ops</span><span class="o">::</span><span class="n">weak_cancel_token_type</span> <span class="n">cancel_token</span><span class="p">,</span>
<span class="k">const</span> <span class="n">query_type</span><span class="o">&amp;</span> <span class="n">query</span><span class="p">,</span> <span class="n">io_service_impl</span><span class="o">&amp;</span> <span class="n">ios</span><span class="p">,</span> <span class="n">Handler</span><span class="o">&amp;</span> <span class="n">handler</span><span class="p">)</span>
<span class="o">:</span> <span class="n">operation</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resolve_op</span><span class="o">::</span><span class="n">do_complete</span><span class="p">),</span>
<span class="n">cancel_token_</span><span class="p">(</span><span class="n">cancel_token</span><span class="p">),</span>
<span class="n">query_</span><span class="p">(</span><span class="n">query</span><span class="p">),</span>
<span class="n">io_service_impl_</span><span class="p">(</span><span class="n">ios</span><span class="p">),</span>
<span class="n">handler_</span><span class="p">(</span><span class="n">BOOST_ASIO_MOVE_CAST</span><span class="p">(</span><span class="n">Handler</span><span class="p">)(</span><span class="n">handler</span><span class="p">)),</span>
<span class="n">addrinfo_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
</pre></div>


<p>这里的构造函数使用了自身的<code>resolve_op::do_complete</code>来初始化<code>func_</code>，其他类型的<code>operation</code>也会定义一个<code>do_complete</code>来初始化<code>func_</code>。也就是说，<code>func_</code>其实等价于一个虚函数，我们可以直接将其替换为<code>virtual do_complete=0</code>之类的函数声明，这样构造的时候就不再需要去赋值了。</p>
<p>将其修改为虚函数的解决方案看上去很美，但是这里我们忽略了一点，事实上<code>win_iocp_operation</code>是继承自OVERLAPPED这个类的：</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">win_iocp_operation</span>
  <span class="o">:</span> <span class="k">public</span> <span class="n">OVERLAPPED</span>
</pre></div>


<p>至于OVERLAPPED,之前谈及<code>IOCP</code>时也间接提到了，在<code>GetQueuedCompletionStatus</code>的签名中的第四个参数就是这个结构。该结构是Win32进行交叠IO一个非常重要的结构，用以异步执行过程中的参数传递。如果我们将<code>func_</code>更改为虚函数<code>do_complete</code>的话，<code>win_iocp_operation</code>的地址则不再是<code>OVERLAPPED</code>的地址，中间还差一个虚函数表的指针，改变了POD的内存布局。这样使得传参时必须使用<code>dynamic_cast</code>，这样有损效率，而且容易出错。所以Asio这里回避了虚函数这个monster，而是手动初始化<code>func_</code>。还需要注意一点，子类中的<code>do_complete</code>都是声明为静态函数的，这样才能与<code>func</code>的类型匹配。</p>
<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="n">do_complete</span><span class="p">(</span><span class="n">io_service_impl</span><span class="o">*</span> <span class="n">owner</span><span class="p">,</span> <span class="n">operation</span><span class="o">*</span> <span class="n">base</span><span class="p">,</span>
<span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="cm">/*ec*/</span><span class="p">,</span>
<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="cm">/*bytes_transferred*/</span><span class="p">)</span>
</pre></div>


<p>如果不是声明为<code>static</code>的话,则需要修改<code>func</code>的类型从函数指针到成员函数指针去，同时子类在构造的时候还需要使用<code>reinteprete_cast</code>将<code>son::*</code>转换为<code>father::*</code>。这样使用起来非常不优雅，所以最后选择了<code>static</code>这种机制。</p>
<p>至于<code>operation</code>具体做了什么，我们以recieve操作为例来讲解。在<code>win_iocp_socket_service_base</code>中，为了启动一个receive的异步操作, <code>start_receive_op</code>函数就直接把传递进来的operation指针作为OVERLAPPED结构传递给::WSARecv函数，从而发起一个异步服务请求。</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">win_iocp_socket_service_base</span><span class="o">::</span><span class="n">start_receive_op</span><span class="p">(</span>
    <span class="n">win_iocp_socket_service_base</span><span class="o">::</span><span class="n">base_implementation_type</span><span class="o">&amp;</span> <span class="n">impl</span><span class="p">,</span>
    <span class="n">WSABUF</span><span class="o">*</span> <span class="n">buffers</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">buffer_count</span><span class="p">,</span>
    <span class="n">socket_base</span><span class="o">::</span><span class="n">message_flags</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">noop</span><span class="p">,</span> <span class="n">operation</span><span class="o">*</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">update_cancellation_thread_id</span><span class="p">(</span><span class="n">impl</span><span class="p">);</span>
  <span class="n">iocp_service_</span><span class="p">.</span><span class="n">work_started</span><span class="p">();</span>
 
  <span class="k">if</span> <span class="p">(</span><span class="n">noop</span><span class="p">)</span>
    <span class="n">iocp_service_</span><span class="p">.</span><span class="n">on_completion</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
  <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_open</span><span class="p">(</span><span class="n">impl</span><span class="p">))</span>
    <span class="n">iocp_service_</span><span class="p">.</span><span class="n">on_completion</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">bad_descriptor</span><span class="p">);</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">bytes_transferred</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">recv_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">::</span><span class="n">WSARecv</span><span class="p">(</span><span class="n">impl</span><span class="p">.</span><span class="n">socket_</span><span class="p">,</span> <span class="n">buffers</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">DWORD</span><span class="o">&gt;</span><span class="p">(</span><span class="n">buffer_count</span><span class="p">),</span>
        <span class="o">&amp;</span><span class="n">bytes_transferred</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">recv_flags</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">DWORD</span> <span class="n">last_error</span> <span class="o">=</span> <span class="o">::</span><span class="n">WSAGetLastError</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">last_error</span> <span class="o">==</span> <span class="n">ERROR_NETNAME_DELETED</span><span class="p">)</span>
      <span class="n">last_error</span> <span class="o">=</span> <span class="n">WSAECONNRESET</span><span class="p">;</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">last_error</span> <span class="o">==</span> <span class="n">ERROR_PORT_UNREACHABLE</span><span class="p">)</span>
      <span class="n">last_error</span> <span class="o">=</span> <span class="n">WSAECONNREFUSED</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">last_error</span> <span class="o">!=</span> <span class="n">WSA_IO_PENDING</span><span class="p">)</span>
      <span class="n">iocp_service_</span><span class="p">.</span><span class="n">on_completion</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">last_error</span><span class="p">,</span> <span class="n">bytes_transferred</span><span class="p">);</span>
    <span class="k">else</span>
      <span class="n">iocp_service_</span><span class="p">.</span><span class="n">on_pending</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>这个函数做了一系列的错误判断之后，之后才通过<code>on_pending</code>操作把<code>op</code>挂在在完成端口上：</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">win_iocp_io_service</span><span class="o">::</span><span class="n">on_pending</span><span class="p">(</span><span class="n">win_iocp_operation</span><span class="o">*</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">::</span><span class="n">InterlockedCompareExchange</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">ready_</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Enqueue the operation on the I/O completion port.</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!::</span><span class="n">PostQueuedCompletionStatus</span><span class="p">(</span><span class="n">iocp_</span><span class="p">.</span><span class="n">handle</span><span class="p">,</span>
          <span class="mi">0</span><span class="p">,</span> <span class="n">overlapped_contains_result</span><span class="p">,</span> <span class="n">op</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="c1">// Out of resources. Put on completed queue instead.</span>
      <span class="n">mutex</span><span class="o">::</span><span class="n">scoped_lock</span> <span class="n">lock</span><span class="p">(</span><span class="n">dispatch_mutex_</span><span class="p">);</span>
      <span class="n">completed_ops_</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
      <span class="o">::</span><span class="n">InterlockedExchange</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dispatch_required_</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>当然，如果挂在不成功的话（系统忙时可能出现），我们就暂时存储这个<code>op</code>在一个备用队列上<code>completed_ops_</code>。</p>
<p>除了recieve_op，还有很多其他类型的op。各个op与async函数的对应关系见下表</p>
<p><img alt="IO对象与IOCP对应操作" src="{attach}image\Asio\operation_table.png"></p>
<h2>Linux IO Operation</h2>
<p>这里我们先来看一下回调函数的封装类，也就是<code>operation</code>对应的类，这个是放在<code>task_io_service_operation</code>中的。</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">task_io_service_operation</span> <span class="n">BOOST_ASIO_INHERIT_TRACKED_HANDLER</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">complete</span><span class="p">(</span><span class="n">task_io_service</span><span class="o">&amp;</span> <span class="n">owner</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">bytes_transferred</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">func_</span><span class="p">(</span><span class="o">&amp;</span><span class="n">owner</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">ec</span><span class="p">,</span> <span class="n">bytes_transferred</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">destroy</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">func_</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>

<span class="k">protected</span><span class="o">:</span>
  <span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func_type</span><span class="p">)(</span><span class="n">task_io_service</span><span class="o">*</span><span class="p">,</span>
      <span class="n">task_io_service_operation</span><span class="o">*</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">);</span>

  <span class="n">task_io_service_operation</span><span class="p">(</span><span class="n">func_type</span> <span class="n">func</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">next_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
      <span class="n">func_</span><span class="p">(</span><span class="n">func</span><span class="p">),</span>
      <span class="n">task_result_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="p">}</span>

  <span class="c1">// Prevents deletion through this type.</span>
  <span class="o">~</span><span class="n">task_io_service_operation</span><span class="p">()</span>
  <span class="p">{</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">op_queue_access</span><span class="p">;</span>
  <span class="n">task_io_service_operation</span><span class="o">*</span> <span class="n">next_</span><span class="p">;</span>
  <span class="n">func_type</span> <span class="n">func_</span><span class="p">;</span>
<span class="k">protected</span><span class="o">:</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">task_io_service</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">task_result_</span><span class="p">;</span> <span class="c1">// Passed into bytes transferred.</span>
<span class="p">};</span>
</pre></div>


<p>其实这个类看上去与<code>operation</code>类差不多，内部也包含了一个<code>func_type</code>的回调函数，也是使用子类的静态函数来做初始化的，也有一个<code>next</code>指针构造了一个侵入性链表。只不过不再继承自<code>OVERLAPD</code>结构体。这样，我们就定义了一个<code>CompletionHandle</code>。</p>
<p>这个类型只是参与管理回调的，我们还需要记录真正的<code>IO</code>操作是什么，执行<code>IO</code>然后再进行回调。同时记录了<code>IO</code>与<code>Completion Handle</code>的类型是<code>descriptor_state</code>,首先查看<code>descriptor_state</code>的类型定义：</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">descriptor_state</span> <span class="o">:</span> <span class="n">operation</span>
  <span class="p">{</span>
    <span class="k">friend</span> <span class="k">class</span> <span class="nc">epoll_reactor</span><span class="p">;</span>
    <span class="k">friend</span> <span class="k">class</span> <span class="nc">object_pool_access</span><span class="p">;</span>

    <span class="n">descriptor_state</span><span class="o">*</span> <span class="n">next_</span><span class="p">;</span>
    <span class="n">descriptor_state</span><span class="o">*</span> <span class="n">prev_</span><span class="p">;</span>

    <span class="n">mutex</span> <span class="n">mutex_</span><span class="p">;</span>
    <span class="n">epoll_reactor</span><span class="o">*</span> <span class="n">reactor_</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">descriptor_</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">registered_events_</span><span class="p">;</span>
    <span class="n">op_queue</span><span class="o">&lt;</span><span class="n">reactor_op</span><span class="o">&gt;</span> <span class="n">op_queue_</span><span class="p">[</span><span class="n">max_ops</span><span class="p">];</span>
    <span class="kt">bool</span> <span class="n">shutdown_</span><span class="p">;</span>

    <span class="n">BOOST_ASIO_DECL</span> <span class="nf">descriptor_state</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">set_ready_events</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">events</span><span class="p">)</span> <span class="p">{</span> <span class="n">task_result_</span> <span class="o">=</span> <span class="n">events</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">BOOST_ASIO_DECL</span> <span class="n">operation</span><span class="o">*</span> <span class="nf">perform_io</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">events</span><span class="p">);</span>
    <span class="n">BOOST_ASIO_DECL</span> <span class="k">static</span> <span class="kt">void</span> <span class="nf">do_complete</span><span class="p">(</span>
        <span class="n">io_service_impl</span><span class="o">*</span> <span class="n">owner</span><span class="p">,</span> <span class="n">operation</span><span class="o">*</span> <span class="n">base</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">bytes_transferred</span><span class="p">);</span>
  <span class="p">};</span>
</pre></div>


<p>这个类型继承自<code>operation</code>，而<code>do_complete</code>与之前我们提到的回调很像，同样的签名同样是<code>static</code>的，都是在构造函数中被传入<code>operation</code>之中。</p>
<div class="highlight"><pre><span></span><span class="n">epoll_reactor</span><span class="o">::</span><span class="n">descriptor_state</span><span class="o">::</span><span class="n">descriptor_state</span><span class="p">()</span>
  <span class="o">:</span> <span class="n">operation</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epoll_reactor</span><span class="o">::</span><span class="n">descriptor_state</span><span class="o">::</span><span class="n">do_complete</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">epoll_reactor</span><span class="o">::</span><span class="n">descriptor_state</span><span class="o">::</span><span class="n">do_complete</span><span class="p">(</span>
    <span class="n">io_service_impl</span><span class="o">*</span> <span class="n">owner</span><span class="p">,</span> <span class="n">operation</span><span class="o">*</span> <span class="n">base</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">bytes_transferred</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">owner</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">descriptor_state</span><span class="o">*</span> <span class="n">descriptor_data</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">descriptor_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
    <span class="kt">uint32_t</span> <span class="n">events</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bytes_transferred</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">operation</span><span class="o">*</span> <span class="n">op</span> <span class="o">=</span> <span class="n">descriptor_data</span><span class="o">-&gt;</span><span class="n">perform_io</span><span class="p">(</span><span class="n">events</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">op</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">(</span><span class="o">*</span><span class="n">owner</span><span class="p">,</span> <span class="n">ec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>这里的<code>perform_io</code>函数便是执行这项工作的：</p>
<div class="highlight"><pre><span></span><span class="n">operation</span><span class="o">*</span> <span class="n">epoll_reactor</span><span class="o">::</span><span class="n">descriptor_state</span><span class="o">::</span><span class="n">perform_io</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">events</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">mutex_</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
  <span class="n">perform_io_cleanup_on_block_exit</span> <span class="nf">io_cleanup</span><span class="p">(</span><span class="n">reactor_</span><span class="p">);</span>
  <span class="n">mutex</span><span class="o">::</span><span class="n">scoped_lock</span> <span class="n">descriptor_lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">,</span> <span class="n">mutex</span><span class="o">::</span><span class="n">scoped_lock</span><span class="o">::</span><span class="n">adopt_lock</span><span class="p">);</span>

  <span class="c1">// Exception operations must be processed first to ensure that any</span>
  <span class="c1">// out-of-band data is read before normal data.</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">[</span><span class="n">max_ops</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">EPOLLIN</span><span class="p">,</span> <span class="n">EPOLLOUT</span><span class="p">,</span> <span class="n">EPOLLPRI</span> <span class="p">};</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">max_ops</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">events</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">|</span> <span class="n">EPOLLERR</span> <span class="o">|</span> <span class="n">EPOLLHUP</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">reactor_op</span><span class="o">*</span> <span class="n">op</span> <span class="o">=</span> <span class="n">op_queue_</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">front</span><span class="p">())</span>
      <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">perform</span><span class="p">())</span>
        <span class="p">{</span>
          <span class="n">op_queue_</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">pop</span><span class="p">();</span>
          <span class="n">io_cleanup</span><span class="p">.</span><span class="n">ops_</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
          <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// The first operation will be returned for completion now. The others will</span>
  <span class="c1">// be posted for later by the io_cleanup object&#39;s destructor.</span>
  <span class="n">io_cleanup</span><span class="p">.</span><span class="n">first_op_</span> <span class="o">=</span> <span class="n">io_cleanup</span><span class="p">.</span><span class="n">ops_</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
  <span class="n">io_cleanup</span><span class="p">.</span><span class="n">ops_</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">io_cleanup</span><span class="p">.</span><span class="n">first_op_</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里的流程就是首先处理异常事件，这里的<code>EPOLLERR</code>和<code>EPOLLDHUP</code>好像都是处理异常断线的。然后开始处理存储在<code>op_queue_</code>中的<code>IO</code>任务，分别是如下几种：</p>
<div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">op_types</span> <span class="p">{</span> <span class="n">read_op</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">write_op</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">connect_op</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">except_op</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_ops</span> <span class="o">=</span> <span class="mi">3</span> <span class="p">};</span>
</pre></div>


<p>这三个队列的初始化到没有看见，估计都放在<code>async</code>之类操作里建立各种子类型然后初始化了。这个<code>reactor_op</code>的类型定义如下：</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">reactor_op</span>
  <span class="o">:</span> <span class="k">public</span> <span class="n">operation</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">// The error code to be passed to the completion handler.</span>
  <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span> <span class="n">ec_</span><span class="p">;</span>

  <span class="c1">// The number of bytes transferred, to be passed to the completion handler.</span>
  <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">bytes_transferred_</span><span class="p">;</span>

  <span class="c1">// Perform the operation. Returns true if it is finished.</span>
  <span class="kt">bool</span> <span class="nf">perform</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">perform_func_</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}</span>

<span class="k">protected</span><span class="o">:</span>
  <span class="k">typedef</span> <span class="kt">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">perform_func_type</span><span class="p">)(</span><span class="n">reactor_op</span><span class="o">*</span><span class="p">);</span>

  <span class="n">reactor_op</span><span class="p">(</span><span class="n">perform_func_type</span> <span class="n">perform_func</span><span class="p">,</span> <span class="n">func_type</span> <span class="n">complete_func</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">operation</span><span class="p">(</span><span class="n">complete_func</span><span class="p">),</span>
      <span class="n">bytes_transferred_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
      <span class="n">perform_func_</span><span class="p">(</span><span class="n">perform_func</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">perform_func_type</span> <span class="n">perform_func_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>这里的完成函数是放在<code>operation</code>里的，而<code>io</code>函数是放在自身的数据成员之中。</p>
<p>每次执行完<code>IO</code>之后，把对应的回调<code>operation</code>放入一个完成队列之中，等待进一步处理。</p>
<h1>strand</h1>
<p>这个<code>strand</code>类型的用途是用来序列化执行流的。在<code>Asio</code>中，由于回调函数是由线程池分发执行的，所以多个回调函数可能在不同的线程中操作一些公共的数据成员，例如共用标准输出导致输出错乱，这就引入了多线程同步的问题。要解决这种多线程同步的问题一般是使用同步原语，例如<code>mutex</code>和<code>cond_var</code>等。但是这些都是比较低级的原语，很容易用错，而我们所要求的仅仅是不可同时执行而已。所以<code>Asio</code>中引入了<code>strand</code>这个类型，来串行化回调函数的执行。</p>
<p>如果要使用<code>strand</code>，我们首先需要声明一个<code>strand</code>类型的对象，然后通过<code>strand.wrap</code>将回调函数包裹起来：</p>
<div class="highlight"><pre><span></span><span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">io_service</span><span class="o">::</span><span class="n">strand</span> <span class="n">strand_</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io</span><span class="p">);</span> <span class="c1">//注意io_service对象地址作为他的参数。</span>
<span class="n">timer1_</span><span class="p">.</span><span class="n">async_wait</span><span class="p">(</span><span class="n">strand_</span><span class="p">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printer</span><span class="o">::</span><span class="n">print1</span><span class="p">,</span> <span class="k">this</span><span class="p">)));</span>
<span class="n">timer2_</span><span class="p">.</span><span class="n">async_wait</span><span class="p">(</span><span class="n">strand_</span><span class="p">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printer</span><span class="o">::</span><span class="n">print2</span><span class="p">,</span> <span class="k">this</span><span class="p">)));</span>
</pre></div>


<p>这里的<code>wrap</code>会生成一个<code>wrapped_handler</code>对象：</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Handler</span><span class="o">&gt;</span>
<span class="cp">#if defined(GENERATING_DOCUMENTATION)</span>
<span class="n">unspecified</span>
<span class="cp">#else</span>
<span class="n">detail</span><span class="o">::</span><span class="n">wrapped_handler</span><span class="o">&lt;</span><span class="n">strand</span><span class="p">,</span> <span class="n">Handler</span><span class="p">,</span> <span class="n">detail</span><span class="o">::</span><span class="n">is_continuation_if_running</span><span class="o">&gt;</span>
<span class="cp">#endif</span>
<span class="n">wrap</span><span class="p">(</span><span class="n">Handler</span> <span class="n">handler</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">return</span> <span class="n">detail</span><span class="o">::</span><span class="n">wrapped_handler</span><span class="o">&lt;</span><span class="n">io_service</span><span class="o">::</span><span class="n">strand</span><span class="p">,</span> <span class="n">Handler</span><span class="p">,</span>
    <span class="n">detail</span><span class="o">::</span><span class="n">is_continuation_if_running</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>而这个<code>wrapped_handler</code>的主要内容见下：</p>
<div class="highlight"><pre><span></span><span class="n">wrapped_handler</span><span class="p">(</span><span class="n">Dispatcher</span> <span class="n">dispatcher</span><span class="p">,</span> <span class="n">Handler</span><span class="o">&amp;</span> <span class="n">handler</span><span class="p">)</span>
<span class="o">:</span> <span class="n">dispatcher_</span><span class="p">(</span><span class="n">dispatcher</span><span class="p">),</span>
  <span class="n">handler_</span><span class="p">(</span><span class="n">BOOST_ASIO_MOVE_CAST</span><span class="p">(</span><span class="n">Handler</span><span class="p">)(</span><span class="n">handler</span><span class="p">))</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="k">operator</span><span class="p">()()</span>
<span class="p">{</span>
    <span class="n">dispatcher_</span><span class="p">.</span><span class="n">dispatch</span><span class="p">(</span><span class="n">BOOST_ASIO_MOVE_CAST</span><span class="p">(</span><span class="n">Handler</span><span class="p">)(</span><span class="n">handler_</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>


<p>所以到头来还是调用了<code>strand.dispatch</code>函数：</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">CompletionHandler</span><span class="o">&gt;</span>
<span class="n">BOOST_ASIO_INITFN_RESULT_TYPE</span><span class="p">(</span><span class="n">CompletionHandler</span><span class="p">,</span> <span class="kt">void</span> <span class="p">())</span>
<span class="n">dispatch</span><span class="p">(</span><span class="n">BOOST_ASIO_MOVE_ARG</span><span class="p">(</span><span class="n">CompletionHandler</span><span class="p">)</span> <span class="n">handler</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// If you get an error on the following line it means that your handler does</span>
    <span class="c1">// not meet the documented type requirements for a CompletionHandler.</span>
    <span class="n">BOOST_ASIO_COMPLETION_HANDLER_CHECK</span><span class="p">(</span><span class="n">CompletionHandler</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span> <span class="n">type_check</span><span class="p">;</span>

    <span class="n">detail</span><span class="o">::</span><span class="n">async_result_init</span><span class="o">&lt;</span>
      <span class="n">CompletionHandler</span><span class="p">,</span> <span class="kt">void</span> <span class="p">()</span><span class="o">&gt;</span> <span class="n">init</span><span class="p">(</span>
        <span class="n">BOOST_ASIO_MOVE_CAST</span><span class="p">(</span><span class="n">CompletionHandler</span><span class="p">)(</span><span class="n">handler</span><span class="p">));</span>

    <span class="n">service_</span><span class="p">.</span><span class="n">dispatch</span><span class="p">(</span><span class="n">impl_</span><span class="p">,</span> <span class="n">init</span><span class="p">.</span><span class="n">handler</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">init</span><span class="p">.</span><span class="n">result</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p>这里又根据pimpl模式转接到了<code>boost::asio::detail::strand_service</code>上，这个<code>strand_service</code>里面有一个<code>io_service</code>的引用，但是实际任务还是根据pimpl规则放在<code>strand_impl</code>之中。这个类才真正承载了互斥操作：</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">strand_impl</span>
<span class="o">:</span> <span class="k">public</span> <span class="n">operation</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
    <span class="n">strand_impl</span><span class="p">();</span>

    <span class="k">private</span><span class="o">:</span>
    <span class="c1">// Only this service will have access to the internal values.</span>
    <span class="k">friend</span> <span class="k">class</span> <span class="nc">strand_service</span><span class="p">;</span>
    <span class="k">friend</span> <span class="k">struct</span> <span class="n">on_do_complete_exit</span><span class="p">;</span>
    <span class="k">friend</span> <span class="k">struct</span> <span class="n">on_dispatch_exit</span><span class="p">;</span>

    <span class="c1">// Mutex to protect access to internal data.</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mutex_</span><span class="p">;</span>

    <span class="c1">// Indicates whether the strand is currently &quot;locked&quot; by a handler. This</span>
    <span class="c1">// means that there is a handler upcall in progress, or that the strand</span>
    <span class="c1">// itself has been scheduled in order to invoke some pending handlers.</span>
    <span class="kt">bool</span> <span class="n">locked_</span><span class="p">;</span>

    <span class="c1">// The handlers that are waiting on the strand but should not be run until</span>
    <span class="c1">// after the next time the strand is scheduled. This queue must only be</span>
    <span class="c1">// modified while the mutex is locked.</span>
    <span class="n">op_queue</span><span class="o">&lt;</span><span class="n">operation</span><span class="o">&gt;</span> <span class="n">waiting_queue_</span><span class="p">;</span>

    <span class="c1">// The handlers that are ready to be run. Logically speaking, these are the</span>
    <span class="c1">// handlers that hold the strand&#39;s lock. The ready queue is only modified</span>
    <span class="c1">// from within the strand and so may be accessed without locking the mutex.</span>
    <span class="n">op_queue</span><span class="o">&lt;</span><span class="n">operation</span><span class="o">&gt;</span> <span class="n">ready_queue_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>继承了<code>operation</code>，同时还有<code>mutex</code>，就是他了！这个<code>mutex_</code>就是用来保护队列用的，而<code>waiting_queue</code>则是所有的等待执行的回调队列，<code>ready_queue_</code>则是可以执行的回调。而<code>locked_</code>则是表明这个<code>strand</code>里面是否已经有函数在执行。</p>
<p>而执行操作仍然把持在<code>strand_service</code>中：</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Handler</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">strand_service</span><span class="o">::</span><span class="n">dispatch</span><span class="p">(</span><span class="n">strand_service</span><span class="o">::</span><span class="n">implementation_type</span><span class="o">&amp;</span> <span class="n">impl</span><span class="p">,</span>
    <span class="n">Handler</span><span class="o">&amp;</span> <span class="n">handler</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// If we are already in the strand then the handler can run immediately.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">call_stack</span><span class="o">&lt;</span><span class="n">strand_impl</span><span class="o">&gt;::</span><span class="n">contains</span><span class="p">(</span><span class="n">impl</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="n">fenced_block</span> <span class="n">b</span><span class="p">(</span><span class="n">fenced_block</span><span class="o">::</span><span class="n">full</span><span class="p">);</span>
    <span class="n">boost_asio_handler_invoke_helpers</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="n">handler</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Allocate and construct an operation to wrap the handler.</span>
  <span class="k">typedef</span> <span class="n">completion_handler</span><span class="o">&lt;</span><span class="n">Handler</span><span class="o">&gt;</span> <span class="n">op</span><span class="p">;</span>
  <span class="k">typename</span> <span class="n">op</span><span class="o">::</span><span class="n">ptr</span> <span class="n">p</span> <span class="o">=</span> <span class="p">{</span> <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">addressof</span><span class="p">(</span><span class="n">handler</span><span class="p">),</span>
    <span class="n">boost_asio_handler_alloc_helpers</span><span class="o">::</span><span class="n">allocate</span><span class="p">(</span>
      <span class="k">sizeof</span><span class="p">(</span><span class="n">op</span><span class="p">),</span> <span class="n">handler</span><span class="p">),</span> <span class="mi">0</span> <span class="p">};</span>
  <span class="n">p</span><span class="p">.</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">v</span><span class="p">)</span> <span class="n">op</span><span class="p">(</span><span class="n">handler</span><span class="p">);</span>

  <span class="n">BOOST_ASIO_HANDLER_CREATION</span><span class="p">((</span><span class="n">p</span><span class="p">.</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;strand&quot;</span><span class="p">,</span> <span class="n">impl</span><span class="p">,</span> <span class="s">&quot;dispatch&quot;</span><span class="p">));</span>

  <span class="kt">bool</span> <span class="n">dispatch_immediately</span> <span class="o">=</span> <span class="n">do_dispatch</span><span class="p">(</span><span class="n">impl</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">p</span><span class="p">);</span>
  <span class="n">operation</span><span class="o">*</span> <span class="n">o</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">p</span><span class="p">;</span>
  <span class="n">p</span><span class="p">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">dispatch_immediately</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Indicate that this strand is executing on the current thread.</span>
    <span class="n">call_stack</span><span class="o">&lt;</span><span class="n">strand_impl</span><span class="o">&gt;::</span><span class="n">context</span> <span class="n">ctx</span><span class="p">(</span><span class="n">impl</span><span class="p">);</span>

    <span class="c1">// Ensure the next handler, if any, is scheduled on block exit.</span>
    <span class="n">on_dispatch_exit</span> <span class="n">on_exit</span> <span class="o">=</span> <span class="p">{</span> <span class="o">&amp;</span><span class="n">io_service_</span><span class="p">,</span> <span class="n">impl</span> <span class="p">};</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">on_exit</span><span class="p">;</span>

    <span class="n">completion_handler</span><span class="o">&lt;</span><span class="n">Handler</span><span class="o">&gt;::</span><span class="n">do_complete</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="n">io_service_</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>这里的执行流程是：首先判断当前线程是否已经在执行<code>strand</code>所包裹的函数。如果是的话，则说明当前函数是在<code>strand</code>内部被调用的，可以理解为尾递归。此时我们的句柄可以直接执行，类似于递归锁的机制。</p>
<p>否则我们就调用<code>do_dispatch</code>:</p>
<div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">strand_service</span><span class="o">::</span><span class="n">do_dispatch</span><span class="p">(</span><span class="n">implementation_type</span><span class="o">&amp;</span> <span class="n">impl</span><span class="p">,</span> <span class="n">operation</span><span class="o">*</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// If we are running inside the io_service, and no other handler already</span>
  <span class="c1">// holds the strand lock, then the handler can run immediately.</span>
  <span class="kt">bool</span> <span class="n">can_dispatch</span> <span class="o">=</span> <span class="n">io_service_</span><span class="p">.</span><span class="n">can_dispatch</span><span class="p">();</span>
  <span class="n">impl</span><span class="o">-&gt;</span><span class="n">mutex_</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">can_dispatch</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">impl</span><span class="o">-&gt;</span><span class="n">locked_</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Immediate invocation is allowed.</span>
    <span class="n">impl</span><span class="o">-&gt;</span><span class="n">locked_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">impl</span><span class="o">-&gt;</span><span class="n">mutex_</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">impl</span><span class="o">-&gt;</span><span class="n">locked_</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Some other handler already holds the strand lock. Enqueue for later.</span>
    <span class="n">impl</span><span class="o">-&gt;</span><span class="n">waiting_queue_</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
    <span class="n">impl</span><span class="o">-&gt;</span><span class="n">mutex_</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="c1">// The handler is acquiring the strand lock and so is responsible for</span>
    <span class="c1">// scheduling the strand.</span>
    <span class="n">impl</span><span class="o">-&gt;</span><span class="n">locked_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">impl</span><span class="o">-&gt;</span><span class="n">mutex_</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="n">impl</span><span class="o">-&gt;</span><span class="n">ready_queue_</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
    <span class="n">io_service_</span><span class="p">.</span><span class="n">post_immediate_completion</span><span class="p">(</span><span class="n">impl</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里才开始利用之前的<code>mutex</code>和<code>locked_</code>。另外还有一个标志位是<code>can_dispatch</code>，这个变量的值表示当前线程是否是<code>io_service</code>开的线程。如果不是<code>io_service</code>的运行线程则我们不能执行这个操作。话说这种情况好诡异。</p>
<p>然后获取队列锁，如果此时<code>strand</code>中没有函数在执行且当前线程可以调度的话，则我们直接返回<code>true</code>，让调用方直接执行<code>op</code>。执行完成之后会有一个<code>RAII</code>类<code>on_dispatch_exit</code>来将<code>locked_</code>设置为<code>false</code>。</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">strand_service</span><span class="o">::</span><span class="n">on_dispatch_exit</span>
<span class="p">{</span>
  <span class="n">io_service_impl</span><span class="o">*</span> <span class="n">io_service_</span><span class="p">;</span>
  <span class="n">strand_impl</span><span class="o">*</span> <span class="n">impl_</span><span class="p">;</span>

  <span class="o">~</span><span class="n">on_dispatch_exit</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">impl_</span><span class="o">-&gt;</span><span class="n">mutex_</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
    <span class="n">impl_</span><span class="o">-&gt;</span><span class="n">ready_queue_</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">impl_</span><span class="o">-&gt;</span><span class="n">waiting_queue_</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">more_handlers</span> <span class="o">=</span> <span class="n">impl_</span><span class="o">-&gt;</span><span class="n">locked_</span> <span class="o">=</span> <span class="o">!</span><span class="n">impl_</span><span class="o">-&gt;</span><span class="n">ready_queue_</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
    <span class="n">impl_</span><span class="o">-&gt;</span><span class="n">mutex_</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">more_handlers</span><span class="p">)</span>
      <span class="n">io_service_</span><span class="o">-&gt;</span><span class="n">post_immediate_completion</span><span class="p">(</span><span class="n">impl_</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>饿，好像跟我设想的不太一样啊，执行完成之后直接把等待队列的全扔进就绪队列，如果最后的就绪队列里面还有任务，则当前线程不停的执行这些任务。这样的设计简直机智啊。</p>
<p>如果其他的线程正在执行当前<code>strand</code>中的一个函数，则将当前函数放入等待队列；否则放在就绪队列，并将此<code>impl</code>放入完成事件中进行等待。</p>
<h1>Asio 实现概览</h1>
<p>总的来说，这些io object 都算 initiator的范畴,启动一个异步操作之后，转接相应的服务类最后到具体的平台相关的xxx_service_impl post 对应的op到io_service上。</p>
<p>因此Asio的总体体系结构可以分为3层：io object 层，basic 模板层和服务层。</p>
<ul>
<li>
<p>io object 层，作为应用程序直接使用的对象，是各种basic模板类的typedef实例类型；</p>
</li>
<li>
<p>basic 模板类层，提供对外操作的接口，并把具体操作转发给服务层；</p>
</li>
<li>
<p>服务层，提供具体操作的底层实现，又可分为操作转接层和平台实现层。</p>
</li>
</ul>
<p>通过对Asio中主要对象类型的交互，我们可以推断出整个异步操作的执行流程就是：</p>
<ul>
<li>
<p>建立<code>io_service</code>，并在此<code>io_service</code>之上建立一些<code>io objects</code></p>
</li>
<li>
<p>通过<code>io objects</code>调用异步操作，例如async_connect;</p>
</li>
<li>
<p>通过多层的service转接，最后生成对应的operation，并把完成handle托付给这个operation；</p>
</li>
<li>
<p>发起异步操作，并将operation对象传递给平台实现相关的service，最后调用平台原生操作;</p>
</li>
<li>
<p>操作系统接受IO请求，执行IO操作；</p>
</li>
<li>
<p>IOCP是等待异步等待操作完成，其他平台是等待<code>IO</code>可以进行；</p>
</li>
<li>
<p>等待条件满足之后，执行下一个函数，IOCP是回调函数，非IOCP是真正的IO函数之后串联回调函数；</p>
</li>
</ul>
<h1>win io service 实现</h1>
<p>在windows平台上，IOCP已经提供了很多异步操作的功能，所以相对来说 <code>win_iocp_io_service</code>比 <code>task_io_service</code>简单点，所以我们先来分析<code>win_iocp_io_service</code>的实现。</p>
<p>根据我们在之前对IOCP的分析，IOCP的使用流程可以分为如下几个步骤：</p>
<ul>
<li>
<p>使用Win函数CreateIoCompletionPort()创建一个完成端口对象； </p>
</li>
<li>
<p>创建一个IO对象，如用于listen的socket对象,并通过CreateIoCompletionPort()函数将创建的对象绑定到第一步中的完成端口中。</p>
</li>
<li>
<p>创建一个线程或者线程池，用以服务完成端口事件；所有这些线程调用GetQueuedCompletionStatus()函数等待一个完成端口事件的到来；</p>
</li>
<li>
<p>IO对象进行异步调用，例如WSASend()等操作。 </p>
</li>
<li>
<p>在系统执行完异步操作并把事件投递到端口上，或者客户自己调用了PostQueuedCompletionStatus()函数，使得在完成端口上等待的一个线程苏醒，执行后续的服务操作。</p>
</li>
</ul>
<p>现在我们去Asio中寻找执行这些流程的具体代码。首先我们来看完成端口的创建，这个是在<code>win_iocp_io_service</code>的构造函数中调用的：</p>
<div class="highlight"><pre><span></span><span class="n">win_iocp_io_service</span><span class="o">::</span><span class="n">win_iocp_io_service</span><span class="p">(</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">io_service</span><span class="o">&amp;</span> <span class="n">io_service</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">concurrency_hint</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">service_base</span><span class="o">&lt;</span><span class="n">win_iocp_io_service</span><span class="o">&gt;</span><span class="p">(</span><span class="n">io_service</span><span class="p">),</span>
    <span class="n">iocp_</span><span class="p">(),</span>
    <span class="n">outstanding_work_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
    <span class="n">stopped_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
    <span class="n">stop_event_posted_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
    <span class="n">shutdown_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
    <span class="n">gqcs_timeout_</span><span class="p">(</span><span class="n">get_gqcs_timeout</span><span class="p">()),</span>
    <span class="n">dispatch_required_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">BOOST_ASIO_HANDLER_TRACKING_INIT</span><span class="p">;</span>

  <span class="n">iocp_</span><span class="p">.</span><span class="n">handle</span> <span class="o">=</span> <span class="o">::</span><span class="n">CreateIoCompletionPort</span><span class="p">(</span><span class="n">INVALID_HANDLE_VALUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
      <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">DWORD</span><span class="o">&gt;</span><span class="p">(</span><span class="n">concurrency_hint</span> <span class="o">&lt;</span> <span class="n">DWORD</span><span class="p">(</span><span class="o">~</span><span class="mi">0</span><span class="p">)</span>
        <span class="o">?</span> <span class="nl">concurrency_hint</span> <span class="p">:</span> <span class="n">DWORD</span><span class="p">(</span><span class="o">~</span><span class="mi">0</span><span class="p">)));</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iocp_</span><span class="p">.</span><span class="n">handle</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">last_error</span> <span class="o">=</span> <span class="o">::</span><span class="n">GetLastError</span><span class="p">();</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span> <span class="n">ec</span><span class="p">(</span><span class="n">last_error</span><span class="p">,</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">get_system_category</span><span class="p">());</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">throw_error</span><span class="p">(</span><span class="n">ec</span><span class="p">,</span> <span class="s">&quot;iocp&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>这里的<code>iocp_</code>是一个RAII类型，封装了完成端口的析构操作：</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">auto_handle</span>
<span class="p">{</span>
<span class="n">HANDLE</span> <span class="n">handle</span><span class="p">;</span>
<span class="n">auto_handle</span><span class="p">()</span> <span class="o">:</span> <span class="n">handle</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
<span class="o">~</span><span class="n">auto_handle</span><span class="p">()</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="n">handle</span><span class="p">)</span> <span class="o">::</span><span class="n">CloseHandle</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// The IO completion port used for queueing operations.</span>
<span class="n">auto_handle</span> <span class="n">iocp_</span><span class="p">;</span>
</pre></div>


<p>因此，每一个<code>io_service</code>都会对应着一个完成端口。</p>
<p>现在我们来考虑完成端口的绑定问题。在创建<code>io objects</code>时，我们需要把这些对象绑定到完成端口之上，这里<code>win_iocp_io_service</code>提供了绑定服务：</p>
<div class="highlight"><pre><span></span><span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span> <span class="n">win_iocp_io_service</span><span class="o">::</span><span class="n">register_handle</span><span class="p">(</span>
    <span class="n">HANDLE</span> <span class="n">handle</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">::</span><span class="n">CreateIoCompletionPort</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">iocp_</span><span class="p">.</span><span class="n">handle</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">last_error</span> <span class="o">=</span> <span class="o">::</span><span class="n">GetLastError</span><span class="p">();</span>
    <span class="n">ec</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="p">(</span><span class="n">last_error</span><span class="p">,</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">get_system_category</span><span class="p">());</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">ec</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">ec</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>所以这些对象的构造函数都会带有<code>io_service&amp;</code>的参数，就是为了绑定完成端口使用的。我们来看一下这个函数的调用方是如何使用<code>register_handle</code>的：</p>
<div class="highlight"><pre><span></span><span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span> <span class="n">win_iocp_socket_service_base</span><span class="o">::</span><span class="n">do_open</span><span class="p">(</span>
    <span class="n">win_iocp_socket_service_base</span><span class="o">::</span><span class="n">base_implementation_type</span><span class="o">&amp;</span> <span class="n">impl</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">family</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">is_open</span><span class="p">(</span><span class="n">impl</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="n">ec</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">already_open</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">ec</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">socket_holder</span> <span class="n">sock</span><span class="p">(</span><span class="n">socket_ops</span><span class="o">::</span><span class="n">socket</span><span class="p">(</span><span class="n">family</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">ec</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">==</span> <span class="n">invalid_socket</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ec</span><span class="p">;</span>

  <span class="n">HANDLE</span> <span class="n">sock_as_handle</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">HANDLE</span><span class="o">&gt;</span><span class="p">(</span><span class="n">sock</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">iocp_service_</span><span class="p">.</span><span class="n">register_handle</span><span class="p">(</span><span class="n">sock_as_handle</span><span class="p">,</span> <span class="n">ec</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">ec</span><span class="p">;</span>

  <span class="n">impl</span><span class="p">.</span><span class="n">socket_</span> <span class="o">=</span> <span class="n">sock</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="k">case</span> <span class="nl">SOCK_STREAM</span><span class="p">:</span> <span class="n">impl</span><span class="p">.</span><span class="n">state_</span> <span class="o">=</span> <span class="n">socket_ops</span><span class="o">::</span><span class="n">stream_oriented</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="nl">SOCK_DGRAM</span><span class="p">:</span> <span class="n">impl</span><span class="p">.</span><span class="n">state_</span> <span class="o">=</span> <span class="n">socket_ops</span><span class="o">::</span><span class="n">datagram_oriented</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="k">default</span><span class="o">:</span> <span class="n">impl</span><span class="p">.</span><span class="n">state_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">impl</span><span class="p">.</span><span class="n">cancel_token_</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">socket_ops</span><span class="o">::</span><span class="n">noop_deleter</span><span class="p">());</span>
  <span class="n">ec</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">ec</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>简而言之呢，就是每个<code>socket</code>打开之后都会绑定在完成端口上。其实还有一个<code>do_assign</code>函数也调用了<code>register_handle</code>，这可函数可以当作拷贝构造函数吧，反正执行流与<code>do_open</code>差不多，只不过不会再构造一个新的<code>socket</code>了。</p>
<p>服务和对象都创建好了之后，我们需要一个线程池来执行任务。创建线程池在<code>Asio</code>中还是比较简单的：</p>
<div class="highlight"><pre><span></span><span class="n">thread1</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">io_service</span><span class="p">.</span><span class="n">run</span><span class="p">);</span>
<span class="n">thread1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</pre></div>


<p>这样就可以为这个<code>io_service</code>增加一个线程执行单元了。</p>
<p>到具体平台执行层，这个<code>run</code>函数会委托到<code>win_io_iocp_service::run</code>来执行，这个函数的实现见下：</p>
<div class="highlight"><pre><span></span><span class="kt">size_t</span> <span class="n">win_iocp_io_service</span><span class="o">::</span><span class="n">run</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">::</span><span class="n">InterlockedExchangeAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">outstanding_work_</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">stop</span><span class="p">();</span>
    <span class="n">ec</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
 
  <span class="n">win_iocp_thread_info</span> <span class="n">this_thread</span><span class="p">;</span>
  <span class="n">thread_call_stack</span><span class="o">::</span><span class="n">context</span> <span class="n">ctx</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">this_thread</span><span class="p">);</span>
 
  <span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">while</span> <span class="p">(</span><span class="n">do_one</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">ec</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">)())</span>
      <span class="o">++</span><span class="n">n</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>首先检查是否有未完成的操作，如果没有直接返回。否则将当前线程加入线程列表，然后开始循环的<code>do_one</code>来完成一个回调，每完成一个计数加一。</p>
<p>所有的任务都委托到了<code>do_one</code>中，这个才会与完成队列直接交互。这个函数的实现大约有110多行，这里我们分部分来分析。这个函数的整个函数体都被放在一个无限循环之中：</p>
<div class="highlight"><pre><span></span>  <span class="k">for</span> <span class="p">(;;)</span>
</pre></div>


<p>每次循环的头部是首先获得由于系统忙而导致未投递出的任务：</p>
<div class="highlight"><pre><span></span><span class="c1">// Try to acquire responsibility for dispatching timers and completed ops.</span>
<span class="k">if</span> <span class="p">(</span><span class="o">::</span><span class="n">InterlockedCompareExchange</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dispatch_required_</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">mutex</span><span class="o">::</span><span class="n">scoped_lock</span> <span class="n">lock</span><span class="p">(</span><span class="n">dispatch_mutex_</span><span class="p">);</span>

  <span class="c1">// Dispatch pending timers and operations.</span>
  <span class="n">op_queue</span><span class="o">&lt;</span><span class="n">win_iocp_operation</span><span class="o">&gt;</span> <span class="n">ops</span><span class="p">;</span>
  <span class="n">ops</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">completed_ops_</span><span class="p">);</span>
  <span class="n">timer_queues_</span><span class="p">.</span><span class="n">get_ready_timers</span><span class="p">(</span><span class="n">ops</span><span class="p">);</span>
  <span class="n">post_deferred_completions</span><span class="p">(</span><span class="n">ops</span><span class="p">);</span>
  <span class="n">update_timeout</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p>这里的<code>dispatch_required_</code>记录了是否有未投递出去的任务，取值范围只有0和1。而<code>completed_ops_</code>则存储了这些未成功投递的任务，每次循环都要把这些任务重新投递一次。</p>
<p>处理完未投递任务之后，我们开始在完成端口上等待一个事件的完成，或者超时：</p>
<div class="highlight"><pre><span></span><span class="c1">// Get the next operation from the queue.</span>
<span class="n">DWORD</span> <span class="n">bytes_transferred</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">dword_ptr_t</span> <span class="n">completion_key</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">LPOVERLAPPED</span> <span class="n">overlapped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="o">::</span><span class="n">SetLastError</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">BOOL</span> <span class="n">ok</span> <span class="o">=</span> <span class="o">::</span><span class="n">GetQueuedCompletionStatus</span><span class="p">(</span><span class="n">iocp_</span><span class="p">.</span><span class="n">handle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bytes_transferred</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">completion_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">overlapped</span><span class="p">,</span> <span class="n">block</span> <span class="o">?</span> <span class="nl">gqcs_timeout_</span> <span class="p">:</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">DWORD</span> <span class="n">last_error</span> <span class="o">=</span> <span class="o">::</span><span class="n">GetLastError</span><span class="p">();</span>
</pre></div>


<p>在得到了一个完成事件或者超时之后，我们检查返回的<code>OVERLAPPED</code>结构。如果有效的话，则转换为<code>operation</code>结构，因为<code>operation</code>结构是直接继承自<code>OVERLAPPED</code>的。</p>
<div class="highlight"><pre><span></span><span class="n">win_iocp_operation</span><span class="o">*</span> <span class="n">op</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">win_iocp_operation</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">overlapped</span><span class="p">);</span>
<span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span> <span class="n">result_ec</span><span class="p">(</span><span class="n">last_error</span><span class="p">,</span>
  <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">error</span><span class="o">::</span><span class="n">get_system_category</span><span class="p">());</span>
</pre></div>


<p>在做任何操作之间首先检查是否异常，然后再做后续的操作：</p>
<div class="highlight"><pre><span></span><span class="c1">// We may have been passed the last_error and bytes_transferred in the</span>
<span class="c1">// OVERLAPPED structure itself.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">completion_key</span> <span class="o">==</span> <span class="n">overlapped_contains_result</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">result_ec</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">Offset</span><span class="p">),</span>
    <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_category</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">Internal</span><span class="p">));</span>
<span class="n">bytes_transferred</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">OffsetHigh</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Otherwise ensure any result has been saved into the OVERLAPPED</span>
<span class="c1">// structure.</span>
<span class="k">else</span>
<span class="p">{</span>
<span class="n">op</span><span class="o">-&gt;</span><span class="n">Internal</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">ulong_ptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result_ec</span><span class="p">.</span><span class="n">category</span><span class="p">());</span>
<span class="n">op</span><span class="o">-&gt;</span><span class="n">Offset</span> <span class="o">=</span> <span class="n">result_ec</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
<span class="n">op</span><span class="o">-&gt;</span><span class="n">OffsetHigh</span> <span class="o">=</span> <span class="n">bytes_transferred</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这个所谓的后续操作就是调用我们之前设置的回调函数，即<code>operation.complete</code>:</p>
<div class="highlight"><pre><span></span><span class="c1">// Dispatch the operation only if ready. The operation may not be ready</span>
<span class="c1">// if the initiating function (e.g. a call to WSARecv) has not yet</span>
<span class="c1">// returned. This is because the initiating function still wants access</span>
<span class="c1">// to the operation&#39;s OVERLAPPED structure.</span>
<span class="k">if</span> <span class="p">(</span><span class="o">::</span><span class="n">InterlockedCompareExchange</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">ready_</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Ensure the count of outstanding work is decremented on block exit.</span>
    <span class="n">work_finished_on_block_exit</span> <span class="n">on_exit</span> <span class="o">=</span> <span class="p">{</span> <span class="k">this</span> <span class="p">};</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">on_exit</span><span class="p">;</span>

    <span class="n">op</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">result_ec</span><span class="p">,</span> <span class="n">bytes_transferred</span><span class="p">);</span>
    <span class="n">ec</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里的<code>work_finished_on_block_exit</code>又是一个<code>RAII</code>类，其唯一动作就是将<code>outstanding_work_</code>减1。自此，一个IO事件就算彻底完成了。</p>
<p>上面的代码已经说明了任务是怎么消费的，但是任务是如何添加的我们还没有搞清楚。在<code>windows</code>上，我们可通过两种形式往完成队列添加信息：</p>
<ul>
<li>
<p>一个是异步操作完成，操作系统自己通过完成端口添加完成事件；</p>
</li>
<li>
<p>另外一个是手动调用<code>PostQueuedCompletionStatus</code>函数往完成端口添加完成事件。</p>
</li>
</ul>
<p>一般的异步操作都是第一种情形，例如<code>async_read</code>和<code>async_write</code>。但是有些操作并没有利用重叠IO机制，需要手动添加完成事件。例如：</p>
<ul>
<li>
<p><code>async_resolver</code> 这个操作系统并没有提供对应的重叠IO操作；</p>
</li>
<li>
<p><code>async_connect</code> 这个是Asio作者并没有采用支持重叠IO的<code>ConnectEx</code>函数；</p>
</li>
<li>
<p><code>io_service</code>自带的<code>post</code>和<code>dispatch</code>操作，压根就不属于IO范围，只不过复用了多线程处理队列而已。</p>
</li>
</ul>
<p>对于这些类型的完成事件的提交，都会调用<code>post_immediate_completion</code>来处理。这个函数只会将<code>outstanding_work_</code>加1，然后调用<code>post_deferred_completion</code>。</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">win_iocp_io_service</span><span class="o">::</span><span class="n">post_deferred_completion</span><span class="p">(</span><span class="n">win_iocp_operation</span><span class="o">*</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Flag the operation as ready.</span>
  <span class="n">op</span><span class="o">-&gt;</span><span class="n">ready_</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="c1">// Enqueue the operation on the I/O completion port.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!::</span><span class="n">PostQueuedCompletionStatus</span><span class="p">(</span><span class="n">iocp_</span><span class="p">.</span><span class="n">handle</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">op</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="c1">// Out of resources. Put on completed queue instead.</span>
    <span class="n">mutex</span><span class="o">::</span><span class="n">scoped_lock</span> <span class="n">lock</span><span class="p">(</span><span class="n">dispatch_mutex_</span><span class="p">);</span>
    <span class="n">completed_ops_</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
    <span class="o">::</span><span class="n">InterlockedExchange</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dispatch_required_</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>这个函数只是将这些完成事件放到一个待处理的队列之中，最后一整批的放入系统的完成端口上：</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">win_iocp_io_service</span><span class="o">::</span><span class="n">post_deferred_completions</span><span class="p">(</span>
    <span class="n">op_queue</span><span class="o">&lt;</span><span class="n">win_iocp_operation</span><span class="o">&gt;&amp;</span> <span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">win_iocp_operation</span><span class="o">*</span> <span class="n">op</span> <span class="o">=</span> <span class="n">ops</span><span class="p">.</span><span class="n">front</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="n">ops</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

    <span class="c1">// Flag the operation as ready.</span>
    <span class="n">op</span><span class="o">-&gt;</span><span class="n">ready_</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// Enqueue the operation on the I/O completion port.</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!::</span><span class="n">PostQueuedCompletionStatus</span><span class="p">(</span><span class="n">iocp_</span><span class="p">.</span><span class="n">handle</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">op</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="c1">// Out of resources. Put on completed queue instead.</span>
      <span class="n">mutex</span><span class="o">::</span><span class="n">scoped_lock</span> <span class="n">lock</span><span class="p">(</span><span class="n">dispatch_mutex_</span><span class="p">);</span>
      <span class="n">completed_ops_</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
      <span class="n">completed_ops_</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">ops</span><span class="p">);</span>
      <span class="o">::</span><span class="n">InterlockedExchange</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dispatch_required_</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>这个函数的调用时机就是每次<code>do_one</code>循环的开头，通过检查<code>dispatch_required_</code>来判断这个<code>ops</code>是不是空，如果不为空则调用此函数。</p>
<h1>task io service 实现</h1>
<p>在无IOCP支持的情况下，Asio可用的只有<code>select/poll/epoll/kqueue</code>之类的多路复用模式（windows也支持select，不过较弱，限制较多）。</p>
<p>而<code>task_io_service</code>这个类本身也是一个接口类，基本提供了与<code>win_iocp_io_service</code>等价的接口，同时会把操作转接到<code>select/poll/epoll/kqueue</code>之上去，我们这里就分析一下基于<code>epoll</code>的实现。</p>
<p>同样的，我们都以<code>run</code>这个函数为入口：</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">task_io_service</span><span class="o">::</span><span class="n">run</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">ec</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">outstanding_work_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">stop</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">thread_info</span> <span class="n">this_thread</span><span class="p">;</span>
  <span class="n">this_thread</span><span class="p">.</span><span class="n">private_outstanding_work</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">thread_call_stack</span><span class="o">::</span><span class="n">context</span> <span class="n">ctx</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">this_thread</span><span class="p">);</span>

  <span class="n">mutex</span><span class="o">::</span><span class="n">scoped_lock</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(;</span> <span class="n">do_run_one</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="n">this_thread</span><span class="p">,</span> <span class="n">ec</span><span class="p">);</span> <span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">())</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">)())</span>
      <span class="o">++</span><span class="n">n</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>首先构造一个<code>thread_info</code>，和<code>first_idle_thread_</code>类型相同，即通过<code>first_idle_thread_</code>将所有线程串联起来，它这个串联不是立即串联的，当该线程无任务可做是加入到<code>first_idle_thread_</code>的首部，有任务执行时，从<code>first_idle_thread_</code>中断开。这很正常，因为<code>first_idle_thread_</code>维护的是当前空闲线程。</p>
<p>这里与<code>iocp_service</code>不同的地方就是有了一个<code>lock</code>，这个lock是用来互斥访问<code>task_io_service</code>的数据的；同时<code>do_one</code>函数改为了<code>do_run_one</code>。所有的四个具体的执行函数的参数中都有这个<code>lock</code>:</p>
<div class="highlight"><pre><span></span><span class="c1">// Run at most one operation. May block.</span>
<span class="n">BOOST_ASIO_DECL</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">do_run_one</span><span class="p">(</span><span class="n">mutex</span><span class="o">::</span><span class="n">scoped_lock</span><span class="o">&amp;</span> <span class="n">lock</span><span class="p">,</span>
  <span class="n">thread_info</span><span class="o">&amp;</span> <span class="n">this_thread</span><span class="p">,</span> <span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">);</span>

<span class="c1">// Poll for at most one operation.</span>
<span class="n">BOOST_ASIO_DECL</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">do_poll_one</span><span class="p">(</span><span class="n">mutex</span><span class="o">::</span><span class="n">scoped_lock</span><span class="o">&amp;</span> <span class="n">lock</span><span class="p">,</span>
  <span class="n">thread_info</span><span class="o">&amp;</span> <span class="n">this_thread</span><span class="p">,</span> <span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">);</span>

<span class="c1">// Stop the task and all idle threads.</span>
<span class="n">BOOST_ASIO_DECL</span> <span class="kt">void</span> <span class="nf">stop_all_threads</span><span class="p">(</span><span class="n">mutex</span><span class="o">::</span><span class="n">scoped_lock</span><span class="o">&amp;</span> <span class="n">lock</span><span class="p">);</span>

<span class="c1">// Wake a single idle thread, or the task, and always unlock the mutex.</span>
<span class="n">BOOST_ASIO_DECL</span> <span class="kt">void</span> <span class="nf">wake_one_thread_and_unlock</span><span class="p">(</span>
  <span class="n">mutex</span><span class="o">::</span><span class="n">scoped_lock</span><span class="o">&amp;</span> <span class="n">lock</span><span class="p">);</span>
</pre></div>


<p>这里我们继续跟进<code>do_run_one</code>函数，看看他干了些什么：</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">task_io_service</span><span class="o">::</span><span class="n">do_run_one</span><span class="p">(</span><span class="n">mutex</span><span class="o">::</span><span class="n">scoped_lock</span><span class="o">&amp;</span> <span class="n">lock</span><span class="p">,</span>
    <span class="n">task_io_service</span><span class="o">::</span><span class="n">thread_info</span><span class="o">&amp;</span> <span class="n">this_thread</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">system</span><span class="o">::</span><span class="n">error_code</span><span class="o">&amp;</span> <span class="n">ec</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">stopped_</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">op_queue_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="c1">// Prepare to execute first handler from queue.</span>
      <span class="n">operation</span><span class="o">*</span> <span class="n">o</span> <span class="o">=</span> <span class="n">op_queue_</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
      <span class="n">op_queue_</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
      <span class="kt">bool</span> <span class="n">more_handlers</span> <span class="o">=</span> <span class="p">(</span><span class="o">!</span><span class="n">op_queue_</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span>

      <span class="c1">//执行具体任务</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="n">wakeup_event_</span><span class="p">.</span><span class="n">clear</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
      <span class="n">wakeup_event_</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里的操作就是每次从<code>op_queue</code>（其实是一个侵入性链表）里拿出头节点，然后处理。如果这个队列为空，那么就等待。</p>
<p>又根据与一个特殊的<code>task_operation_</code>的比较结果，这里的具体执行任务分为了两种情况。</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">o</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">task_operation_</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">task_interrupted_</span> <span class="o">=</span> <span class="n">more_handlers</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">more_handlers</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">one_thread_</span><span class="p">)</span>
      <span class="n">wakeup_event_</span><span class="p">.</span><span class="n">unlock_and_signal_one</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
    <span class="k">else</span>
      <span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>

    <span class="n">task_cleanup</span> <span class="n">on_exit</span> <span class="o">=</span> <span class="p">{</span> <span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">this_thread</span> <span class="p">};</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">on_exit</span><span class="p">;</span>

    <span class="c1">// Run the task. May throw an exception. Only block if the operation</span>
    <span class="c1">// queue is empty and we&#39;re not polling, otherwise we want to return</span>
    <span class="c1">// as soon as possible.</span>
    <span class="n">task_</span><span class="o">-&gt;</span><span class="n">run</span><span class="p">(</span><span class="o">!</span><span class="n">more_handlers</span><span class="p">,</span> <span class="n">this_thread</span><span class="p">.</span><span class="n">private_op_queue</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>


<p>这里的逻辑就比较诡异了，首先做的是：</p>
<div class="highlight"><pre><span></span><span class="c1">// Operation object to represent the position of the task in the queue.</span>
<span class="k">struct</span> <span class="nl">task_operation</span> <span class="p">:</span> <span class="n">operation</span>
<span class="p">{</span>
    <span class="n">task_operation</span><span class="p">()</span> <span class="o">:</span> <span class="n">operation</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span> <span class="n">task_operation_</span><span class="p">;</span>
</pre></div>


<p>如果我们得到的<code>operation</code>就是这个特殊的<code>task_operation_</code>的话，再根据队列是否还有剩下的任务以及是否是单线程执行的做下一步操作。如果有剩下的任务且是多线程环境，则使用<code>wake_one_thread_and|unlock</code>尝试唤醒可能休眠的线程；否则直接释放锁。可以看出，这个<code>task_operation_</code>的用途肯定是说明当前线程不适合执行任务了。</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">task_io_service</span><span class="o">::</span><span class="n">wake_one_thread_and_unlock</span><span class="p">(</span>
    <span class="n">mutex</span><span class="o">::</span><span class="n">scoped_lock</span><span class="o">&amp;</span> <span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wakeup_event_</span><span class="p">.</span><span class="n">maybe_unlock_and_signal_one</span><span class="p">(</span><span class="n">lock</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task_interrupted_</span> <span class="o">&amp;&amp;</span> <span class="n">task_</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">task_interrupted_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="n">task_</span><span class="o">-&gt;</span><span class="n">interrupt</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>这个<code>wakeup_event</code>是<code>event</code>类型的，这又是一个各种实现的别名：</p>
<div class="highlight"><pre><span></span><span class="cp">#if !defined(BOOST_ASIO_HAS_THREADS)</span>
<span class="k">typedef</span> <span class="n">null_event</span> <span class="n">event</span><span class="p">;</span>
<span class="cp">#elif defined(BOOST_ASIO_WINDOWS)</span>
<span class="k">typedef</span> <span class="n">win_event</span> <span class="n">event</span><span class="p">;</span>
<span class="cp">#elif defined(BOOST_ASIO_HAS_PTHREADS)</span>
<span class="k">typedef</span> <span class="n">posix_event</span> <span class="n">event</span><span class="p">;</span>
<span class="cp">#elif defined(BOOST_ASIO_HAS_STD_MUTEX_AND_CONDVAR)</span>
<span class="k">typedef</span> <span class="n">std_event</span> <span class="n">event</span><span class="p">;</span>
<span class="cp">#endif</span>
</pre></div>


<p>这里我就尝试去查看<code>std</code>的实现。实现上来说还是非常简单的，用条件变量来等待和通知，我就不贴代码了。</p>
<p>整个流程就是：若有空闲线程，则唤醒空闲线程；若没有空闲线程，但是有线程在执行<code>task-&gt;run</code>，即阻塞在<code>epoll_wait</code>上，那么先中断<code>epoll_wait</code>执行任务队列完成后再执行<code>epoll_wait</code>。这个阻塞标记位就是<code>task_interrupted_</code>。</p>
<div class="highlight"><pre><span></span><span class="c1">// The task to be run by this service.</span>
<span class="n">reactor</span><span class="o">*</span> <span class="n">task_</span><span class="p">;</span>
</pre></div>


<p>然后就是让<code>reactor</code>执行当前线程的私有任务队列，最后返回的时候利用<code>task_cleanup</code>这个<code>RAII</code>类型去做一些清理工作：</p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">task_io_service</span><span class="o">::</span><span class="n">task_cleanup</span>
<span class="p">{</span>
  <span class="o">~</span><span class="n">task_cleanup</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">this_thread_</span><span class="o">-&gt;</span><span class="n">private_outstanding_work</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">boost</span><span class="o">::</span><span class="n">asio</span><span class="o">::</span><span class="n">detail</span><span class="o">::</span><span class="n">increment</span><span class="p">(</span>
          <span class="n">task_io_service_</span><span class="o">-&gt;</span><span class="n">outstanding_work_</span><span class="p">,</span>
          <span class="n">this_thread_</span><span class="o">-&gt;</span><span class="n">private_outstanding_work</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">this_thread_</span><span class="o">-&gt;</span><span class="n">private_outstanding_work</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// Enqueue the completed operations and reinsert the task at the end of</span>
    <span class="c1">// the operation queue.</span>
    <span class="n">lock_</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">();</span>
    <span class="n">task_io_service_</span><span class="o">-&gt;</span><span class="n">task_interrupted_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">task_io_service_</span><span class="o">-&gt;</span><span class="n">op_queue_</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">this_thread_</span><span class="o">-&gt;</span><span class="n">private_op_queue</span><span class="p">);</span>
    <span class="n">task_io_service_</span><span class="o">-&gt;</span><span class="n">op_queue_</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_io_service_</span><span class="o">-&gt;</span><span class="n">task_operation_</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">task_io_service</span><span class="o">*</span> <span class="n">task_io_service_</span><span class="p">;</span>
  <span class="n">mutex</span><span class="o">::</span><span class="n">scoped_lock</span><span class="o">*</span> <span class="n">lock_</span><span class="p">;</span>
  <span class="n">thread_info</span><span class="o">*</span> <span class="n">this_thread_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>这里的操作就是将本线程的私有队列放入全局队列中，然后用<code>task_operation_</code>来标记一个线程私有队列的结束。</p>
<p>以上这些操作中唯一可疑的就是<code>reactor.run</code>函数了，我们继续顺藤摸瓜。在<code>Asio</code>中，<code>reactor</code>有多种实现模式，是一个代理类：</p>
<div class="highlight"><pre><span></span><span class="cp">#if defined(BOOST_ASIO_WINDOWS_RUNTIME)</span>
<span class="k">typedef</span> <span class="k">class</span> <span class="nc">null_reactor</span> <span class="n">reactor</span><span class="p">;</span>
<span class="cp">#elif defined(BOOST_ASIO_HAS_IOCP)</span>
<span class="k">typedef</span> <span class="k">class</span> <span class="nc">select_reactor</span> <span class="n">reactor</span><span class="p">;</span>
<span class="cp">#elif defined(BOOST_ASIO_HAS_EPOLL)</span>
<span class="k">typedef</span> <span class="k">class</span> <span class="nc">epoll_reactor</span> <span class="n">reactor</span><span class="p">;</span>
<span class="cp">#elif defined(BOOST_ASIO_HAS_KQUEUE)</span>
<span class="k">typedef</span> <span class="k">class</span> <span class="nc">kqueue_reactor</span> <span class="n">reactor</span><span class="p">;</span>
<span class="cp">#elif defined(BOOST_ASIO_HAS_DEV_POLL)</span>
<span class="k">typedef</span> <span class="k">class</span> <span class="nc">dev_poll_reactor</span> <span class="n">reactor</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">typedef</span> <span class="k">class</span> <span class="nc">select_reactor</span> <span class="n">reactor</span><span class="p">;</span>
<span class="cp">#endif</span>
</pre></div>


<p>我们这里就查看一下<code>epoll.run</code>的实现吧，这个函数也比较长，我们分部分的来解析。首先是其签名：</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">epoll_reactor</span><span class="o">::</span><span class="n">run</span><span class="p">(</span><span class="kt">bool</span> <span class="n">block</span><span class="p">,</span> <span class="n">op_queue</span><span class="o">&lt;</span><span class="n">operation</span><span class="o">&gt;&amp;</span> <span class="n">ops</span><span class="p">)</span>
  <span class="c1">// This code relies on the fact that the task_io_service queues the reactor</span>
  <span class="c1">// task behind all descriptor operations generated by this function. This</span>
  <span class="c1">// means, that by the time we reach this point, any previously returned</span>
  <span class="c1">// descriptor operations have already been dequeued. Therefore it is now safe</span>
  <span class="c1">// for us to reuse and return them for the task_io_service to queue again.</span>
</pre></div>


<p>这里首先对时钟的<code>time_out</code>做处理，设置好正确的<code>time_out</code>参数。如果有<code>timer_fd</code>在等待队列内且调用设置为非阻塞，则我们设置为立即返回；否则设置为阻塞。没有使用<code>timer_fd</code>的话则获取之前设置的<code>time_out</code>参数。</p>
<div class="highlight"><pre><span></span><span class="c1">// Calculate a timeout only if timerfd is not used.</span>
<span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">timer_fd_</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">timeout</span> <span class="o">=</span> <span class="n">block</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">else</span>
<span class="p">{</span>
<span class="n">mutex</span><span class="o">::</span><span class="n">scoped_lock</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
<span class="n">timeout</span> <span class="o">=</span> <span class="n">block</span> <span class="o">?</span> <span class="n">get_timeout</span><span class="p">()</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>然后我们开始设置好<code>epoll_wait</code>的参数，开始等待。</p>
<div class="highlight"><pre><span></span><span class="c1">// Block on the epoll descriptor.</span>
<span class="n">epoll_event</span> <span class="n">events</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">num_events</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">epoll_fd_</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
</pre></div>


<p>等待完成之后，我们开始分发事件:</p>
<div class="highlight"><pre><span></span><span class="cp">#if defined(BOOST_ASIO_HAS_TIMERFD)</span>
  <span class="kt">bool</span> <span class="n">check_timers</span> <span class="o">=</span> <span class="p">(</span><span class="n">timer_fd_</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="cp">#else </span><span class="c1">// defined(BOOST_ASIO_HAS_TIMERFD)</span>
  <span class="kt">bool</span> <span class="n">check_timers</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// defined(BOOST_ASIO_HAS_TIMERFD)</span>

  <span class="c1">// Dispatch the waiting events.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_events</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">interrupter_</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// No need to reset the interrupter since we&#39;re leaving the descriptor</span>
      <span class="c1">// in a ready-to-read state and relying on edge-triggered notifications</span>
      <span class="c1">// to make it so that we only get woken up when the descriptor&#39;s epoll</span>
      <span class="c1">// registration is updated.</span>

<span class="cp">#if defined(BOOST_ASIO_HAS_TIMERFD)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">timer_fd_</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">check_timers</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="cp">#else </span><span class="c1">// defined(BOOST_ASIO_HAS_TIMERFD)</span>
      <span class="n">check_timers</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// defined(BOOST_ASIO_HAS_TIMERFD)</span>
    <span class="p">}</span>
<span class="cp">#if defined(BOOST_ASIO_HAS_TIMERFD)</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">timer_fd_</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">check_timers</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// defined(BOOST_ASIO_HAS_TIMERFD)</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="c1">// The descriptor operation doesn&#39;t count as work in and of itself, so we</span>
      <span class="c1">// don&#39;t call work_started() here. This still allows the io_service to</span>
      <span class="c1">// stop if the only remaining operations are descriptor operations.</span>
      <span class="n">descriptor_state</span><span class="o">*</span> <span class="n">descriptor_data</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">descriptor_state</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
      <span class="n">descriptor_data</span><span class="o">-&gt;</span><span class="n">set_ready_events</span><span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span><span class="p">);</span>
      <span class="n">ops</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">descriptor_data</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></div>


<p>这里处理了三种<code>event</code>：<code>interrupt</code>,<code>timer</code>和普通的<code>IO</code>事件。这里需要特别说明的就是<code>interrupt</code>，这个是一个特别的文件描述符。如果我们想要人工的终止<code>epoll_wait</code>，可以通过<code>select_interrupter</code>函数来将这个描述符加入到监听列表之中去。<code>select_interrupter</code>实际上实现是<code>eventfd_select_interrupter</code>，在构造的时候通过<code>pipe</code>系统调用创建两个文件描述符，然后预先通过<code>write_fd</code>写8个字节，这8个字节一直保留。在添加到<code>epoll_wait</code>中采用<code>EPOLLET</code>水平触发，这样只要<code>select_interrupter</code>的读文件描述符添加到<code>epoll_wait</code>中，立即中断<code>epoll_wait</code>。</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">epoll_reactor</span><span class="o">::</span><span class="n">interrupt</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">epoll_event</span> <span class="n">ev</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span> <span class="p">};</span>
  <span class="n">ev</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLIN</span> <span class="o">|</span> <span class="n">EPOLLERR</span> <span class="o">|</span> <span class="n">EPOLLET</span><span class="p">;</span>
  <span class="n">ev</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">interrupter_</span><span class="p">;</span>
  <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epoll_fd_</span><span class="p">,</span> <span class="n">EPOLL_CTL_MOD</span><span class="p">,</span> <span class="n">interrupter_</span><span class="p">.</span><span class="n">read_descriptor</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">ev</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>这里会调用<code>set_ready_event</code>来做一些工作，只是简单将当前事件放入可执行队列里而已。最后的结果是可执行的操作都放入了<code>this_thread</code>的<code>private_op_queue</code>之中去了，等待线程去处理。</p>
<p>如果不是<code>task_operation</code>，即普通的完成事件，初始处理也是类似。</p>
<div class="highlight"><pre><span></span>  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">task_result</span> <span class="o">=</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">task_result_</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">more_handlers</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">one_thread_</span><span class="p">)</span>
      <span class="n">wake_one_thread_and_unlock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
    <span class="k">else</span>
      <span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>

    <span class="c1">// Ensure the count of outstanding work is decremented on block exit.</span>
    <span class="n">work_cleanup</span> <span class="n">on_exit</span> <span class="o">=</span> <span class="p">{</span> <span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">this_thread</span> <span class="p">};</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">on_exit</span><span class="p">;</span>

    <span class="c1">// Complete the operation. May throw an exception. Deletes the object.</span>
    <span class="n">o</span><span class="o">-&gt;</span><span class="n">complete</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">ec</span><span class="p">,</span> <span class="n">task_result</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>


<p>最后就是调用回调函数<code>operation.complete</code>，具体内容在前面的代码里也说明了：先执行<code>IO</code>，然后执行回调。至此整个线程调度可以说是完美结束。</p>
<p>而<code>stop</code>操作就比较简单了，直接调用<code>stop_all_threads</code>：</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">task_io_service</span><span class="o">::</span><span class="n">stop_all_threads</span><span class="p">(</span>
    <span class="n">mutex</span><span class="o">::</span><span class="n">scoped_lock</span><span class="o">&amp;</span> <span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">stopped_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">wakeup_event_</span><span class="p">.</span><span class="n">signal_all</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task_interrupted_</span> <span class="o">&amp;&amp;</span> <span class="n">task_</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">task_interrupted_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">task_</span><span class="o">-&gt;</span><span class="n">interrupt</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>直接设置<code>stopped</code>为<code>true</code>，然后唤醒所有休眠线程，这是通过<code>single</code>和<code>interrupt</code>一起实现的。</p>                </article>
            </aside><!-- /#featured -->
                <section id="content" class="body">
                    <h1>Other articles</h1>
                    <hr />
                    <ol id="posts-list" class="hfeed">

            <li><article class="hentry">
                <header>
                    <h1><a href="/clang-lexer.html" rel="bookmark"
                           title="Permalink to Clang Lexer">Clang Lexer</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2015-11-27T23:35:00+08:00">
                Published: 周五 27 十一月 2015
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/spiritsaway.html">SpiritsAway</a>
        </address>
<p>In <a href="/category/compiler.html">Compiler</a>.</p>
<p>tags: <a href="/tag/compiler.html">Compiler</a> <a href="/tag/clang.html">Clang</a> <a href="/tag/cpp.html">Cpp</a> </p>
</footer><!-- /.post-info -->                <h1>Lexer</h1>
<p>在cpp语言标准中，词法分析分为了多道。</p>
<ol>
<li>
<p>phase 1.操作系统将源文件里的每个字节从源文件编码转换为标准编码。主要包括平台相关的换行符替换、宽字节（UCN）映射和trigraph映射。</p>
</li>
<li>
<p>phase 2.每个以$\backslash$为结束的行，都会与之后的那一行进行拼接。但是这里每一行只处理一次这个情况，末尾是$\backslash$$\backslash$且下一行是空行的情况下不会自动拼接到第二行。同时对于行拼接可能引发的UCN编码结果都是未定义行为。如果源文件最后一行是以$\backslash$结尾的，则这个也是一个未定义行为。</p>
</li>
<li>
<p>phase 3.源文件内容被分为了：注释、空白和预处理词法单元。这些预处理此法单元包括：</p>
<ol>
<li>
<p>在 #include 后面的头文件名字</p>
</li>
<li>
<p>标识符</p>
</li>
<li>
<p>预处理数字</p>
</li>
<li>
<p>字符常量和字符串常量，包括用户自定义类型</p>
</li>
<li>
<p>操作符和标点符号， 这里又引入了<a href="http://en.cppreference.com/w/cpp/language/operator_alternative">alternative tokens</a>这种形式，</p>
</li>
<li>
<p>不属于上述归类的的字符串</p>
</li>
</ol>
<p>注意这里从cpp11开始规定了<a href="http://en.cppreference.com/w/cpp/language/string_literal">raw string literal</a>，对于phase …</p></li></ol>
                <a class="readmore" href="/clang-lexer.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="/clang-basic.html" rel="bookmark"
                           title="Permalink to Clang Basic">Clang Basic</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2015-11-17T19:27:00+08:00">
                Published: 周二 17 十一月 2015
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/spiritsaway.html">SpiritsAway</a>
        </address>
<p>In <a href="/category/compiler.html">Compiler</a>.</p>
<p>tags: <a href="/tag/compiler.html">Compiler</a> <a href="/tag/clang.html">Clang</a> <a href="/tag/cpp.html">CPP</a> </p>
</footer><!-- /.post-info -->                <h1>基本类型</h1>
<h2>FileManager</h2>
<h3>FileID</h3>
<p>这个<code>FileID</code>只包含一个数据成员<code>int ID</code>，作为其代表文件的索引。通过这个索引，<code>SourceManager</code>可以得到其<code>MemoryBuffer</code>和引入该文件的位置。</p>
<p>这里还提到了加载域，如果当前文件是从当前模块中加载的，则这个<code>ID</code>是正的，否则是负的。实现时是通过一个全局的<code>ID=index++</code>来分配，如果是从其他模块中加载进来的，则设置为<code>ID=-ID-2</code>。如果<code>ID=-1</code>，则认为是非法<code>FileID</code>.</p>
<h3>FileInfo</h3>
<p><code>FileInfo</code>代表的是一个文件相关的引入文件信息和自身的被引入信息。</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">FileInfo</span>
<span class="p">{</span>
    <span class="c1">/// \brief The location of the #include that brought in this file.</span>
    <span class="c1">///</span>
    <span class="c1">/// This …</span></pre></div>
                <a class="readmore" href="/clang-basic.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="/enhanced-future.html" rel="bookmark"
                           title="Permalink to Enhanced Future">Enhanced Future</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2015-11-05T21:31:00+08:00">
                Published: 周四 05 十一月 2015
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/spiritsaway.html">SpiritsAway</a>
        </address>
<p>In <a href="/category/cpp.html">CPP</a>.</p>
<p>tags: <a href="/tag/cpp.html">CPP</a> <a href="/tag/concurrent.html">Concurrent</a> </p>
</footer><!-- /.post-info -->                <h1>future介绍</h1>
<p>在多线程环境下，我们经常需要同时启动多个任务。有些任务是比较耗时，而且我们并不急于获得其结果。对于这些任务，我们可以使用<code>std::future</code>和<code>std::async</code>来封装其异步执行流程。通过<code>std::async</code>来注册异步任务，然后返回一个该异步结果的句柄<code>std::future</code>。</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">future</span> <span class="o">&lt;</span> <span class="kt">double</span> <span class="o">&gt;</span> <span class="n">result_future</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">power</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
</pre></div>


<p>当我们需要得到这个异步过程的结果时，我们可以显示的请求。</p>
<div class="highlight"><pre><span></span><span class="kt">double</span> <span class="n">result</span><span class="o">=</span><span class="n">result_future</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</pre></div>


<p>如果该异步过程已经执行完，则可以直接获得结果；如果还未执行，则当前线程被阻塞，直到执行完成。</p>
<p>在后文中，我们将分为两个部分：</p>
<ul>
<li>
<p>异步过程的执行，即处理<code>std::async</code>封装后的任务调度；</p>
</li>
<li>
<p>异步过程的生成，即处理 …</p></li></ul>
                <a class="readmore" href="/enhanced-future.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="/type-deduction-of-cpp.html" rel="bookmark"
                           title="Permalink to Type Deduction of CPP">Type Deduction of CPP</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2015-10-11T20:13:00+08:00">
                Published: 周日 11 十月 2015
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/spiritsaway.html">SpiritsAway</a>
        </address>
<p>In <a href="/category/cpp.html">CPP</a>.</p>
<p>tags: <a href="/tag/type.html">Type</a> <a href="/tag/cpp.html">CPP</a> </p>
</footer><!-- /.post-info -->                <p>类型系统在语言设计中是一个非常重要的方面，在影响语言的好坏程度的时候，类型系统与相关的库同是起决定性的两个因素。
C++的类型系统为静态弱类型。虽说静态类型的优点是变量的类型明确，但是碰到这种声明<code>char (*(*X())[])()</code>，在没有cdecl类似工具的辅助下一般人也很难看出变量的意义是什么。上面的例子属于C语言的范畴，C++在其基础上增加了更加复杂的模板类型推导和自动类型推导。在这些因素的影响下，如何读懂C++的类型便成为了一个很大的问题。本文便以弄懂C++的类型为出发点，剖析<code>template&lt;T&gt; ,auto ,decltype</code>这三种语法下的类型推导。相关内容都是自己从internet及相关书籍总结而来，如有错误欢迎指出。</p>
<h1>理解template类型推导</h1>
<p>模板(template)被引入C++主要是用来处理泛型容器和通用算法问题。在被证明了是图灵完全之后，模板的使用场景便百花齐放，无所不用其极。看过boost库中spirit等类似库之后，很多人自此都换上了尖括号恐惧症。如果你经历过编译器报模板相关错误，那么你应该能理解我所说的。本文并不想去谈论模板元编程（我也没有资格去谈，水平不够），只讨论一下模板类型推导的问题。由于函数模板类型推导与类模板类型推导原理一样，下文只讨论函数模板推导。简单来说，函数模板声明有如下形式：</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void …</span></pre></div>
                <a class="readmore" href="/type-deduction-of-cpp.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="/2d-topk-search.html" rel="bookmark"
                           title="Permalink to 2D Topk Search">2D Topk Search</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2015-09-13T22:00:00+08:00">
                Published: 周日 13 九月 2015
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/spiritsaway.html">SpiritsAway</a>
        </address>
<p>In <a href="/category/algorithm.html">Algorithm</a>.</p>
<p>tags: <a href="/tag/algorithm.html">Algorithm</a> </p>
</footer><!-- /.post-info -->                <h1>二维区间topk问题</h1>
<p>二维区间topk问题原始来源是<a href="https://churchillnavigation.com/challenge/">https://churchillnavigation.com/challenge/</a>。去年年前我在reddit上看到这个比赛之后，跃跃欲试，期间可以说是茶饭不思啊！但是，我要说但是，最后成绩排名只是33。平均用时比第一名慢33倍，这简直是智商上的压制。期间也暴露了我写代码上的一些问题，努力改正！不过学到更多的是程序优化是算法优化和体系结构的综合，而不仅仅是理论上的渐进复杂度而已。如果不用SSE/AVX指令集，任何解决方案都打不进前10。主办方用的算法基本是理论上最优的，然而只排到了第18名，运行时间差不多是我的一半。通过研究这些代码，也发现了一些好玩的东西，因此写这篇文章来记录一下。半年之后才开始动笔，真是懒惰！</p>
<h1>naive topk问题</h1>
<p>所谓的naive topk问题可以表述为：</p>
<blockquote>
<p>从n个数中找出其最大的k个数</p>
</blockquote>
<p>言简意赅。解决方案也是非常直接，基本可用的方法用3种：</p>
<ul>
<li>
<p>堆排序：用一个大小为k的最小堆，所需时间为$\mathcal{O}(nlogk)$，空间为$k$,其实额外空间都不需要，直接原地排就可以。</p>
</li>
<li>
<p>部分快排:只对索引小于k的部分进行排序，期望运行时间为 …</p></li></ul>
                <a class="readmore" href="/2d-topk-search.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="/under-the-hood-pogs.html" rel="bookmark"
                           title="Permalink to Under the Hood : POGS">Under the Hood : POGS</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2015-05-15T21:31:00+08:00">
                Published: 周五 15 五月 2015
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/spiritsaway.html">SpiritsAway</a>
        </address>
<p>In <a href="/category/code.html">Code</a>.</p>
<p>tags: <a href="/tag/code.html">Code</a> <a href="/tag/admm.html">ADMM</a> </p>
</footer><!-- /.post-info -->                <h1>POGS Introduction</h1>
<p>Proximal Graph Solver (POGS) is a solver for convex optimization problems in graph form using Alternating Direction Method of Multipliers (ADMM).  The graph form problem can be expressed as</p>
<p>\begin{equation}\begin{aligned}&amp; minimize \quad &amp; f(y)+g(x)\&amp; subject to \quad &amp; y=Ax\\end{aligned}\end{equation …</p>
                <a class="readmore" href="/under-the-hood-pogs.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="/admm.html" rel="bookmark"
                           title="Permalink to ADMM">ADMM</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2015-05-07T13:31:00+08:00">
                Published: 周四 07 五月 2015
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/spiritsaway.html">SpiritsAway</a>
        </address>
<p>In <a href="/category/ai.html">AI</a>.</p>
<p>tags: <a href="/tag/admm.html">ADMM</a> <a href="/tag/math.html">Math</a> <a href="/tag/ai.html">AI</a> <a href="/tag/converge.html">Converge</a> </p>
</footer><!-- /.post-info -->                <h1>扩展的拉格朗日乘子方法</h1>
<p><code>Augmented Lagrangrians and the Method of Multipliers</code>是凸优化问题的一种通用解法. 在凸优化中，我们一般会遇到如此形式的优化问题</p>
<p>\begin{equation}\label{eq:oringinal}minimize \quad f(x) \quad w.r.t. \quad Ax=b\end{equation}
上式经过拉格朗日乘子变换之后，变为了</p>
<p>\begin{equation}\label{eq:normalLag}minimize \quad f(x)+y^{T} (Ax-b) \quad w.r.t. \quad y\ge …</p>
                <a class="readmore" href="/admm.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="/concurrency-in-cpp.html" rel="bookmark"
                           title="Permalink to Concurrency in CPP">Concurrency in CPP</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2015-04-28T20:23:00+08:00">
                Published: 周二 28 四月 2015
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/spiritsaway.html">SpiritsAway</a>
        </address>
<p>In <a href="/category/cpp.html">CPP</a>.</p>
<p>tags: <a href="/tag/concurrency.html">Concurrency</a> <a href="/tag/cpp.html">CPP</a> </p>
</footer><!-- /.post-info -->                <p>并行是一个非常fancy的词，在正确的实现并行的时候能够得到非常大的效率提高。但是，如何正确的实现并行一直陷阱重重。这之间的陷阱主要有如下三个：</p>
<ul>
<li>
<p>并行读写竞争处理</p>
</li>
<li>
<p>并行操作的异常处理</p>
</li>
<li>
<p>缓存敏感的数据布局及访问设计</p>
</li>
</ul>
<p>其中第三个问题被誉为CS里面中最难的两个问题之首。常言道：<code>There are only two hard things in Computer Science: cache invalidation and naming things.</code> 后面这个问题能够使整个论坛吵起来乃至血流成河，而前面这个问题只会造成男默女泪的局面。所以，当前就围绕着前两个问题进行讨论。首先解决访问读写竞争问题，然后讨论异常处理问题。</p>
<h1>读写竞争：双线程</h1>
<p>在并行程序中，最基本的进行访问仲裁的方法是使用<code>mutex</code>。但是在双线程的情况下，采用peterson算法比使用<code>mutex</code>代价小很多。下文就来介绍一个peterson方法。</p>
<p>只有两个程序在访问同一个数据，所以数组大小为2。在下文中，flag[2]代表意向数组，分别为P1和P0，当为1时代表他们想去临界区或者已经在临界区中了,另外有一个turn来代表下一个该进入的程序号，turn可取的值为0或1 …</p>
                <a class="readmore" href="/concurrency-in-cpp.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>

            <li><article class="hentry">
                <header>
                    <h1><a href="/lazy-evaluation-in-cpp.html" rel="bookmark"
                           title="Permalink to Lazy Evaluation in CPP">Lazy Evaluation in CPP</a></h1>
                </header>

                <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2015-04-28T20:22:00+08:00">
                Published: 周二 28 四月 2015
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/spiritsaway.html">SpiritsAway</a>
        </address>
<p>In <a href="/category/cpp.html">CPP</a>.</p>
<p>tags: <a href="/tag/cpp.html">CPP</a> <a href="/tag/lazy-evaluation.html">Lazy Evaluation</a> </p>
</footer><!-- /.post-info -->                <p>惰性求值的概念来自于<code>lambda calculus</code>，并在一些函数式编程语言中得到了实现，如<code>Miranda,Haskell</code>中惰性求值是默认的。惰性求值的主要思想就是尽可能的避免不必要的计算，如果这些计算的结果并没有被使用的话。惰性求值除可以得到性能的提升外，惰性计算的最重要的好处是它可以构造一个无限的数据类型（例如处理无穷列表，流式计算等）。而C++脱胎于面向过程和面向对象两种编程范式，本来与惰性求值是格格不入的。不过，短路操作符倒是挺符合惰性求值的特点的。例如<code>a||b</code>，如果<code>a</code>被求值为真的时候，<code>b</code>的值则不需要再去求了，直接返回<code>true</code>。但是如果我们在类的内部将短路操作符重载的话，则求值的短路性质将不再被满足。因为重载之后，原来的操作符退化成为了函数，操作数退化成为了参数。在函数应用时，参数必须已经求值。所以，任何企图重载短路操作符的举动都是在自寻死路。</p>
<p>难道除了短路操作符我们就无法惰性求值了么？</p>
<h1>惰性求值简单实现</h1>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">Point</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>为了简化讨论，只实现加法版本的惰性求值。此时，我们引入一个辅助类 …</p>
                <a class="readmore" href="/lazy-evaluation-in-cpp.html">read more</a>
                </div><!-- /.entry-content -->
            </article></li>
                </ol><!-- /#posts-list -->
<p class="paginator">
    Page 1 / 3
        <a href="/author/spiritsaway2.html">&raquo;</a>
</p>
                </section><!-- /#content -->
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="http://getpelican.com/">Pelican</a></li>
                            <li><a href="http://python.org/">Python.org</a></li>
                            <li><a href="http://jinja.pocoo.org/">Jinja2</a></li>
                            <li><a href="#">You can modify those links in your config file</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="#">You can add links in your config file</a></li>
                            <li><a href="#">Another social link</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>
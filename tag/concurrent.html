<!DOCTYPE html>
<html lang="chinese (simplified)">
<head>
        <meta charset="utf-8" />
        <title>SpiritsAway - Concurrent</title>
        <link rel="stylesheet" href="/theme/css/main.css" />

        <!--[if IE]>
            <script src="https://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">SpiritsAway </a></h1>
                <nav><ul>
                    <li><a href="/pages/about.html">about</a></li>
                    <li><a href="/category/ai.html">AI</a></li>
                    <li><a href="/category/algorithm.html">Algorithm</a></li>
                    <li><a href="/category/code.html">Code</a></li>
                    <li><a href="/category/compiler.html">Compiler</a></li>
                    <li><a href="/category/cpp.html">CPP</a></li>
                    <li><a href="/category/math.html">Math</a></li>
                </ul></nav>
        </header><!-- /#banner -->

            <aside id="featured" class="body">
                <article>
                    <h1 class="entry-title"><a href="/enhanced-future.html">Enhanced Future</a></h1>
<footer class="post-info">
        <abbr class="published" title="2015-11-05T21:31:00+08:00">
                Published: 周四 05 十一月 2015
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/spiritsaway.html">SpiritsAway</a>
        </address>
<p>In <a href="/category/cpp.html">CPP</a>.</p>
<p>tags: <a href="/tag/cpp.html">CPP</a> <a href="/tag/concurrent.html">Concurrent</a> </p>
</footer><!-- /.post-info --><h1>future介绍</h1>
<p>在多线程环境下，我们经常需要同时启动多个任务。有些任务是比较耗时，而且我们并不急于获得其结果。对于这些任务，我们可以使用<code>std::future</code>和<code>std::async</code>来封装其异步执行流程。通过<code>std::async</code>来注册异步任务，然后返回一个该异步结果的句柄<code>std::future</code>。</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">future</span> <span class="o">&lt;</span> <span class="kt">double</span> <span class="o">&gt;</span> <span class="n">result_future</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">power</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
</pre></div>


<p>当我们需要得到这个异步过程的结果时，我们可以显示的请求。</p>
<div class="highlight"><pre><span></span><span class="kt">double</span> <span class="n">result</span><span class="o">=</span><span class="n">result_future</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</pre></div>


<p>如果该异步过程已经执行完，则可以直接获得结果；如果还未执行，则当前线程被阻塞，直到执行完成。</p>
<p>在后文中，我们将分为两个部分：</p>
<ul>
<li>
<p>异步过程的执行，即处理<code>std::async</code>封装后的任务调度；</p>
</li>
<li>
<p>异步过程的生成，即处理<code>future=async()</code>中异步过程的注册和结果句柄的生成；</p>
</li>
<li>
<p>异步过程的串联，即处理<code>future=future.then(async())</code>中异步过程的序列化。</p>
</li>
</ul>
<h1>异步过程的执行</h1>
<h2>基本执行结构</h2>
<p>首先我们考虑无返回值、无参数的异步过程的执行。在这种情况下，最直接的处理方案就是利用一个队列来存储提交的异步任务，同时建立一个线程池来消费这个任务队列。为此，我们需要实现两个部分：多线程的任务队列，以及任务的提交和请求。</p>
<p>对于多线程的任务队列，可以参考下面代码</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">notification_queue</span>
<span class="p">{</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;&gt;</span> <span class="n">_q</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">_done</span><span class="p">{</span> <span class="nb">false</span> <span class="p">};</span>
    <span class="n">mutex</span> <span class="n">_mutex</span><span class="p">;</span>
    <span class="n">condition_variable</span> <span class="n">_ready</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">done</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="p">{</span>
            <span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">{</span> <span class="n">_mutex</span> <span class="p">};</span>
            <span class="n">_done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">_ready</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">try_pop</span><span class="p">(</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">{</span> <span class="n">_mutex</span> <span class="p">};</span>
        <span class="n">_ready</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="o">!</span><span class="n">_q</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span><span class="o">||</span><span class="n">_done</span><span class="p">;</span>
        <span class="p">});</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_q</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span><span class="o">||</span><span class="n">done</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">move</span><span class="p">(</span><span class="n">_q</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
        <span class="n">_q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
    <span class="kt">bool</span> <span class="n">try_push</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">{</span>
            <span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">{</span> <span class="n">_mutex</span><span class="p">,</span><span class="n">try_to_lock</span> <span class="p">};</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lock</span><span class="o">||</span><span class="n">done</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">_q</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="n">_ready</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">};</span>
</pre></div>


<p>上述代码与一般的多线程队列的不同之处在于增加了<code>done</code>这个<code>bool</code>变量，用来停止任务的提交和请求。其实更好的多线程任务队列实现应该以<code>std::shared_ptr</code>作为返回值，以防止内存分配时异常所导致的数据不一致。当前文档只是为了做概念性说明作用，因此以最简实现作为展示。</p>
<p>在此多线程队列的支持下，初步的线程池系统可以有如下实现：</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">task_system</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">_count</span><span class="p">{</span> <span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">()</span> <span class="p">};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">_threads</span><span class="p">;</span>
    <span class="n">notification_queue</span> <span class="n">_q</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">_done</span><span class="p">{</span><span class="nb">false</span><span class="p">};</span>
    <span class="kt">void</span> <span class="nf">run</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_q</span><span class="p">.</span><span class="n">try_pop</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">this_thread</span><span class="p">.</span><span class="n">yield</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">f</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">task_system</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">_count</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_threads</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span> <span class="n">run</span><span class="p">();</span> <span class="p">});</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">task_system</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">_done</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
        <span class="n">_q</span><span class="p">.</span><span class="n">done</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">e</span> <span class="p">:</span> <span class="n">_threads</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">e</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
    <span class="kt">bool</span> <span class="n">async_</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">_q</span><span class="p">.</span><span class="n">try_push</span><span class="p">(</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">done</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">_done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>上述代码虽然实现了一个简单的线程池，但是在效率上是有问题的。主要的原因就是所有的工作线程都在争夺任务队列的控制权，产生了<code>contention</code>。为了缓解<code>contention</code>现象，可以从以下两个方面来入手：</p>
<ul>
<li>
<p>显式的以待头节点的链表来实现队列，从而使得任务的提交和请求所需要的锁分开；</p>
</li>
<li>
<p>为每一个线程分配一个专有的任务队列，同时允许线程向其他任务队列请求任务，即 <code>work_steal</code>。</p>
</li>
</ul>
<h2>良构锁队列</h2>
<p>所谓良构锁队列，就是尽可能的减少不必要的锁占用时间。因此，我们采取链表来作为良构锁队列的底层数据结构，其数据结构如下：</p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">notification_queue</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="k">struct</span> <span class="n">node</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">head_mutex</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">tail_mutex</span><span class="p">;</span>
    <span class="n">node</span><span class="o">*</span> <span class="n">tail</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里我们存储了链表的头节点和尾节点，同时为头节点和尾节点添加相应的锁。同时我们将链表初始化为有一个头节点的链表：</p>
<div class="highlight"><pre><span></span><span class="n">notification_queue</span><span class="p">()</span> <span class="o">:</span><span class="n">head</span><span class="p">(</span><span class="k">new</span> <span class="n">node</span><span class="p">),</span><span class="n">tail</span><span class="p">(</span><span class="n">head</span><span class="p">.</span><span class="n">get</span><span class="p">())</span>
<span class="p">{</span>

<span class="p">}</span>
</pre></div>


<p>此外，在此链表中加入一个头节点，以减少<code>pop</code>操作对于尾节点锁的争用。对于<code>push</code>操作来说，实现是很直白的，因为这个过程只涉及到了尾节点的锁。唯一需要注意的一点是在获得锁之前就通过<code>make_shared</code>分配好内存空间，以防止在锁的作用域内抛出异常，从而导致数据不一致。</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">T</span> <span class="n">new_value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">new_data</span><span class="p">(</span>
        <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">new_value</span><span class="p">)));</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="k">new</span> <span class="n">node</span><span class="p">);</span>
    <span class="n">node</span><span class="o">*</span> <span class="k">const</span> <span class="n">new_tail</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">tail_lock</span><span class="p">(</span><span class="n">tail_mutex</span><span class="p">);</span>
    <span class="n">tail</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">new_data</span><span class="p">;</span>
    <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="n">tail</span> <span class="o">=</span> <span class="n">new_tail</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>此时的<code>pop</code>操作则需要小心：</p>
<div class="highlight"><pre><span></span><span class="n">node</span><span class="o">*</span> <span class="nf">get_tail</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">tail_lock</span><span class="p">(</span><span class="n">tail_mutex</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">tail</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">bool</span> <span class="nf">try_pop</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">head_lock</span><span class="p">(</span><span class="n">head_mutex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">==</span> <span class="n">get_tail</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&gt;</span> <span class="n">old_head</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">old_head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
    <span class="n">result</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">old_head</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>在<code>try_pop</code>的过程中，我们首先判断当前链表是否为空，这里的<code>get_tail</code>必须放在<code>head_lock</code>之后。否则的话：我们获得<code>head</code>时，可能其他线程已经多次进行了<code>try_pop</code>和<code>push</code>。从而导致<code>head</code>获得时，队列可能已经为空，而之前获得的尾节点所指向的并非当前尾节点。在这种情况下<code>head</code>与 <code>tail</code>的比较失败，返回<code>head</code>，从而导致错误。</p>
<h2>work_steal线程池</h2>
<p><code>work_steal</code>的实现比较直白。首先我们修改其数据结构为:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">task_system</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">_count</span><span class="p">{</span> <span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">()</span> <span class="p">};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">_threads</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">notification_queue</span><span class="o">&gt;</span> <span class="n">_q</span><span class="p">{</span> <span class="n">_count</span> <span class="p">};</span>
    <span class="n">atomic</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> <span class="n">_index</span><span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="kt">bool</span> <span class="n">_done</span><span class="p">{</span> <span class="nb">false</span> <span class="p">};</span>
<span class="p">}</span>
</pre></div>


<p>对于每一个逻辑执行单元，我们都分配一个专有任务队列。提交新任务时，我们直接采取轮转法来平衡负载，用<code>index</code>自增来实现：</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">async_</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">_index</span><span class="o">++</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">_count</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_q</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">%</span> <span class="n">_count</span><span class="p">].</span><span class="n">try_push</span><span class="p">(</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">)))</span>
        <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">_q</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">_count</span><span class="p">].</span><span class="n">push</span><span class="p">(</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>


<p>而对于<code>run</code>函数，我们添加一个参数来指明该线程所对应的专有任务队列：</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">run</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">_count</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_q</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">%</span> <span class="n">_count</span><span class="p">].</span><span class="n">try_pop</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">_q</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">try_pop</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">f</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>同时，线程池的构造函数和析构函数也要做相应的修改,以实现RAII：</p>
<div class="highlight"><pre><span></span><span class="n">task_system</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">_count</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_threads</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">([</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="p">{</span> <span class="n">run</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="o">~</span><span class="n">task_system</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">e</span> <span class="p">:</span> <span class="n">_q</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">e</span><span class="p">.</span><span class="n">done</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">e</span> <span class="p">:</span> <span class="n">_threads</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">e</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>至此，一个带<code>work_steal</code>的线程池就完成了</p>
<h1>异步过程的生成</h1>
<h2>返回值保存</h2>
<p>现有的代码处理的只是<code>function&lt;void()&gt;</code>类型的任务。对于普通函数来说，函数签名则是<code>function&lt;R(Args...)&gt;</code>的。但是异步提交任务时其参数列表就已经确定，需要处理的只是返回值，即<code>function&lt;R()&gt;</code>。为此，我们可以定义一个<code>shared_base</code>，来存储返回值相关信息。</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">shared_base</span>
<span class="p">{</span>
    <span class="n">optional</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">_r</span><span class="p">;</span> 
    <span class="n">mutex</span> <span class="n">_mutex</span><span class="p">;</span>
    <span class="n">condition_variable</span> <span class="n">_ready</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>这里的<code>optional&lt;R&gt; _r</code>用来存储异步过程的执行结果。</p>
<p>下面就是这个类所附带的几个函数：虚析构函数、<code>set</code>、<code>get</code>。</p>
<div class="highlight"><pre><span></span><span class="k">virtual</span> <span class="o">~</span><span class="n">shared_base</span><span class="p">()</span> <span class="p">{}</span>
<span class="kt">void</span> <span class="n">set</span><span class="p">(</span><span class="n">R</span><span class="o">&amp;&amp;</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">{</span>
        <span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">{</span> <span class="n">_mutex</span> <span class="p">};</span>
        <span class="n">_r</span><span class="o">=</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">_ready</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">const</span> <span class="n">R</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">{</span> <span class="n">_mutex</span> <span class="p">};</span>
    <span class="n">_ready</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_r</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="k">return</span> <span class="n">_r</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p>这样，我们就可以在异步调用中调用<code>set</code>函数来填充返回值，同时在<code>future</code>中调用<code>get</code>来等待返回值。为了在等待线程和工作线程中同时操作这个<code>shared_base</code>对象，我们需要以 <code>shared_ptr</code>的形式来保存这个对象的指针。自此，<code>future</code>所需要的元素都已具备，定义<code>future</code>来保存异步过程的结果句柄，其简单实现如下所示：</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">future</span>
<span class="p">{</span>
    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">_p</span><span class="p">;</span>
    <span class="k">explicit</span> <span class="nf">future</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">)</span> <span class="o">:</span> <span class="n">_p</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
    <span class="p">{</span>

    <span class="p">}</span>
    <span class="n">future</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
    <span class="k">const</span> <span class="n">R</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> 
    <span class="p">{</span> 
        <span class="k">return</span> <span class="n">_p</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">();</span> 
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>这里的<code>R</code>就是<code>shared_base&lt;T&gt;</code>类型。</p>
<h2>异步过程封装</h2>
<p>由于线程池中只支持<code>function&lt;void()&gt;</code>类型的调用，为此我们需要在<code>shared_base</code>的基础上进一步做封装。</p>
<p>首先，我们将返回值封装起来：</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">shared</span><span class="o">&lt;</span><span class="n">R</span><span class="p">(</span><span class="n">Args</span><span class="p">...)</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">shared_base</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="n">function</span><span class="o">&lt;</span><span class="n">R</span><span class="p">(</span><span class="n">Args</span><span class="p">...)</span><span class="o">&gt;</span> <span class="n">_f</span><span class="p">;</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
    <span class="n">shared</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="o">:</span> <span class="n">_f</span><span class="p">(</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="p">{}</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">A</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">A</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="n">_f</span><span class="p">(</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...));</span>
        <span class="n">_f</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>当前的<code>shared</code>结构既保存了返回值相关信息，还保留了函数的相关信息，即当前类型是一个可调用对象。在这个对象之上,我们再定义一个<code>packaged_task</code>。</p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span><span class="n">Args</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">packaged_task</span><span class="o">&lt;</span><span class="n">R</span><span class="p">(</span><span class="n">Args</span><span class="p">...)</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">shared</span><span class="o">&lt;</span><span class="n">R</span><span class="p">(</span><span class="n">Args</span><span class="p">...)</span><span class="o">&gt;&gt;</span> <span class="n">_p</span><span class="p">;</span>
    <span class="k">explicit</span> <span class="nf">packaged_task</span><span class="p">(</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">shared</span><span class="o">&lt;</span><span class="n">R</span><span class="p">(</span><span class="n">Args</span><span class="p">...)</span><span class="o">&gt;&gt;</span> <span class="n">p</span><span class="p">)</span> <span class="o">:</span> <span class="n">_p</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{}</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">packaged_task</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">A</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">A</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">_p</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)(</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>这个<code>packaged_task</code>中存储了一个<code>weak_ptr&lt;shared&lt;R(Args...)&gt;&gt;</code>，用来保留所有的调用信息和返回值信息。至于这里为什么用<code>weak_ptr</code>，可能是为了处理某些特殊情况：例如异步结果直接被抛弃，此时则没有必要去执行该异步过程。即异步过程的所有者是其返回值的所有者，而不是过程本身。</p>
<p>至此，我们把异步结果的存储和异步过程的存储都解决了，剩下的问题就是：我们如何根据一个可调用对象生成<code>future</code>和<code>packaged_task</code>。为此，我们定义一个新的中间函数<code>package</code>来执行次任务：</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">S</span><span class="p">,</span> <span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">package</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">future</span><span class="o">&lt;</span><span class="n">result_of_t_</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;&gt;&gt;</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">shared</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
    <span class="k">return</span> <span class="nf">make_pair</span><span class="p">(</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">future</span><span class="o">&lt;</span><span class="n">result_of_t_</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="p">}</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span><span class="n">Args</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">async</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="n">result_of_t</span><span class="o">&lt;</span><span class="n">F</span><span class="p">(</span><span class="n">Args</span><span class="p">...)</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">packaged_type</span> <span class="o">=</span> <span class="n">packaged_task</span><span class="o">&lt;</span><span class="n">result_type</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">pack</span> <span class="o">=</span> <span class="n">package</span><span class="o">&lt;</span><span class="n">result_type</span><span class="p">()</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...));</span>
    <span class="n">_system</span><span class="p">.</span><span class="n">async_</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pack</span><span class="p">)));</span>
    <span class="k">return</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pack</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>这个<code>package</code>函数做了两件事：</p>
<ul>
<li>
<p>根据所提供的函数参数<code>f</code>来生成一个保存了返回值和参数<code>f</code>的<code>shared&lt;S&gt;</code>，用<code>shared_ptr p</code>来控制其所有权。这里利用了<code>result_of_t</code>这个<code>type_traits</code>，其作用是根据函数签名返回该函数的返回值类型。</p>
</li>
<li>
<p>根据上一步生成的<code>shared_ptr p</code>构造<code>packaged_task</code>和<code>future</code>对象。这里利用了两个自动类型转换：一个是由<code>shared_ptr&lt;shared&lt;result_type()&gt;&gt;</code>构造出一个<code>weak_ptr &lt;shared&lt;result_type()&gt;&gt;</code>，另外一个就是根据<code>shared_ptr&lt;shared&lt;result_type()&gt;&gt;</code> 构造出一个<code>shared_ptr&lt;shared_base&lt;result_type&gt;&gt;</code>。在自动类型转换之后，再调用这两个对象相应的构造函数。</p>
</li>
</ul>
<p>同时，在<code>async</code>中，主要包括四个过程。</p>
<ul>
<li>
<p>通过<code>bind</code>将函数<code>f</code>与其相应的参数<code>args</code>绑定起来，生成了一个<code>function&lt;result_type()</code>类型的可调用对象。</p>
</li>
<li>
<p>将上一步构造出的临时可调用对象作为<code>package</code>的参数，生成了包含<code>package_task&lt;result_type()&gt;</code> 和<code>future&lt;result_type&gt;</code>的<code>pair pack</code>。</p>
</li>
<li>
<p>这个<code>pair</code>中所包含的<code>package_task</code>在当作一个可调用对象时，其函数签名为<code>void()</code>，因此可以直接向<code>_system</code>提交异步任务，这里的<code>_system</code>的类型就是前一节中所提到的<code>work_steal</code> 线程池任务系统。</p>
</li>
<li>
<p>最后，将<code>pair</code>中的<code>future&lt;result_type&gt;</code>返回，作为结果句柄。</p>
</li>
</ul>
<p>自此，从可调用对象构造出了对应的异步执行对象<code>packaged_task</code>和<code>future</code>。这个<code>packaged_task</code>被提交到了系统的任务处理系统<code>_system</code>中，而<code>future</code>则返回到用户线程。</p>
<h1>异步过程的串联</h1>
<h2>单后继串联</h2>
<p>在处理多个异步任务的系统设计中，异步任务的串联（即任务之间的依赖)是很重要的一个特性。设想一下场景中，我们需要依次调用两个函数：</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">future</span> <span class="o">&lt;</span> <span class="kt">double</span> <span class="o">&gt;</span> <span class="n">result_future_1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">power</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
<span class="kt">double</span> <span class="n">result_1</span><span class="o">=</span><span class="n">result_future_1</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">future</span> <span class="o">&lt;</span> <span class="kt">double</span> <span class="o">&gt;</span> <span class="n">result_future_2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">power</span><span class="p">,</span><span class="n">result_1</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="kt">double</span> <span class="n">result_2</span><span class="o">=</span><span class="n">result_future_2</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</pre></div>


<p>在上述实例中，<code>result_2</code>依赖于<code>result_1</code>。因此执行时我们必须显式的调用<code>future.get()</code>来获得<code>result_1</code>，然后才能提交第二个异步任务。这种显示的同步在依赖路径变长时就会显得非常繁杂，而且引入了多次同步的需求。理想情况下，我们想要的只是最后的执行结果，只需要调用一次<code>future.get()</code>就可以。简化的代码可以变成这样：</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">future</span> <span class="o">&lt;</span> <span class="kt">double</span> <span class="o">&gt;</span> <span class="n">result_future_1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">power</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">future</span> <span class="o">&lt;</span> <span class="kt">double</span> <span class="o">&gt;</span> <span class="n">result_future_2</span> <span class="o">=</span> <span class="n">result_future_1</span><span class="p">.</span><span class="n">then</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">power</span><span class="p">,</span><span class="n">_1</span><span class="p">,</span> <span class="mi">10</span><span class="p">));</span>
<span class="kt">double</span> <span class="n">result_2</span><span class="o">=</span><span class="n">result_future_2</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</pre></div>


<p>同时也可以变成这样</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">future</span> <span class="o">&lt;</span> <span class="kt">double</span> <span class="o">&gt;</span> <span class="n">result_future_1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">power</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">).</span><span class="n">then</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">power</span><span class="p">,</span><span class="n">_1</span><span class="p">,</span> <span class="mi">10</span><span class="p">));</span>
<span class="kt">double</span> <span class="n">result_1</span><span class="o">=</span><span class="n">result_future_1</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</pre></div>


<p>但是<code>C++11</code>中的<code>std::future</code>并不支持串联，所以我们就不得不去造轮子。现在我们就来实现<code>future.then()</code>。</p>
<p>为了支持<code>then</code>操作，我们必须在<code>future</code>中保存后续的执行路径。我们来研究<code>future</code>中对<code>then</code>的处理：</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">then</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">pack</span> <span class="o">=</span> <span class="n">package</span><span class="o">&lt;</span><span class="n">result_of_t</span><span class="o">&lt;</span><span class="n">F</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">&gt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">([</span><span class="n">p</span> <span class="o">=</span> <span class="n">_p</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">)]()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">_r</span><span class="p">.</span><span class="n">back</span><span class="p">());</span>
    <span class="p">});</span>
    <span class="n">_p</span><span class="o">-&gt;</span><span class="n">then</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">pack</span><span class="p">.</span><span class="n">first</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">pack</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里的<code>then</code>操作每次生成一个新的<code>pair&lt;packaged_task,future&gt;</code>。其中的<code>packaged_task</code>部分捕获了调用者<code>future</code>的<code>shared_ptr&lt;shared_base&gt;</code>成员<code>_p</code>,同时这个<code>packaged_task</code>注册到了<code>_p._then</code>队列中。<code>pair</code>中的<code>future</code>则保留了新的返回值信息。现在剩下的任务就是实现<code>shared_base.then</code>了。</p>
<p>为此我们首先修改<code>share_base</code>，增加一个保存后续任务的<code>optional</code>，同样以<code>vector</code>的形式来实现。此时<code>shared_base&lt;R&gt;</code>的数据成员如下：</p>
<div class="highlight"><pre><span></span><span class="n">optional</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">_r</span><span class="p">;</span> <span class="c1">// optional</span>
<span class="n">mutex</span> <span class="n">_mutex</span><span class="p">;</span>
<span class="n">condition_variable</span> <span class="n">_ready</span><span class="p">;</span>
<span class="n">optional</span><span class="o">&lt;</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;&gt;</span> <span class="n">_then</span><span class="p">;</span>
</pre></div>


<p>这个<code>_then</code>成员就是用来保存后续的执行路径的。其实也不算路径，因为只保留路径中的直接子节点，可以当作路径中的<code>next</code>指针。</p>
<p>而<code>then</code>操作就比较直接了：</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">then</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">resolved</span><span class="p">{</span> <span class="nb">false</span> <span class="p">};</span>
    <span class="p">{</span>
        <span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">{</span> <span class="n">_mutex</span> <span class="p">};</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_r</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_then</span><span class="o">=</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">resolved</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">resolved</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_system</span><span class="p">.</span><span class="n">async_</span><span class="p">(</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>在执行<code>then</code>操作时，首先判断是否之前的异步任务已经执行完全。这个判断是通过<code>_r</code>来执行的，因为<code>optional</code>有一个到<code>bool</code>的自动类型转换。</p>
<p>如果之前的异步任务已执行，则提交当前任务到任务调度系统；否则将当前任务挂载在<code>next</code>下，即<code>_then</code>。</p>
<p>同时，<code>set</code>函数也要做一些修改：</p>
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="n">R</span><span class="o">&amp;&amp;</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">optional</span><span class="o">&lt;</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;&gt;</span> <span class="n">then</span><span class="p">;</span>
    <span class="p">{</span>
        <span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">{</span> <span class="n">_mutex</span> <span class="p">};</span>
        <span class="n">_r</span><span class="o">=</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">_then</span><span class="p">,</span> <span class="n">then</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">_ready</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">then</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_system</span><span class="p">.</span><span class="n">async_</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">then</span><span class="p">.</span><span class="n">value</span><span class="p">()));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>这段代码也是比较直接：在当前<code>shared_base</code>获得了初始值之后，再去执行下一个异步过程。至于这里为什么用<code>swap</code>操作，目前还不是很清楚，需要测试一下才能知道这里的<code>swap</code>到底发生了什么。</p>
<h2>多后继串联</h2>
<p>之前的代码处理的只是包含了一个后续任务依赖的情况，但是当我们谈到依赖的时候，我们所提到的都是依赖树，而不是依赖序列。这种依赖树的情况，一个<code>packaged_task</code>可能有多个任务都在等待其完成。</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">future</span> <span class="o">&lt;</span> <span class="kt">double</span> <span class="o">&gt;</span> <span class="n">result_future_1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">power</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
<span class="kt">double</span> <span class="n">result_1</span><span class="o">=</span><span class="n">result_future_1</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">future</span> <span class="o">&lt;</span> <span class="kt">double</span> <span class="o">&gt;</span> <span class="n">result_future_2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">power</span><span class="p">,</span><span class="n">result_1</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">future</span> <span class="o">&lt;</span> <span class="kt">double</span> <span class="o">&gt;</span> <span class="n">result_future_3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">power</span><span class="p">,</span><span class="n">result_1</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="kt">double</span> <span class="n">result_2</span><span class="o">=</span><span class="n">result_future_2</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="kt">double</span> <span class="n">result_3</span><span class="o">=</span><span class="n">result_future_3</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</pre></div>


<p>为了支持这种多后继的操作，我们需要对<code>shared_base</code>做修改。</p>
<p>首先，<code>_then</code>成员不再是一个<code>optional&lt;function&lt;void()&gt;&gt;</code>，而是一个<code>vector&lt;function&lt;void&gt;&gt;</code>，因为我们所存储的后续任务不再仅限于一个。</p>
<div class="highlight"><pre><span></span><span class="n">optional</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="n">_r</span><span class="p">;</span> <span class="c1">// optional</span>
<span class="n">mutex</span> <span class="n">_mutex</span><span class="p">;</span>
<span class="n">condition_variable</span> <span class="n">_ready</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;&gt;</span> <span class="n">_then</span><span class="p">;</span>
</pre></div>


<p>同时，我们也要修改对应的<code>then</code>和<code>set</code>的代码实现，从<code>optional</code>转换到<code>vector</code>上来。</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">then</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">resolved</span><span class="p">{</span> <span class="nb">false</span> <span class="p">};</span>
    <span class="p">{</span>
        <span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">{</span> <span class="n">_mutex</span> <span class="p">};</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_r</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_then</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">resolved</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">resolved</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_system</span><span class="p">.</span><span class="n">async_</span><span class="p">(</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="o">:::</span><span class="n">c</span><span class="o">++</span>
<span class="kt">void</span> <span class="n">set</span><span class="p">(</span><span class="n">R</span><span class="o">&amp;&amp;</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;&gt;</span> <span class="n">then</span><span class="p">;</span>
    <span class="p">{</span>
        <span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">{</span> <span class="n">_mutex</span> <span class="p">};</span>
        <span class="n">_r</span><span class="o">=</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">_then</span><span class="p">,</span> <span class="n">then</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">_ready</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
    <span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">f</span><span class="p">:</span><span class="n">then</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_system</span><span class="p">.</span><span class="n">async_</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>在经过这种修改之后，之前的示例代码可以这样写：</p>
<div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">future</span> <span class="o">&lt;</span> <span class="kt">double</span> <span class="o">&gt;</span> <span class="n">result_future_1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">power</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">future</span> <span class="o">&lt;</span> <span class="kt">double</span> <span class="o">&gt;</span> <span class="n">result_future_2</span> <span class="o">=</span> <span class="n">result_future_1</span><span class="p">.</span><span class="n">then</span><span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">power</span><span class="p">,</span><span class="n">_1</span><span class="p">,</span> <span class="mi">10</span><span class="p">));</span>
<span class="n">std</span><span class="o">::</span><span class="n">future</span> <span class="o">&lt;</span> <span class="kt">double</span> <span class="o">&gt;</span> <span class="n">result_future_3</span> <span class="o">=</span> <span class="n">result_future_1</span><span class="p">.</span><span class="n">then</span><span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">power</span><span class="p">,</span><span class="n">_1</span><span class="p">,</span> <span class="mi">10</span><span class="p">));</span>
<span class="kt">double</span> <span class="n">result_2</span><span class="o">=</span><span class="n">result_future_2</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="kt">double</span> <span class="n">result_3</span><span class="o">=</span><span class="n">result_future_3</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</pre></div>


<h1>多前驱串联</h1>
<h2>wait_all 串联</h2>
<p>对于<code>wait_for_all</code>形式，一个任务的启动需要多个任务都已完成。我们需要等待所有过程的执行完全，所以需要显示的等待。为了支持这种显示的同步操作，我们继续修改之前的<code>shared_base</code>和<code>future</code>，都加入显示的等待<code>wait</code>。</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">shared_base</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;::</span><span class="n">wait</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">{</span> <span class="n">_mutex</span> <span class="p">};</span>
    <span class="n">_ready</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="o">!</span><span class="n">_r</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
    <span class="p">});</span>
<span class="p">}</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">future</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;::</span><span class="n">wait</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">_p</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p>这样我们可以以一下形式来实现<code>wait_for_all</code>：</p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F1</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Fs</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">wait_for_all</span><span class="p">(</span><span class="n">F1</span><span class="o">&amp;</span> <span class="n">f1</span><span class="p">,</span> <span class="n">Fs</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">fs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">dummy</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">(</span><span class="n">f1</span><span class="p">.</span><span class="n">wait</span><span class="p">(),</span> <span class="nb">true</span><span class="p">),</span> <span class="p">(</span><span class="n">fs</span><span class="p">.</span><span class="n">wait</span><span class="p">(),</span> <span class="nb">true</span><span class="p">)...</span> <span class="p">};</span>

    <span class="c1">// prevent unused parameter warning</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">dummy</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>虽然上述代码实现了<code>wait_for_all</code>这个接口，但是这种实现并不利于<code>future</code>的进一步组合。更好的实现应该是综合所依赖的<code>future</code>生成一个新的<code>future</code>，类似于如下形式:</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">R</span><span class="p">,</span><span class="k">typename</span><span class="p">...</span> <span class="n">Arg</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">all_package</span><span class="p">(</span><span class="n">function</span><span class="o">&lt;</span><span class="n">R</span><span class="p">(</span><span class="n">Arg</span><span class="p">...)</span><span class="o">&gt;&amp;&amp;</span> <span class="n">_f</span><span class="p">,</span> <span class="n">future</span><span class="o">&lt;</span><span class="n">Arg</span><span class="o">&gt;&amp;&amp;</span> <span class="n">all_futures</span><span class="p">...)</span>
<span class="o">-&gt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="n">R</span><span class="p">()</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">future</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;&gt;</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">lambda_task</span> <span class="o">=</span> <span class="p">[</span><span class="n">all</span><span class="o">=</span><span class="n">move</span><span class="p">(</span><span class="n">all_futures</span><span class="p">)...,</span><span class="n">f</span><span class="o">=</span><span class="n">move</span><span class="p">(</span><span class="n">f</span><span class="p">)]()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">all</span><span class="p">.</span><span class="n">get</span><span class="p">()...);</span>
    <span class="p">}</span>
    <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">shared</span><span class="o">&lt;</span><span class="n">R</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">lambda_task</span><span class="p">));</span>
    <span class="k">return</span> <span class="nf">make_pair</span><span class="p">(</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="n">R</span><span class="p">()</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">future</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>


<p>同时添加<code>async_all</code></p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">R</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span><span class="n">Args</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">async_all</span><span class="p">(</span><span class="n">function</span><span class="o">&lt;</span><span class="n">R</span><span class="p">(</span><span class="n">Args</span><span class="p">...)</span><span class="o">&gt;&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">future</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">pack</span> <span class="o">=</span> <span class="n">all_package</span><span class="o">&lt;</span><span class="n">R</span><span class="p">,</span><span class="n">Args</span><span class="p">...</span><span class="o">&gt;</span><span class="p">(</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">function</span><span class="o">&lt;</span><span class="n">R</span><span class="p">(</span><span class="n">Args</span><span class="p">...)</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">forward</span><span class="o">&lt;</span><span class="n">future</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="n">_system</span><span class="p">.</span><span class="n">async_</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pack</span><span class="p">)));</span>
    <span class="k">return</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pack</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h2>wait_any 串联</h2>
<p><code>wait_any</code>相对来说就比较麻烦了，需要实现一个通知机制。只要所等待的<code>future</code>其中一个有了信号，其他的<code>future</code>就不需要再执行了。我们可以采取<code>atomic_bool</code>的形式来实现这个<code>once_flag</code>，剩下的任务就是如何将这个<code>atomic_bool</code>挂载到各个<code>future</code>之上，这个挂载操作我们可以利用<code>then</code>。但是用<code>then</code>的话就无法控制其他<code>future</code>的执行，因为当我们执行<code>then</code>操作的时候之前的结果肯定已经计算完成。所以，我只能说毫无办法。</p>
<p>如果实在想这么做的话，需要在这些<code>future</code>生成之前就定义好这个<code>atomic_bool</code>。同时修改这些任务的执行逻辑，执行前首先判断<code>atomic_bool</code>是否已经<code>set</code>了，没有的话才执行后续任务。</p>                </article>
            </aside><!-- /#featured -->
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="http://getpelican.com/">Pelican</a></li>
                            <li><a href="http://python.org/">Python.org</a></li>
                            <li><a href="http://jinja.pocoo.org/">Jinja2</a></li>
                            <li><a href="#">You can modify those links in your config file</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="#">You can add links in your config file</a></li>
                            <li><a href="#">Another social link</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>
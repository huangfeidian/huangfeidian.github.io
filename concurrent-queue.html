<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Concurrent Queue - spirits away</title>
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.png">
    <link rel="stylesheet" href="./theme/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="./theme/font-icons/style.min.css" type="text/css" />
    <link rel="stylesheet" href="./theme/css/niu2.min.css" type="text/css" />

    <link rel="canonical" href="./concurrent-queue.html" />
    
    <script type="text/javascript">window.onload=function(){};</script>
    <!--[if lt IE 9]>
        <script src="./theme/js/html5shiv.js"></script>
        <script src="./theme/js/respond.min.js"></script>
    <![endif]-->
  </head>
  <body> 
    <div id="body-header">
<div class="navbar navbar-inverse navbar-fixed-top">
<div class="col-md-12">
    <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href=".">
            <i class="icon-home"></i>spirits away
        </a>
    </div>
    <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
        <ul class="nav navbar-nav">
            <li><a href="/pages/about.html" title="about">
                <i class="icon-anchor"></i>关于</a>
            </li>
            <li><a href="/archives.html" title="archives">
                <i class="icon-archive"></i>存档</a>
            </li>
            <li><a href="/tags.html" title="tags">
                <i class="icon-tag"></i>标签</a>
            </li>
        <!-- category dropdown list -->
        <!--  self defined dropdown list -->
        </ul>
        
        <!-- right nav bar -->
        <ul class="nav navbar-nav navbar-right">
        <!-- google custom search -->
       </ul>
    </nav>
</div>
</div>    </div>
    
    <div id="body-content">
<div class="col-md-8 col-md-offset-2">
    <h1 id="content-heading">Concurrent Queue</h1>
</div>
<div id="niu2-left-container" class="col-md-6 col-md-offset-2 with-right-border">
    <div id="niu2-main-content">
        <h1 id="6b5bed">Concurrent Queue</h1>
<p>Herb Sutter在DDJ <code>pillars of concurrency</code>一文中抛出并行编程的三个简单论点，一是分离任务，使用更细粒度的锁或者无锁编程；二是尽量通过并行任务使用CPU资源，以提高系统吞吐量及扩展性；三是保证对共享资源访问的一致性。第三点已经被<code>atomic</code>、<code>mutex</code>、<code>lock</code>、<code>condition_variable</code>解决了，第一点和第二点则可以归结为如何对任务进行粒度划分并投递到任务的执行单元中去调度执行。任务划分依赖于各种不同业务的理解，例如网络和渲染，很难抽取出其共性。而任务的调度执行则是一种通用的结构，可以分为四个部分：</p>
<ol>
<li>任务的封装 在<code>c++11</code>里提供了三种最基本的任务封装形式<code>future, promise,packaged_task</code></li>
<li>任务的结构 在<code>c++17</code>里补全了任务结构控制，主要是提供了<code>then, when_all, when_any</code>这三个用来关联多个<code>future</code>的函数</li>
<li>任务的执行 任务执行者基本都是使用线程池，每个线程不断的尝试获取一个任务并执行，类似于一个while循环</li>
<li>任务的调度 这部分负责了任务的投递和分发，他在多线程之间维持了一个任务容器集合，提供的接口主要包括接受新任务、取出一个任务和判断容器是否为空</li>
</ol>
<p>在整个并发任务系统中，在任务容器集合之上的任务调度结构是核心。现在使用的最广泛的任务容器是concurrent queue，下面我们来对concurrent queue来做一下分析。</p>
<h2 id="8fd87e">naive concurrent queue</h2>
<p>queue是一个维持先进先出（FIFO）队列的结构，在很多STL的实现之中采取的是多块连续内存的双向链表来维持其先进先出结构。为了在多线程中使用<code>std::queue</code>，最简单的方法就是使用锁来解决<code>data race</code>，同时修改原始提供的接口，使得这个数据结构不会被用错。</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp"></span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">concurrent_queue</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mut</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">data_queue</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">data_cond</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">concurrent_queue</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// pass</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="n">T</span> <span class="n">new_value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">mut</span><span class="p">);</span>
        <span class="n">data_queue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>
        <span class="n">data_cond</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">wait_and_pop</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">mut</span><span class="p">);</span>
        <span class="n">data_cond</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="p">[</span><span class="k">this</span><span class="p">]{</span>
            <span class="k">return</span> <span class="o">!</span><span class="n">data_queue</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
        <span class="p">})</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">data_queue</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
        <span class="n">data_queue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">wait_and_pop</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">mut</span><span class="p">);</span>
        <span class="n">data_cond</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="p">[</span><span class="k">this</span><span class="p">]{</span>
            <span class="k">return</span> <span class="o">!</span><span class="n">data_queue</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
        <span class="p">})</span>
        <span class="k">auto</span> <span class="n">res</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">data_queue</span><span class="p">.</span><span class="n">front</span><span class="p">()));</span>
        <span class="n">data_queue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">try_pop</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">mut</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">data_queue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">data_queue</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
        <span class="n">data_queue</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">True</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">try_pop</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">mut</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">data_queue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">auto</span> <span class="n">res</span> <span class="o">=</span>  <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">data_queue</span><span class="p">.</span><span class="n">front</span><span class="p">()));</span>
        <span class="n">data_queue</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">mut</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">data_queue</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>上述代码的主要考量如下：</p>
<ol>
<li>由于多线程的干扰，常规的查询<code>empty</code>之后再<code>pop</code>的处理流程是错误的，这两个操作必须封装在一起，所以这里提供了<code>try_pop</code>和<code>wait_and_pop</code>这两个接口来获取数据。</li>
<li>为了避免在数据拷贝的时候出现异常导致的数据不一致，返回数据的时候采取两套方案，一个是调用者提供引用，一个是返回一个<code>shared_ptr</code>。这样就保证了如果在拷贝构造<code>front</code>的时候出了trace也能维持整个<code>queue</code>的结构完整。</li>
</ol>
<p>这个<code>concurrent_queue</code>并不是很高效，主要的<code>drawback</code>包括如下三个方面:</p>
<ol>
<li>每次访问接口的时候都需要调用锁，而且是同一个锁</li>
<li>在尝试获得数据的时候失败会触发<code>yield</code>，从而导致线程切换</li>
<li>维持了一个全局的先进先出序列，在多消费者的情况下这个强制唯一序是没有意义的，在单消费者的情况下也很少会有这种要求。</li>
</ol>
<p>对应的常见解决方案：</p>
<ol>
<li>使用无锁的方式去代替<code>mutex</code>，同时由于无锁最大的问题是内存分配，有些并发队列通过预先设置最大大小的方式来预分配内存，从而绕过了著名的<code>ABA</code>问题</li>
<li>使用双链表结构去维持队列，而不是使用<code>queue</code>，这样我们就可以分离头节点和尾节点的访问；如果是固定大小的队列则可以采取<code>ring buffer</code>的形式来维持队列结构。</li>
<li>当尝试获得数据失败的时候，先轮询一段时间，如果这段时间内还是没有数据，则调用<code>yield</code>，也就是对<code>condition_variable</code>封装了一层。</li>
<li>每个生产者维护其投递队列，每个消费者根据对各个生产者任务队列的优先级去遍历获取任务。</li>
</ol>
<p>事实上，在这是一个并发<code>queue</code>的时候，首先要明确如下几个问题：</p>
<ol>
<li>
<p>这个<code>queue</code>的生产者和消费者各有多少个，常见的有单生产者单消费者(SPSC)、单生产者多消费者(SPMC)、多生产者单消费者(MPSC)和多生产者多消费者(MPMC)</p>
</li>
<li>
<p>这个queue的最大元素大小是否确定，如果可以确定最大大小，则动态内存分配就可以避免，直接采取环形队列当作容器即可；如果无法确定最大大小，则只能通过动态内存分配的形式去处理，这里的难度加大了很多，因为要处理多线程的内存分配。</p>
</li>
</ol>
<p>下面我们来看一下现在主流的几种<code>concurrent_queue</code>的实现，来分析一下他们对<code>concurrent_queue</code>的实现优化。</p>
<h2 id="d10ffe">intel spsc concurrent queue</h2>
<p><a href="https://software.intel.com/en-us/articles/single-producer-single-consumer-queue">intel官方网站</a>上提供了一个<code>SPSC queue</code>，但是这个<code>queue</code>没有限制最大元素大小，如果临时内存不够的话会调用<code>new</code>，可能会触发锁。</p>
<div class="codehilite"><pre><span></span><span class="c1">// load with &#39;consume&#39; (data-dependent) memory ordering</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">load_consume</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">*</span> <span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// hardware fence is implicit on x86</span>
  <span class="n">T</span> <span class="n">v</span> <span class="o">=</span> <span class="o">*</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">T</span> <span class="k">const</span> <span class="k">volatile</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
  <span class="n">__memory_barrier</span><span class="p">();</span> <span class="c1">// compiler fence</span>
  <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// store with &#39;release&#39; memory ordering</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">store_release</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">addr</span><span class="p">,</span> <span class="n">T</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// hardware fence is implicit on x86</span>
  <span class="n">__memory_barrier</span><span class="p">();</span> <span class="c1">// compiler fence</span>
  <span class="o">*</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">T</span> <span class="k">volatile</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// cache line size on modern x86 processors (in bytes)</span>
<span class="kt">size_t</span> <span class="k">const</span> <span class="n">cache_line_size</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>

<span class="c1">// single-producer/single-consumer queue</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">spsc_queue</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">spsc_queue</span><span class="p">()</span>
  <span class="p">{</span>
      <span class="n">node</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="k">new</span> <span class="n">node</span><span class="p">;</span>
      <span class="n">n</span><span class="o">-&gt;</span><span class="n">next_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">tail_</span> <span class="o">=</span> <span class="n">head_</span> <span class="o">=</span> <span class="n">first_</span><span class="o">=</span> <span class="n">tail_copy_</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">spsc_queue</span><span class="p">()</span>
  <span class="p">{</span>
      <span class="n">node</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">first_</span><span class="p">;</span>
      <span class="k">do</span>
      <span class="p">{</span>
          <span class="n">node</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">;</span>
          <span class="k">delete</span> <span class="n">n</span><span class="p">;</span>
          <span class="n">n</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">enqueue</span><span class="p">(</span><span class="n">T</span> <span class="n">v</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="n">node</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">alloc_node</span><span class="p">();</span>
      <span class="n">n</span><span class="o">-&gt;</span><span class="n">next_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">n</span><span class="o">-&gt;</span><span class="n">value_</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
      <span class="n">store_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head_</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
      <span class="n">head_</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// returns &#39;false&#39; if queue is empty</span>
  <span class="kt">bool</span> <span class="n">dequeue</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">load_consume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tail_</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">))</span>
      <span class="p">{</span>
          <span class="n">v</span> <span class="o">=</span> <span class="n">tail_</span><span class="o">-&gt;</span><span class="n">next_</span><span class="o">-&gt;</span><span class="n">value_</span><span class="p">;</span>
          <span class="n">store_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tail_</span><span class="p">,</span> <span class="n">tail_</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">);</span>
          <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span>
      <span class="p">{</span>
          <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="c1">// internal node structure</span>
  <span class="k">struct</span> <span class="n">node</span>
  <span class="p">{</span>
      <span class="n">node</span><span class="o">*</span> <span class="n">next_</span><span class="p">;</span>
      <span class="n">T</span> <span class="n">value_</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="c1">// consumer part</span>
  <span class="c1">// accessed mainly by consumer, infrequently be producer</span>
  <span class="n">node</span><span class="o">*</span> <span class="n">tail_</span><span class="p">;</span> <span class="c1">// tail of the queue</span>

  <span class="c1">// delimiter between consumer part and producer part,</span>
  <span class="c1">// so that they situated on different cache lines</span>
  <span class="kt">char</span> <span class="n">cache_line_pad_</span> <span class="p">[</span><span class="n">cache_line_size</span><span class="p">];</span>

  <span class="c1">// producer part</span>
  <span class="c1">// accessed only by producer</span>
  <span class="n">node</span><span class="o">*</span> <span class="n">head_</span><span class="p">;</span> <span class="c1">// head of the queue</span>
  <span class="n">node</span><span class="o">*</span> <span class="n">first_</span><span class="p">;</span> <span class="c1">// last unused node (tail of node cache)</span>
  <span class="n">node</span><span class="o">*</span> <span class="n">tail_copy_</span><span class="p">;</span> <span class="c1">// helper (points somewhere between first_ and tail_)</span>

  <span class="n">node</span><span class="o">*</span> <span class="nf">alloc_node</span><span class="p">()</span>
  <span class="p">{</span>
      <span class="c1">// first tries to allocate node from internal node cache,</span>
      <span class="c1">// if attempt fails, allocates node via ::operator new()</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">first_</span> <span class="o">!=</span> <span class="n">tail_copy_</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">node</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">first_</span><span class="p">;</span>
          <span class="n">first_</span> <span class="o">=</span> <span class="n">first_</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">;</span>
          <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">tail_copy_</span> <span class="o">=</span> <span class="n">load_consume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tail_</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">first_</span> <span class="o">!=</span> <span class="n">tail_copy_</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="n">node</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">first_</span><span class="p">;</span>
          <span class="n">first_</span> <span class="o">=</span> <span class="n">first_</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">;</span>
          <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">node</span><span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="k">new</span> <span class="n">node</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">spsc_queue</span><span class="p">(</span><span class="n">spsc_queue</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="n">spsc_queue</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="n">spsc_queue</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// usage example</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">spsc_queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
  <span class="n">q</span><span class="p">.</span><span class="n">enqueue</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">q</span><span class="p">.</span><span class="n">enqueue</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">v</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">b</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">dequeue</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">dequeue</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
  <span class="n">q</span><span class="p">.</span><span class="n">enqueue</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="n">q</span><span class="p">.</span><span class="n">enqueue</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">dequeue</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">dequeue</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">dequeue</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>这个代码的实现很简单粗暴，核心是一个单链表，对于单链表的任何操作都是<code>wait_free</code>的，这个链表有四个指针：</p>
<ol>
<li><code>tail</code>指针，指向下一个应该<code>dequeue</code>的位置</li>
<li><code>head</code>指针，指向最新的一个<code>enqueue</code>的位置</li>
<li><code>first_</code>指针，指向第一个可以回收<code>node</code>的位置</li>
<li><code>tail_copy</code>指针，指向一个安全的可以回收的<code>node</code>的<code>next</code>位置，他不一定指向<code>tail</code>。</li>
</ol>
<p>在这个链表里，指针之间有如下关系：<span class="math">\(first \le tail\_copy \le tail \le head\)</span> 。这里做的核心优化就是按需去更新<code>tail_copy</code>，没必要每次更新<code>tail</code>的时候都把<code>tail_copy</code>更新一遍，只有发现<code>first == tail_copy</code>的时候才去更新一下。每个操作都没有使用到<code>CAS</code>，因此都是<code>wait_free</code>的，当然那一行调用了<code>new</code>的除外。</p>
<p>这里为了避免<code>False Sharing</code>使用了<code>padding</code>。由于读线程只需要更改<code>tail</code>，所以只需要在<code>tail</code>之后加个<code>padding</code>即可。</p>
<h2 id="86a472">facebook spsc concurrent queue</h2>
<p>facebook 提供了固定大小的<code>SPSC queue</code>，代码在<code>folly</code>的<code>ProducerConsumerQueue</code>里。</p>
<div class="codehilite"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Copyright 2017 Facebook, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="cm"> * you may not use this file except in compliance with the License.</span>
<span class="cm"> * You may obtain a copy of the License at</span>
<span class="cm"> *</span>
<span class="cm"> *   http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="cm"> *</span>
<span class="cm"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="cm"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="cm"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="cm"> * See the License for the specific language governing permissions and</span>
<span class="cm"> * limitations under the License.</span>
<span class="cm"> */</span>

<span class="c1">// @author Bo Hu (bhu@fb.com)</span>
<span class="c1">// @author Jordan DeLong (delong.j@fb.com)</span>

<span class="cp">#pragma once</span>

<span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdexcept&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;folly/concurrency/CacheLocality.h&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">folly</span> <span class="p">{</span>

<span class="cm">/*</span>
<span class="cm"> * ProducerConsumerQueue is a one producer and one consumer queue</span>
<span class="cm"> * without locks.</span>
<span class="cm"> */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">ProducerConsumerQueue</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">T</span> <span class="n">value_type</span><span class="p">;</span>

  <span class="n">ProducerConsumerQueue</span><span class="p">(</span><span class="k">const</span> <span class="n">ProducerConsumerQueue</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
  <span class="n">ProducerConsumerQueue</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">ProducerConsumerQueue</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

  <span class="c1">// size must be &gt;= 2.</span>
  <span class="c1">//</span>
  <span class="c1">// Also, note that the number of usable slots in the queue at any</span>
  <span class="c1">// given time is actually (size-1), so if you start with an empty queue,</span>
  <span class="c1">// isFull() will return true after size-1 insertions.</span>
  <span class="k">explicit</span> <span class="nf">ProducerConsumerQueue</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">size</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">size_</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">records_</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">size</span><span class="p">)))</span>
    <span class="p">,</span> <span class="n">readIndex_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">,</span> <span class="n">writeIndex_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">records_</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">ProducerConsumerQueue</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// We need to destruct anything that may still exist in our queue.</span>
    <span class="c1">// (No real synchronization needed at destructor time: only one</span>
    <span class="c1">// thread can be doing this.)</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_trivially_destructible</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">size_t</span> <span class="n">readIndex</span> <span class="o">=</span> <span class="n">readIndex_</span><span class="p">;</span>
      <span class="kt">size_t</span> <span class="n">endIndex</span> <span class="o">=</span> <span class="n">writeIndex_</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">readIndex</span> <span class="o">!=</span> <span class="n">endIndex</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">records_</span><span class="p">[</span><span class="n">readIndex</span><span class="p">].</span><span class="o">~</span><span class="n">T</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">readIndex</span> <span class="o">==</span> <span class="n">size_</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">readIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">records_</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="err">...</span><span class="nc">Args</span><span class="o">&gt;</span>
  <span class="kt">bool</span> <span class="n">write</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">recordArgs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="k">const</span> <span class="n">currentWrite</span> <span class="o">=</span> <span class="n">writeIndex_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">nextRecord</span> <span class="o">=</span> <span class="n">currentWrite</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nextRecord</span> <span class="o">==</span> <span class="n">size_</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">nextRecord</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nextRecord</span> <span class="o">!=</span> <span class="n">readIndex_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">new</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">records_</span><span class="p">[</span><span class="n">currentWrite</span><span class="p">])</span> <span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">recordArgs</span><span class="p">)...);</span>
      <span class="n">writeIndex_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">nextRecord</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// queue is full</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// move (or copy) the value at the front of the queue to given variable</span>
  <span class="kt">bool</span> <span class="n">read</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">record</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="k">const</span> <span class="n">currentRead</span> <span class="o">=</span> <span class="n">readIndex_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">currentRead</span> <span class="o">==</span> <span class="n">writeIndex_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">))</span> <span class="p">{</span>
      <span class="c1">// queue is empty</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="n">nextRecord</span> <span class="o">=</span> <span class="n">currentRead</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nextRecord</span> <span class="o">==</span> <span class="n">size_</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">nextRecord</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">record</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">records_</span><span class="p">[</span><span class="n">currentRead</span><span class="p">]);</span>
    <span class="n">records_</span><span class="p">[</span><span class="n">currentRead</span><span class="p">].</span><span class="o">~</span><span class="n">T</span><span class="p">();</span>
    <span class="n">readIndex_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">nextRecord</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// pointer to the value at the front of the queue (for use in-place) or</span>
  <span class="c1">// nullptr if empty.</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">frontPtr</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="k">const</span> <span class="n">currentRead</span> <span class="o">=</span> <span class="n">readIndex_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">currentRead</span> <span class="o">==</span> <span class="n">writeIndex_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">))</span> <span class="p">{</span>
      <span class="c1">// queue is empty</span>
      <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">records_</span><span class="p">[</span><span class="n">currentRead</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">// queue must not be empty</span>
  <span class="kt">void</span> <span class="n">popFront</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="k">const</span> <span class="n">currentRead</span> <span class="o">=</span> <span class="n">readIndex_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">currentRead</span> <span class="o">!=</span> <span class="n">writeIndex_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">));</span>

    <span class="k">auto</span> <span class="n">nextRecord</span> <span class="o">=</span> <span class="n">currentRead</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nextRecord</span> <span class="o">==</span> <span class="n">size_</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">nextRecord</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">records_</span><span class="p">[</span><span class="n">currentRead</span><span class="p">].</span><span class="o">~</span><span class="n">T</span><span class="p">();</span>
    <span class="n">readIndex_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">nextRecord</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">isEmpty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">readIndex_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">)</span> <span class="o">==</span>
        <span class="n">writeIndex_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">isFull</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">nextRecord</span> <span class="o">=</span> <span class="n">writeIndex_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nextRecord</span> <span class="o">==</span> <span class="n">size_</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">nextRecord</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nextRecord</span> <span class="o">!=</span> <span class="n">readIndex_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// queue is full</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// * If called by consumer, then true size may be more (because producer may</span>
  <span class="c1">//   be adding items concurrently).</span>
  <span class="c1">// * If called by producer, then true size may be less (because consumer may</span>
  <span class="c1">//   be removing items concurrently).</span>
  <span class="c1">// * It is undefined to call this from any other thread.</span>
  <span class="kt">size_t</span> <span class="n">sizeGuess</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">writeIndex_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">)</span> <span class="o">-</span>
        <span class="n">readIndex_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ret</span> <span class="o">+=</span> <span class="n">size_</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
 <span class="kt">char</span> <span class="n">pad0_</span><span class="p">[</span><span class="n">CacheLocality</span><span class="o">::</span><span class="n">kFalseSharingRange</span><span class="p">];</span>
 <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">size_</span><span class="p">;</span>
 <span class="n">T</span><span class="o">*</span> <span class="k">const</span> <span class="n">records_</span><span class="p">;</span>

 <span class="n">FOLLY_ALIGN_TO_AVOID_FALSE_SHARING</span> <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">readIndex_</span><span class="p">;</span>
 <span class="n">FOLLY_ALIGN_TO_AVOID_FALSE_SHARING</span> <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">writeIndex_</span><span class="p">;</span>

 <span class="kt">char</span> <span class="n">pad1_</span><span class="p">[</span><span class="n">CacheLocality</span><span class="o">::</span><span class="n">kFalseSharingRange</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">writeIndex_</span><span class="p">)];</span>
<span class="p">};</span>

<span class="p">}</span>
</pre></div>


<p>这里就是使用环形队列来作为容器，双指针来作为头尾，读线程读取<code>readIndex</code>直接采用<code>relaxed</code>，写线程读取<code>writeIndex</code>的时候也是采取<code>relaxed</code>，因为这两个变量只会在对应的线程内修改，可以认为是对应线程的私有变量，如果要读取另外一个线程的变量则需要采取<code>acquire</code>，当然前提是修改的时候使用了<code>release</code>。为了避免<code>False Sharing</code>这里也使用了<code>padding</code>，只不过是用宏做的。</p>
<p>其实这里也可以做一点优化，就像前面<code>intel</code>的延迟处理<code>tail_copy</code>一样，首次读取另外一个线程变量的时候先用<code>relaxed</code>，如果发现不能操作了，则再使用<code>acquire</code>。</p>
<p>总的来说，这个无锁<code>spsc queue</code>也是<code>wait_free</code>的。</p>
<h2 id="7f087f">moodycamel spsc concurrent queue</h2>
<p>moody camel 在上面的基础上做了一些改进：在支持无大小限制的情况下，将动态内存分配的需求降得很低，同时支持了容量的动态增长。其容器结构是两层的<code>queue of queue</code>，第一层是循环链表，第二层是循环队列。第一层循环链表的控制基本等价于<code>intel</code>的<code>spsc</code>里的代码，而第二层的循环队列的控制基本等价于<code>folly</code>的代码。当<code>enqueue</code>的时候，发现没有空闲内存的时候会调用<code>malloc</code>，不过这种动态内存分配比起<code>intel</code>的每个新<code>node</code>都分配来说简单多了，总的来说还是比较符合<code>wait_free</code>的。这个的代码我就不分析了，直接贴作者的解释吧。</p>
<div class="codehilite"><pre><span></span># Enqueue
If room in tail block, add to tail
Else check next block
    If next block is not the head block, enqueue on next block
    Else create a new block and enqueue there
    Advance tail to the block we just enqueued to

# Dequeue
Remember where the tail block is
If the front block has an element in it, dequeue it
Else
    If front block was the tail block when we entered the function, return false
    Else advance to next block and dequeue the item there
</pre></div>


<h2 id="a39b9e">naive spmc concurrent queue</h2>
<p>在这前面介绍的<code>spsc</code>并发队列的基础上，我们可以比较容易的构建出一个<code>spmc</code>的并发队列，而构造一个<code>mpsc</code>的并发队列则难很多。其原因主要是在<code>enqueue</code>的时候，可能会涉及到动态内存分配，如果有好几个线程都抢着进行动态内存分配的话，就会出现<code>malloc</code>的锁征用。而多个线程抢占<code>dequeue</code>的时候，只需要采取<code>CAS</code>来保持<code>tail</code>的更新即可，虽说这个不是<code>waitfree</code>的，但是<code>lockfree</code>还是可以基本保证的。</p>
<h2 id="9a6f11">boost mpmc concurrent queue</h2>
<p><code>boost  concurrent queue</code>通过模板参数的方式来支持固定大小的队列和不定大小的队列。</p>
<p>如果是固定大小队列，则会使用一个带<code>dummy head</code>的<code>ring buffer</code>来存储内容，同时使用一个头节点索引和一个尾节点索引来标记队列的头尾位置。为了一次性的修改头尾节点索引，这里将队列大小的上限设置为了<span class="math">\(2^{16} - 2\)</span>  ，这样两个索引就可以合并为一个<code>int32</code> 来处理，修改的时候可以使用<code>compare_exchange_</code>来同时修改。如果在支持<code>int64</code>类型的<code>compare_exchange_</code>操作的平台，队列大小的上限可以放到<span class="math">\(2^{32} -2\)</span> ，同时两个索引会被压缩为一个<code>int64</code>来做同时修改。</p>
<p>如果是不定大小的队列，则会使用链表的形式来维持队列结构, 代码见下。</p>
<div class="codehilite"><pre><span></span> <span class="k">struct</span> <span class="n">BOOST_LOCKFREE_CACHELINE_ALIGNMENT</span> <span class="n">node</span>
 <span class="p">{</span>
   <span class="k">typedef</span> <span class="k">typename</span> <span class="n">detail</span><span class="o">::</span><span class="n">select_tagged_handle</span><span class="o">&lt;</span><span class="n">node</span><span class="p">,</span> <span class="n">node_based</span><span class="o">&gt;::</span><span class="n">tagged_handle_type</span> <span class="n">tagged_node_handle</span><span class="p">;</span>
   <span class="k">typedef</span> <span class="k">typename</span> <span class="n">detail</span><span class="o">::</span><span class="n">select_tagged_handle</span><span class="o">&lt;</span><span class="n">node</span><span class="p">,</span> <span class="n">node_based</span><span class="o">&gt;::</span><span class="n">handle_type</span> <span class="n">handle_type</span><span class="p">;</span>

   <span class="n">node</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="n">handle_type</span> <span class="n">null_handle</span><span class="p">)</span><span class="o">:</span>
   <span class="n">data</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="c1">//, next(tagged_node_handle(0, 0))</span>
   <span class="p">{</span>
     <span class="cm">/* increment tag to avoid ABA problem */</span>
     <span class="n">tagged_node_handle</span> <span class="n">old_next</span> <span class="o">=</span> <span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
     <span class="n">tagged_node_handle</span> <span class="nf">new_next</span> <span class="p">(</span><span class="n">null_handle</span><span class="p">,</span> <span class="n">old_next</span><span class="p">.</span><span class="n">get_next_tag</span><span class="p">());</span>
     <span class="n">next</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">new_next</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span>
   <span class="p">}</span>

   <span class="n">node</span> <span class="p">(</span><span class="n">handle_type</span> <span class="n">null_handle</span><span class="p">)</span><span class="o">:</span>
   <span class="n">next</span><span class="p">(</span><span class="n">tagged_node_handle</span><span class="p">(</span><span class="n">null_handle</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
   <span class="p">{}</span>

   <span class="n">node</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
   <span class="p">{}</span>

   <span class="n">atomic</span><span class="o">&lt;</span><span class="n">tagged_node_handle</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">;</span>
   <span class="n">T</span> <span class="n">data</span><span class="p">;</span>
 <span class="p">};</span>
</pre></div>


<p>这里比较有意思的就是第九行的注释：对指针的<code>tag</code>位置进行自增来避免<code>ABA</code>问题。这里的<code>next</code>指针是一个<code>tagged_pointer</code>，其分配位置是内存对齐的，对齐的大小由<code>BOOST_LOCKFREE_CACHELINE_BYTES</code>定义，在<code>WIN</code>平台下，这个宏定义如下：</p>
<div class="codehilite"><pre><span></span><span class="cp">#define BOOST_LOCKFREE_CACHELINE_BYTES 64</span>
<span class="cp">#ifdef _MSC_VER</span>
<span class="cp">#define BOOST_LOCKFREE_CACHELINE_ALIGNMENT __declspec(align(BOOST_LOCKFREE_CACHELINE_BYTES))</span>
</pre></div>


<p>当这个指针是64字节对齐时，最底的6位是没有意义的，所以这6位我们可以用来存储额外的数据，这种指针就叫做<code>tagged_pointer</code>，在<code>llvm</code>里这个指针结构也很常见。</p>
<p>在<code>boost lockfree queue</code>里，数据成员定义如下：</p>
<div class="codehilite"><pre><span></span><span class="k">typedef</span> <span class="k">typename</span> <span class="n">detail</span><span class="o">::</span><span class="n">queue_signature</span><span class="o">::</span><span class="n">bind</span><span class="o">&lt;</span><span class="n">A0</span><span class="p">,</span> <span class="n">A1</span><span class="p">,</span> <span class="n">A2</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">bound_args</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">has_capacity</span> <span class="o">=</span> <span class="n">detail</span><span class="o">::</span><span class="n">extract_capacity</span><span class="o">&lt;</span><span class="n">bound_args</span><span class="o">&gt;::</span><span class="n">has_capacity</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="n">capacity</span> <span class="o">=</span> <span class="n">detail</span><span class="o">::</span><span class="n">extract_capacity</span><span class="o">&lt;</span><span class="n">bound_args</span><span class="o">&gt;::</span><span class="n">capacity</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// the queue uses one dummy node</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">fixed_sized</span> <span class="o">=</span> <span class="n">detail</span><span class="o">::</span><span class="n">extract_fixed_sized</span><span class="o">&lt;</span><span class="n">bound_args</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">node_based</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">has_capacity</span> <span class="o">||</span> <span class="n">fixed_sized</span><span class="p">);</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">compile_time_sized</span> <span class="o">=</span> <span class="n">has_capacity</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">typename</span> <span class="n">detail</span><span class="o">::</span><span class="n">extract_allocator</span><span class="o">&lt;</span><span class="n">bound_args</span><span class="p">,</span> <span class="n">node</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">node_allocator</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">typename</span> <span class="n">detail</span><span class="o">::</span><span class="n">select_freelist</span><span class="o">&lt;</span><span class="n">node</span><span class="p">,</span> <span class="n">node_allocator</span><span class="p">,</span> <span class="n">compile_time_sized</span><span class="p">,</span> <span class="n">fixed_sized</span><span class="p">,</span> <span class="n">capacity</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">pool_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">typename</span> <span class="n">pool_t</span><span class="o">::</span><span class="n">tagged_node_handle</span> <span class="n">tagged_node_handle</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">typename</span> <span class="n">detail</span><span class="o">::</span><span class="n">select_tagged_handle</span><span class="o">&lt;</span><span class="n">node</span><span class="p">,</span> <span class="n">node_based</span><span class="o">&gt;::</span><span class="n">handle_type</span> <span class="n">handle_type</span><span class="p">;</span>

<span class="n">atomic</span><span class="o">&lt;</span><span class="n">tagged_node_handle</span><span class="o">&gt;</span> <span class="n">head_</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">padding_size</span> <span class="o">=</span> <span class="n">BOOST_LOCKFREE_CACHELINE_BYTES</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tagged_node_handle</span><span class="p">);</span>
<span class="kt">char</span> <span class="n">padding1</span><span class="p">[</span><span class="n">padding_size</span><span class="p">];</span>
<span class="n">atomic</span><span class="o">&lt;</span><span class="n">tagged_node_handle</span><span class="o">&gt;</span> <span class="n">tail_</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">padding2</span><span class="p">[</span><span class="n">padding_size</span><span class="p">];</span>
<span class="n">pool_t</span> <span class="n">pool</span><span class="p">;</span> <span class="c1">//代表node的pool 可以当作内存分配器</span>
</pre></div>


<p>因为<code>atomic&lt;T*&gt;</code>内部只包含一个<code>T*</code>作为成员变量，所以<code>atomic&lt;T*&gt;</code>与<code>T*</code>的内存布局是一样的，所以这里的<code>padding_size</code>才会这样计算出来。这里的<code>padding</code>的意义在于让<code>poll</code>的开始地址是<code>BOOST_LOCKFREE_CACHELINE_BYTES</code>对齐的，同时这里分为了两个<code>padding</code>而不是一个<code>padding</code>主要是考虑到将<code>tail head</code>分离在两个<code>cache_line</code>上，避免不同线程之间的缓存竞争。</p>
<p>现在我们来看这个<code>lockfree queue</code>提供的接口。</p>
<p>首先查看<code>empty</code>。</p>
<div class="codehilite"><pre><span></span><span class="cm">/** Check if the queue is empty</span>
<span class="cm">*</span>
<span class="cm">* \return true, if the queue is empty, false otherwise</span>
<span class="cm">* \note The result is only accurate, if no other thread modifies the queue. Therefore it is rarely practical to use this</span>
<span class="cm">*       value in program logic.</span>
<span class="cm">* */</span><span class="w"></span>
bool<span class="w"> </span>empty<span class="o">(</span>void<span class="o">)</span><span class="w"></span>
<span class="err">{</span><span class="w"></span>
<span class="kr">return</span><span class="w"> </span>pool<span class="o">.</span>get_handle<span class="o">(</span>head_<span class="o">.</span>load<span class="o">())</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>pool<span class="o">.</span>get_handle<span class="o">(</span>tail_<span class="o">.</span>load<span class="o">())</span><span class="err">;</span><span class="w"></span>
<span class="err">}</span><span class="w"></span>
</pre></div>


<p>注释里写的很清楚了，这个函数的返回值是不准确的，因为在没有锁的情况下无法同时获得<code>head tail</code>的准确值。</p>
<p>现在来看<code>push</code>，这里分为了两个接口<code>push bounded_push</code>，区分在于如果内存池已经用完，第一个<code>push</code>在当前队列是大小固定的情况下会返回<code>false</code>，不固定的情况下会向操作系统尝试申请更多的内存并返回；而第二个<code>bounded_push</code>则直接返回<code>false</code>。</p>
<div class="codehilite"><pre><span></span><span class="cm">/** Pushes object t to the queue.</span>
<span class="cm">*</span>
<span class="cm">* \post object will be pushed to the queue, if internal node can be allocated</span>
<span class="cm">* \returns true, if the push operation is successful.</span>
<span class="cm">*</span>
<span class="cm">* \note Thread-safe. If internal memory pool is exhausted and the memory pool is not fixed-sized, a new node will be allocated</span>
<span class="cm">*                    from the OS. This may not be lock-free.</span>
<span class="cm">* */</span><span class="w"></span>
bool<span class="w"> </span><span class="kr">push</span><span class="o">(</span>T<span class="w"> </span>const<span class="w"> </span><span class="o">&amp;</span><span class="w"> </span>t<span class="o">)</span><span class="w"></span>
<span class="err">{</span><span class="w"></span>
<span class="w">    </span><span class="kr">return</span><span class="w"> </span>do_push<span class="o">&lt;</span>false<span class="o">&gt;(</span>t<span class="o">)</span><span class="err">;</span><span class="w"></span>
<span class="err">}</span><span class="w"></span>

<span class="cm">/** Pushes object t to the queue.</span>
<span class="cm">*</span>
<span class="cm">* \post object will be pushed to the queue, if internal node can be allocated</span>
<span class="cm">* \returns true, if the push operation is successful.</span>
<span class="cm">*</span>
<span class="cm">* \note Thread-safe and non-blocking. If internal memory pool is exhausted, operation will fail</span>
<span class="cm">* \throws if memory allocator throws</span>
<span class="cm">* */</span><span class="w"></span>
bool<span class="w"> </span>bounded_push<span class="o">(</span>T<span class="w"> </span>const<span class="w"> </span><span class="o">&amp;</span><span class="w"> </span>t<span class="o">)</span><span class="w"></span>
<span class="err">{</span><span class="w"></span>
<span class="w">    </span><span class="kr">return</span><span class="w"> </span>do_push<span class="o">&lt;</span>true<span class="o">&gt;(</span>t<span class="o">)</span><span class="err">;</span><span class="w"></span>
<span class="err">}</span><span class="w"></span>
</pre></div>


<p>这两个函数都调用了<code>do_push</code>，这个函数的定义如下：</p>
<div class="codehilite"><pre><span></span>    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">Bounded</span><span class="o">&gt;</span>
    <span class="kt">bool</span> <span class="n">do_push</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">using</span> <span class="n">detail</span><span class="o">::</span><span class="n">likely</span><span class="p">;</span>

        <span class="n">node</span> <span class="o">*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">pool</span><span class="p">.</span><span class="k">template</span> <span class="n">construct</span><span class="o">&lt;</span><span class="nb">true</span><span class="p">,</span> <span class="n">Bounded</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">pool</span><span class="p">.</span><span class="n">null_handle</span><span class="p">());</span>
        <span class="n">handle_type</span> <span class="n">node_handle</span> <span class="o">=</span> <span class="n">pool</span><span class="p">.</span><span class="n">get_handle</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
            <span class="n">tagged_node_handle</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">memory_order_acquire</span><span class="p">);</span>
            <span class="n">node</span> <span class="o">*</span> <span class="n">tail_node</span> <span class="o">=</span> <span class="n">pool</span><span class="p">.</span><span class="n">get_pointer</span><span class="p">(</span><span class="n">tail</span><span class="p">);</span>
            <span class="n">tagged_node_handle</span> <span class="n">next</span> <span class="o">=</span> <span class="n">tail_node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">memory_order_acquire</span><span class="p">);</span>
            <span class="n">node</span> <span class="o">*</span> <span class="n">next_ptr</span> <span class="o">=</span> <span class="n">pool</span><span class="p">.</span><span class="n">get_pointer</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>

            <span class="n">tagged_node_handle</span> <span class="n">tail2</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">memory_order_acquire</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">tail</span> <span class="o">==</span> <span class="n">tail2</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">next_ptr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">tagged_node_handle</span> <span class="n">new_tail_next</span><span class="p">(</span><span class="n">node_handle</span><span class="p">,</span> <span class="n">next</span><span class="p">.</span><span class="n">get_next_tag</span><span class="p">());</span>
                    <span class="k">if</span> <span class="p">(</span> <span class="n">tail_node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">new_tail_next</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
                        <span class="n">tagged_node_handle</span> <span class="n">new_tail</span><span class="p">(</span><span class="n">node_handle</span><span class="p">,</span> <span class="n">tail</span><span class="p">.</span><span class="n">get_next_tag</span><span class="p">());</span>
                        <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_strong</span><span class="p">(</span><span class="n">tail</span><span class="p">,</span> <span class="n">new_tail</span><span class="p">);</span>
                        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="n">tagged_node_handle</span> <span class="n">new_tail</span><span class="p">(</span><span class="n">pool</span><span class="p">.</span><span class="n">get_handle</span><span class="p">(</span><span class="n">next_ptr</span><span class="p">),</span> <span class="n">tail</span><span class="p">.</span><span class="n">get_next_tag</span><span class="p">());</span>
                    <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_strong</span><span class="p">(</span><span class="n">tail</span><span class="p">,</span> <span class="n">new_tail</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>


<p>这里比较难理解的一点就是<code>tail tail2</code>，以及最后30行的<code>compare_exchange_strong</code>。这里在19行使用判断的意义是避免在内部做无用功，虽然不使用19行的判断， <code>tail</code>改变之后，20行所在分支的检测都会<code>fail</code>掉，对正确性没影响，对性能上来说提升很大。在一个完整的成功<code>push</code>流程中有两个<code>cas</code>操作，我们需要担心的是在两个<code>cas</code>操作之间线程被换出之后会出现何种结果，也就是在24行之前被换出。此时老的<code>tail</code>的<code>next</code>已经被修正为了新数据，而新<code>tail</code>却没有更新。在下一个线程进来的时候会发现<code>tail-&gt;next != 0</code>， 因此会进28号的分支，在此分支之内会尝试将<code>tail-&gt;next</code>更新为<code>tail</code>，这样就避免了数据更新到一半的尴尬局面。</p>
<p>对于<code>pop</code>则只有一个函数:</p>
<div class="codehilite"><pre><span></span>    <span class="cm">/** Pops object from queue.</span>
<span class="cm">     *</span>
<span class="cm">     * \pre type U must be constructible by T and copyable, or T must be convertible to U</span>
<span class="cm">     * \post if pop operation is successful, object will be copied to ret.</span>
<span class="cm">     * \returns true, if the pop operation is successful, false if queue was empty.</span>
<span class="cm">     *</span>
<span class="cm">     * \note Thread-safe and non-blocking</span>
<span class="cm">     * */</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
    <span class="kt">bool</span> <span class="n">pop</span> <span class="p">(</span><span class="n">U</span> <span class="o">&amp;</span> <span class="n">ret</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">using</span> <span class="n">detail</span><span class="o">::</span><span class="n">likely</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
            <span class="n">tagged_node_handle</span> <span class="n">head</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">memory_order_acquire</span><span class="p">);</span>
            <span class="n">node</span> <span class="o">*</span> <span class="n">head_ptr</span> <span class="o">=</span> <span class="n">pool</span><span class="p">.</span><span class="n">get_pointer</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>

            <span class="n">tagged_node_handle</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">tail_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">memory_order_acquire</span><span class="p">);</span>
            <span class="n">tagged_node_handle</span> <span class="n">next</span> <span class="o">=</span> <span class="n">head_ptr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">memory_order_acquire</span><span class="p">);</span>
            <span class="n">node</span> <span class="o">*</span> <span class="n">next_ptr</span> <span class="o">=</span> <span class="n">pool</span><span class="p">.</span><span class="n">get_pointer</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>

            <span class="n">tagged_node_handle</span> <span class="n">head2</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">memory_order_acquire</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="n">head2</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">pool</span><span class="p">.</span><span class="n">get_handle</span><span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="o">==</span> <span class="n">pool</span><span class="p">.</span><span class="n">get_handle</span><span class="p">(</span><span class="n">tail</span><span class="p">))</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">next_ptr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

                    <span class="n">tagged_node_handle</span> <span class="nf">new_tail</span><span class="p">(</span><span class="n">pool</span><span class="p">.</span><span class="n">get_handle</span><span class="p">(</span><span class="n">next</span><span class="p">),</span> <span class="n">tail</span><span class="p">.</span><span class="n">get_next_tag</span><span class="p">());</span>
                    <span class="n">tail_</span><span class="p">.</span><span class="n">compare_exchange_strong</span><span class="p">(</span><span class="n">tail</span><span class="p">,</span> <span class="n">new_tail</span><span class="p">);</span>

                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">next_ptr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="cm">/* this check is not part of the original algorithm as published by michael and scott</span>
<span class="cm">                         *</span>
<span class="cm">                         * however we reuse the tagged_ptr part for the freelist and clear the next part during node</span>
<span class="cm">                         * allocation. we can observe a null-pointer here.</span>
<span class="cm">                         * */</span>
                        <span class="k">continue</span><span class="p">;</span>
                    <span class="n">detail</span><span class="o">::</span><span class="n">copy_payload</span><span class="p">(</span><span class="n">next_ptr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

                    <span class="n">tagged_node_handle</span> <span class="nf">new_head</span><span class="p">(</span><span class="n">pool</span><span class="p">.</span><span class="n">get_handle</span><span class="p">(</span><span class="n">next</span><span class="p">),</span> <span class="n">head</span><span class="p">.</span><span class="n">get_next_tag</span><span class="p">());</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">new_head</span><span class="p">))</span> <span class="p">{</span>
                        <span class="n">pool</span><span class="p">.</span><span class="k">template</span> <span class="n">destruct</span><span class="o">&lt;</span><span class="nb">true</span><span class="o">&gt;</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
                        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>


<p>这里就简单多了，成功的<code>pop</code>只需要一个<code>compare_exchange_weak</code>即可，所以就不需要担心数据更改到一半的问题，这里的28行处理的还是<code>tail</code>数据更新到一半的问题。</p>
<p>这里比较有意思的一点就是42行的<code>.template</code>，这个叫做<a href="http://en.cppreference.com/w/cpp/language/dependent_name">template disambiguator</a>， 其作用就是通知编译器<code>destruct&lt;true&gt;</code>是一个模板，而不是<code>destruct &lt; true</code> 。</p>
<p>总的来说， <code>boost lockfree queue</code>的注意点完全在<code>lock free</code>上，并没有采取每个生产者单独一个<code>queue</code>的方式来解决争用，虽然我们可以在<code>lockfree queue</code>的基础上做一个这样的东西。</p>
<h2 id="cecc0c">intel tbb concurrent queue</h2>
<p>其实这个的总体实现与boost类似。占坑，以后填。粗看起来，这个东西的实现很具有<code>STL</code>的风格。</p>
<h2 id="01023c">moodycamel concurrent queue</h2>
<p>这个<code>concurrent queue</code>的实现被很多项目使用过， 值得重点分析。这个实现的突出之处在于，每个生产者都维持自己的专属<code>queue</code>，而不同的消费者会以不同的顺序去访问各个生产者的<code>queue</code>，直到遇到一个不为空的<code>queue</code>。简而言之，他所实现的<code>MPMC(multiple producer multiple consumer)</code>的队列建立在了<code>SPMC</code>的多线程队列的基础上。这个<code>SPMC</code>的实现是<code>lockfree</code>的，同时还增加了<code>bulk</code>操作。下面来慢慢介绍这个的设计。</p>
<p>首先就是在构建消费者的时候，尽可能的让消费者与生产者均衡绑定，内部实现是通过使用一个<code>token</code>来维持消费者与生产者之间的亲和性。其实最简单的亲和性分配的方法就是每个消费者分配一个生产者的编号，<code>dequeue</code>的时候采取轮询的方式，每次开始轮询的时候都以上次<code>dequeue</code>成功的生产者<code>queue</code>开始。</p>
<p>处理完了多生产者多消费者之间的映射，现在剩下的内容就是如何更高效的处理单生产者多消费者。moodycamel这里的主要改进就是单个<code>queue</code>的存储结构，这里采取的是两层的循环队列，第一层循环队列存储的是第二层循环队列的指针。一个队列只需要维护四个索引，考虑到原子性修改可以把消费者的两个索引合并为一个<code>uint64</code>或者<code>uint32t</code>，因为只有消费者会发生数据竞争，为了方便比较，也顺便把生产者的两个索引合并为一个<code>uint64t or uint32t</code>，这样就可以直接使用整数比较了。在<code>enqueue</code>的时候，数据复制完成之后，直接对生产者的索引自增即可。而<code>dequeue</code>的时候则没这么容易，此时首先自增消费者索引，然后判断当前消费者索引是否已经越过生产者索引，如果越过了，则对则对另外一个<code>overcommit</code>计数器进行自增，三个计数器合用才能获得真正的容量。</p>
<p>这里使用环形缓冲来扩容而不是采取列表来扩容，主要是因为连续的空间操作可以支持批量的<code>enqueue</code>和<code>dequeue</code>操作，直接预先占据一些索引就行了。</p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
    </div>
    <div id="content-comments">
</div>

</div>
<div class="niu2-right-container col-md-2">
    <div id="niu2-sidebar-meta" class="niu2-sidebar">
        <div class="niu2-sidebar-label"><i class="icon-calendar"></i>Published:</div>
        <div class="niu2-sidebar-value">2017-06-08 22:00</div>
        <div class="niu2-sidebar-label"><i class="icon-open-folder"></i>Category:</div>
        <div class="niu2-sidebar-value"><a href="./category/concurrency.html">Concurrency</a></div>
        <div class="niu2-sidebar-label"><i class="icon-tag"></i>Tag:</div>
 
            <div class="niu2-sidebar-inter-value niu2-sidebar-tag"><a href="./tag/concurrency.html">Concurrency</a><sup>4</sup></div>
            <div class="niu2-sidebar-inter-value niu2-sidebar-tag"><a href="./tag/cpp.html">Cpp</a><sup>15</sup></div>
    </div>

    <div id="niu2-sidebar-toc" class="niu2-sidebar" data-status="closed">
        <div class="niu2-sidebar-label">
            <i id="niu2-sidebar-toc-ctrl" class="icon-open-tocs"></i>TOC
        </div>
        <ol id="niu2-sidebar-toc-list">
            <li><a href="#content-heading">Concurrent Queue</a></li>
            <li><a href='#6b5bed'>Concurrent Queue</a><ol><li><a href='#8fd87e'>naive concurrent queue</a></li><li><a href='#d10ffe'>intel spsc concurrent queue</a></li><li><a href='#86a472'>facebook spsc concurrent queue</a></li><li><a href='#7f087f'>moodycamel spsc concurrent queue</a></li><li><a href='#a39b9e'>naive spmc concurrent queue</a></li><li><a href='#9a6f11'>boost mpmc concurrent queue</a></li><li><a href='#cecc0c'>intel tbb concurrent queue</a></li><li><a href='#01023c'>moodycamel concurrent queue</a></li></ol></li>
        </ol>
    </div>
</div>    </div>

    <div class="niu2-footer">
        <div id="body-footer" class="col-md-6 col-md-offset-2">
<hr/>
<p>
    Powered by <a href="https://github.com/getpelican/pelican">Pelican</a>, 
    <a href="https://github.com/mawenbao/niu-x2-sidebar">theme</a> built with <a href="http://getbootstrap.com">Bootstrap3</a>
    by <a href="http://blog.atime.me">Ma Wenbao</a>, icons by 
    <a href="http://fortawesome.github.io/Font-Awesome">Font Awesome</a>.
</p>
<p>
    ©
            2014-2017
    <a class="niu2-footer-link" href=".">Huiliang Huang</a>
</p>
<p class="niu2-icons">
</p>        </div>
    </div>
    
    <div id="niu2-pygments" data-theme="github"></div>

    <script type="text/javascript" src="./theme/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="./theme/js/niu2.min.js"></script>
    <script type="text/javascript" src="./theme/js/bootstrap.min.js"></script>
    <script type="text/javascript">onContentLoaded();</script>
  </body>
</html>
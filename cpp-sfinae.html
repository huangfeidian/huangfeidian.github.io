<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CPP SFINAE - spirits away</title>
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.png">
    <link rel="stylesheet" href="./theme/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="./theme/font-icons/style.min.css" type="text/css" />
    <link rel="stylesheet" href="./theme/css/niu2.min.css" type="text/css" />

    <link rel="canonical" href="./cpp-sfinae.html" />
    
    <script type="text/javascript">window.onload=function(){};</script>
    <!--[if lt IE 9]>
        <script src="./theme/js/html5shiv.js"></script>
        <script src="./theme/js/respond.min.js"></script>
    <![endif]-->
  </head>
  <body> 
    <div id="body-header">
<div class="navbar navbar-inverse navbar-fixed-top">
<div class="col-md-12">
    <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href=".">
            <i class="icon-home"></i>spirits away
        </a>
    </div>
    <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
        <ul class="nav navbar-nav">
            <li><a href="/pages/about.html" title="about">
                <i class="icon-anchor"></i>关于</a>
            </li>
            <li><a href="/archives.html" title="archives">
                <i class="icon-archive"></i>存档</a>
            </li>
            <li><a href="/tags.html" title="tags">
                <i class="icon-tag"></i>标签</a>
            </li>
        <!-- category dropdown list -->
        <!--  self defined dropdown list -->
        </ul>
        
        <!-- right nav bar -->
        <ul class="nav navbar-nav navbar-right">
        <!-- google custom search -->
       </ul>
    </nav>
</div>
</div>    </div>
    
    <div id="body-content">
<div class="col-md-8 col-md-offset-2">
    <h1 id="content-heading">CPP SFINAE</h1>
</div>
<div id="niu2-left-container" class="col-md-6 col-md-offset-2 with-right-border">
    <div id="niu2-main-content">
        <p>SFINAE是C++里面的术语，确切名称叫做<code>Substitution failure is not an error</code> 。其实准确的来说还应该加入一个前缀<code>template</code>，其意义从其名称中就可以看出来：模板参数替代失败并非错误。SFINAE是一种编程技巧，利用了函数模板的重载决议(<code>overload resolution</code>)：当有多个同名模板函数可用时，单独的一个模板函数匹配失败并不意味着错误，只有当所有的匹配都失败的时候才是错误。只用文字描述的话，SFINAE不是很好理解，后面将给出具体事例及代码说明。</p>
<h1 id="aaf1c5">利用SFINAE实现内部类型判断</h1>
<p>下面给出利用SFINAE实现编译期内部类型判断的最简单的例子：</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">Test</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="kt">int</span> <span class="n">foo</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">foo</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;with T::foo&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// Definition #1</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;without T::foo&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>                <span class="c1">// Definition #2</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">f</span><span class="o">&lt;</span><span class="n">Test</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// Call #1. cout with T::foo</span>
    <span class="n">f</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>  <span class="c1">// Call #2. cout without T::foo Without error (even though there is no int::foo) thanks to SFINAE.</span>
<span class="p">}</span>
</pre></div>


<p>模板函数<code>f</code>有两个定义，第一个定义要求类型<code>struct Test</code>中定义了一个类型<code>foo</code>，第二个定义则对参数类型不做任何要求。所以当我们显示实例化<code>f&lt;Test&gt;</code>时，第一个定义匹配成功，调用第一个定义；而当显示实例化<code>f&lt;int&gt;</code>时，第一个定义匹配失败，尝试匹配第二个定义，并最终调用第二个定义。事实上，这两个定义的先后顺序并不影响最后的结果。上面的代码的主要功能就是通过SFINAE，判断模板参数的类型是否内部定义了一个<code>foo</code>类型。类似的，我们可以通过下面的代码来判断传入参数类型是否内部定义了<code>foobar</code>类型：</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">has_typedef_foobar</span> 
<span class="p">{</span>
    <span class="c1">// Types &quot;yes&quot; and &quot;no&quot; are guaranteed to have different sizes,</span>
    <span class="c1">// specifically sizeof(yes) == 1 and sizeof(no) == 2.</span>
    <span class="k">typedef</span> <span class="kt">char</span> <span class="n">yes</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">typedef</span> <span class="kt">char</span> <span class="n">no</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="n">yes</span><span class="o">&amp;</span> <span class="n">test</span><span class="p">(</span><span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">foobar</span><span class="o">*</span><span class="p">);</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="n">no</span><span class="o">&amp;</span> <span class="n">test</span><span class="p">(...);</span>
    <span class="c1">// If the &quot;sizeof&quot; of the result of calling test&lt;T&gt;(0) would be equal to sizeof(yes),</span>
    <span class="c1">// the first overload worked and T has a nested type named foobar.</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">value</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">test</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">yes</span><span class="p">);</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">foo</span>
<span class="p">{</span>    
    <span class="k">typedef</span> <span class="kt">float</span> <span class="n">foobar</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">has_typedef_foobar</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">has_typedef_foobar</span><span class="o">&lt;</span><span class="n">foo</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>如果类型<code>T</code>内部定义了类型<code>foobar</code>，则<code>has_typedef_foobar&lt;int&gt;::value</code>的值为<code>true</code>，否则为<code>false</code>。这里之所以将<code>no</code>定义为10个<code>char</code>，是因为在不同的平台上可能有不同的内存对齐要求。如果定义为3个的话，遇到4字节对齐的硬件结构会导致<code>sizeof(yes)</code>与<code>sizeof(no)</code>都返回4，在8字节对齐的机器上也是同理。目前来说还没见过大于8字节的对齐（当然自己犯贱#pragma_pack(16)的除外)，所以定义为10基本可以保证这两个类型返回的字节大小是不一样的。</p>
<h1 id="1b222c">用SFINAE实现类内部函数判断</h1>
<p>SFINAE的功能不仅仅是能编译期确定类型内部是否定义了新类型，而且还能在编译期确定实参类型内部是否定义了某个成员函数，样例代码如下（注意 VS编译不过。。。）：</p>
<div class="codehilite"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"></span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">has_f</span> <span class="p">:</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">has_f</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span>
    <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">().</span><span class="n">f</span><span class="p">(),</span> <span class="kt">void</span><span class="p">())</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">has_f</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">A</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">struct</span> <span class="n">B</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">();</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">C</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">template</span> <span class="k">class</span> <span class="nc">A</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// compiles</span>
<span class="k">template</span> <span class="k">class</span> <span class="nc">A</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// error: no type named ‘type’ </span>
                     <span class="c1">// in ‘struct std::enable_if&lt;false, void&gt;’</span>
</pre></div>


<p>首先来理解一下<code>std::declval</code>，这是在C++11中引入的一个函数模板，具体定义如下:</p>
<div class="codehilite"><pre><span></span><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">T</span> <span class="o">&gt;</span>
<span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">add_rvalue_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">declval</span><span class="p">();</span>
</pre></div>


<p>其具体作用就是返回任意类型<code>T</code>的一个右值引用，即使该类型不存在构造函数。但是该右值引用不可以用来求值，只能用在不可求值环境，只能用来推导类型，如其成员变量和成员函数的类型。而<code>decltype(std::declval&lt;T&gt;().f(), void())</code>的作用就是强制进行<code>std::declval&lt;T&gt;().f()</code>的类型推导，并最后返回<code>void</code>类型。</p>
<p><code>std::false_type,std::true_type</code>内部都有一个成员<code>value</code>，类似于我们上个事例代码中的<code>has_typedef_foobar&lt;int&gt;::value</code>，值分别为<code>false,true</code>。而<code>std::enable_if</code>是一个类模板，并显示特化为了<code>true,false</code>两种类型。<code>std::enable_if&lt;true&gt;</code>内部定义了一个新类型<code>type</code>，而<code>std::enable_if&lt;false&gt;</code>内部则没有定义这个类型。<code>std::enable_if</code>具体定义代码如下所示：</p>
<div class="codehilite"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="n">B</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span> <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">enable_if</span> <span class="p">{};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">enable_if</span><span class="o">&lt;</span><span class="nb">true</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">typedef</span> <span class="n">T</span> <span class="n">type</span><span class="p">;</span> <span class="p">};</span>
</pre></div>


<p>在这一系列的模板特化和实例化之下，语句<code>A&lt;B&gt;</code>能够编译通过，而语句<code>A(C)</code>则编译报错。</p>
<p>当前我们只做到了判断没有参数也没有返回值的函数的存在性，事实上还可以判断具体签名的成员函数的存在性。假设我们要判断某个类内部是否定义了<code>size_t used_memory() const</code>这个函数，该需求可以通过下面的代码来实现：</p>
<div class="codehilite"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">HasUsedMemoryMethod</span>
<span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="p">,</span> <span class="kt">size_t</span> <span class="p">(</span><span class="n">U</span><span class="o">::*</span><span class="p">)()</span> <span class="k">const</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">SFINAE</span> <span class="p">{};</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span> <span class="k">static</span> <span class="kt">char</span> <span class="n">Test</span><span class="p">(</span><span class="n">SFINAE</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">U</span><span class="o">::</span><span class="n">used_memory</span><span class="o">&gt;*</span><span class="p">);</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">Test</span><span class="p">(...);</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">Has</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Test</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">TMap</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">ReportMemUsage</span><span class="p">(</span><span class="k">const</span> <span class="n">TMap</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">)</span>
<span class="p">{</span>
        <span class="c1">// We may call used_memory() on m here.</span>
<span class="p">}</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">TMap</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">ReportMemUsage</span><span class="p">(</span><span class="k">const</span> <span class="n">TMap</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">TMap</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">ReportMemUsage</span><span class="p">(</span><span class="k">const</span> <span class="n">TMap</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ReportMemUsage</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">integral_constant</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="n">HasUsedMemoryMethod</span><span class="o">&lt;</span><span class="n">TMap</span><span class="o">&gt;::</span><span class="n">Has</span><span class="o">&gt;</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>


<p>这里用到了成员指针<code>::*</code>这个类型，因为普通指针无法指向成员函数（多了一个this指针的参数)，具体细节读者自行百度吧。由于个人能力所限，还无法得到有参数的成员函数的存在性判断，但是现在最起码得到了有返回值类型的成员函数的存在性判断，先偷着乐一会吧。</p>
<h1 id="2eabc6">利用SFINAE实现指针类型判断</h1>
<p>对于一个变量，我们还可以利用SFINAE来判断该变量是否是指针类型的：包括普通变量指针，成员变量指针，成员函数指针，函数指针这四种指针类型。<code>type_traits</code>中的<code>is_pointer</code>元函数可以做到这一功能，代码如下：</p>
<div class="codehilite"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">is_pointer</span>
<span class="p">{</span>
  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
  <span class="k">static</span> <span class="kt">char</span> <span class="n">is_ptr</span><span class="p">(</span><span class="n">U</span> <span class="o">*</span><span class="p">);</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">X</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Y</span><span class="o">&gt;</span>
  <span class="k">static</span> <span class="kt">char</span> <span class="n">is_ptr</span><span class="p">(</span><span class="n">Y</span> <span class="n">X</span><span class="o">::*</span><span class="p">);</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span>
  <span class="k">static</span> <span class="kt">char</span> <span class="n">is_ptr</span><span class="p">(</span><span class="n">U</span> <span class="p">(</span><span class="o">*</span><span class="p">)());</span>

  <span class="k">static</span> <span class="kt">double</span> <span class="nf">is_ptr</span><span class="p">(...);</span>

  <span class="k">static</span> <span class="n">T</span> <span class="n">t</span><span class="p">;</span>
  <span class="k">enum</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">is_ptr</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="p">};</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">bar</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">typedef</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">IntPtr</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="kt">int</span> <span class="n">Foo</span><span class="o">::*</span> <span class="n">FooMemberPtr</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">FuncPtr</span><span class="p">)();</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">is_pointer</span><span class="o">&lt;</span><span class="n">IntPtr</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">);</span>         <span class="c1">// prints 1</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">is_pointer</span><span class="o">&lt;</span><span class="n">FooMemberPtr</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">);</span>  <span class="c1">// prints 1</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">is_pointer</span><span class="o">&lt;</span><span class="n">FuncPtr</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">);</span>        <span class="c1">// prints 1</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>上面的代码通过显示特化了所有的指针类型并让函数模板返回值为<code>char</code>，同时让非指针类型的函数模板特化为返回<code>double</code>。这两个返回类型在<code>sizeof</code>运算符下返回的值是不同的，所以我们可以把指针类型与非指针类型区分出来。</p>
<h1 id="73a8d0">利用SFINAE实现类继承判断</h1>
<p>除了上面提到的类内部类型和类函数存在性判断之外，我们还可以判断某个类<code>A</code>是否是从<code>B</code>继承下来的。事例代码如下：</p>
<div class="codehilite"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">A</span><span class="p">,</span> <span class="k">class</span> <span class="nc">B</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">IsDerivedFrom</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
  <span class="k">class</span> <span class="nc">Yes</span> <span class="p">{</span> <span class="kt">char</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="p">};</span>
  <span class="k">class</span> <span class="nc">No</span> <span class="p">{</span> <span class="kt">char</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="p">};</span>

  <span class="k">static</span> <span class="n">Yes</span> <span class="nf">Test</span><span class="p">(</span> <span class="n">B</span><span class="o">*</span> <span class="p">);</span> <span class="c1">// undefined</span>
  <span class="k">static</span> <span class="n">No</span> <span class="nf">Test</span><span class="p">(</span> <span class="p">...</span> <span class="p">);</span> <span class="c1">// undefined</span>

<span class="k">public</span><span class="o">:</span>
  <span class="k">enum</span> <span class="p">{</span> <span class="n">Is</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Test</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">A</span><span class="o">*&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Yes</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span> <span class="p">};</span>
<span class="p">};</span>
</pre></div>


<p><code>static_cast&lt;D*&gt;(0)</code>这一句的作用是将0转换为一个<code>A</code>类型的指针。由于<code>Test（B*)</code>接受的是<code>B*</code>类型的参数，所以会默认进行<code>A*</code>到<code>B*</code>的转换，如果可以转换，则匹配第一个模板。如果<code>A*</code>没有到<code>B*</code>的转换，则<code>Test(B*)</code>这个模板匹配失败，并最终匹配了第二个模板。剩下的工作就好理解了，这里就不再赘述。需要注意的是，这里并不是去做真正的类型转换，而且，只有<code>enum</code>和<code>const static</code>类型的值才能在编译期动态赋值。</p>
<p>上面的代码只能实现可转换的判断，如果<code>A</code>与<code>B</code>的类型相同的时候，会返回1。如果我们要判断的是<code>A</code>是否是<code>B</code>的继承类型的时候，该结果并不令人满意。所以我们还需要增加一个代码片段，来排除相同类型的情况。代码示例如下:</p>
<div class="codehilite"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">IsDerivedFrom</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">enum</span> <span class="p">{</span> <span class="n">Is</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">};</span>
<span class="p">};</span>
</pre></div>


<p>上面的两个代码合并起来，就能完美的判断是否是继承类型的问题。</p>
<h1 id="c0178f">利用SFINAE实现纯虚类判断</h1>
<p>我们也可以利用SFINAE来判断一个类是不是纯虚类。此时我们使用到了纯虚类的一个性质：不能声明纯虚类的变量。所以对于纯虚类<code>A</code>来说,<code>A(*)[1]</code>是无法实例化的。因为这个类型是一个指向<code>A</code>类型的数组的指针（注意不是<code>A</code>指针的数组），而数组声明要求类型不能为reference,void,function,abstract。所以我们可以用以下的代码测试类型是不是纯虚类：</p>
<div class="codehilite"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">IsAbstract</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="kt">char</span> <span class="n">SmallType</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="kt">int</span> <span class="n">LargeType</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">char</span> <span class="n">Test</span><span class="p">(</span><span class="n">U</span><span class="p">(</span><span class="o">*</span><span class="p">)[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">Test</span><span class="p">(...);</span>

    <span class="k">const</span> <span class="k">static</span> <span class="kt">bool</span> <span class="n">Result</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Test</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nb">NULL</span><span class="p">))</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">LargeType</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>


<p>但是，正如前文所说，reference,void,function都会导致类型被判断为纯虚类，所以应该再对这几种类型做特化，这里就不写了。</p>
<h1 id="c84163">利用SFINAE实现类模板特化</h1>
<p>虽然之前的两个例子让我们感到了模板与SFINAE的强大与恐怖之处，但是得到了判断结果又能怎么样呢，好像都没有多大实际作用的样子。这里，我们给出一个有实际作用的例子：利用SFINAE实现类模板特化。</p>
<p>假设我们当前要实现一个容器<code>C&lt;T&gt;</code>，用来存储<code>T</code>类型的值。一个最简单的实现如下：</p>
<div class="codehilite"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">C</span> 
<span class="p">{</span>
  <span class="k">private</span><span class="o">:</span>
    <span class="n">T</span> <span class="n">t</span><span class="p">;</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">C</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>
    <span class="n">C</span><span class="p">(</span><span class="n">C</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span>
  <span class="c1">// other stuff</span>
<span class="p">};</span>
</pre></div>


<p>由于有些类型的<code>T</code>是不可拷贝的，例如<code>std::mutex,std::unique_ptr</code>。但是对于这些类型的<code>T</code>，<code>is_copy_constructible&lt;C&lt;T&gt;\,&gt;::value</code>仍然是<code>true</code>的。为了防止这些类型的拷贝构造，我们要把<code>C&lt;T&gt;</code>的拷贝构造函数禁用。代码如下：</p>
<div class="codehilite"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="n">copyable</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">copyable_characteristic</span> <span class="p">{</span> <span class="p">};</span>

<span class="k">template</span><span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="n">copyable_characteristic</span><span class="o">&lt;</span><span class="nb">false</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">copyable_characteristic</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="n">copyable_characteristic</span><span class="p">(</span><span class="k">const</span> <span class="n">copyable_characteristic</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">C</span>
<span class="o">:</span> <span class="n">copyable_characteristic</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_copy_constructible</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;</span>
<span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">C</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="n">C</span><span class="p">(</span><span class="n">C</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">);</span>
  <span class="c1">// other stuff</span>
<span class="p">};</span>
</pre></div>


<p>因为默认的拷贝构造函数会首先调用父类的拷贝构造函数。当父类的拷贝构造函数为<code>delete</code>的时候，子类的拷贝构造函数也就相当于声明为了<code>delete</code>，这个解决方案简直完美。</p>
<h1 id="bb09be">利用SFINAE实现函数模板特化</h1>
<p>模板参数既能决定类的行为，同时也能决定函数的行为。如下例:</p>
<div class="codehilite"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">A</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">sum</span><span class="p">()</span> <span class="k">const</span> 
    <span class="p">{</span> <span class="k">return</span> <span class="n">_sum</span><span class="o">&lt;</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">();</span> <span class="p">}</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">otherN</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">otherN</span> <span class="o">&gt;=</span> <span class="n">N</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
    <span class="k">explicit</span> <span class="n">A</span><span class="p">(</span><span class="n">A</span><span class="o">&lt;</span><span class="n">otherN</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">)</span>
    <span class="p">{</span>

    <span class="p">}</span>
    <span class="n">A</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">_data</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">I</span><span class="o">&gt;</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span> <span class="n">I</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">_sum</span><span class="p">()</span> <span class="k">const</span> 
    <span class="p">{</span> <span class="k">return</span> <span class="n">_sum</span><span class="o">&lt;</span><span class="n">I</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">+</span> <span class="n">_data</span><span class="p">[</span><span class="n">I</span><span class="p">];</span> <span class="p">}</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">I</span><span class="o">&gt;</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;!</span><span class="n">I</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">_sum</span><span class="p">()</span> <span class="k">const</span> 
    <span class="p">{</span> <span class="k">return</span> <span class="n">_data</span><span class="p">[</span><span class="n">I</span><span class="p">];</span> <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">A</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">a4</span><span class="p">;</span>
    <span class="n">A</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">&gt;</span> <span class="n">a5</span><span class="p">;</span>
    <span class="n">A</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">a3</span><span class="p">(</span><span class="n">a5</span><span class="p">);</span>
    <span class="n">A</span><span class="o">&lt;</span><span class="mi">7</span><span class="o">&gt;</span> <span class="n">a7</span><span class="p">(</span><span class="n">a3</span><span class="p">);</span>   <span class="c1">//error </span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>上面的代码中，<code>_sum&lt;N&gt;</code>是一个模板元函数，<code>A&lt;N&gt;</code>是一个封装了N个整数的结构体。<code>_sum&lt;N&gt;</code>非常巧妙的利用了<code>int</code>与<code>bool</code>的隐式类型转换，以及<code>std::enable_if</code>的特性，还有类型别名机制，实现了递归求前N个元素和的壮举。同时，<code>A(A&lt;otherN&gt; const)</code>也通过利用<code>std::enable_if</code>实现了把拷贝构造中长度控制的奇迹。看到这两个简短而又不知所云的代码是不是感觉有点怕！当SFINAE和TYPETRIATS一起结合的时候，<code>the real terror awaits you</code>。</p>
<h1 id="ea6f3b">参考链接</h1>
<ul>
<li>
<p>wikipedia上关于SFINAE的页面 <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error</a></p>
</li>
<li>
<p>stackoverflow上关于禁止某些类型的拷贝构造函数的问题链接<a href="http://stackoverflow.com/questions/27073082/conditionally-disabling-a-copy-constructor">http://stackoverflow.com/questions/27073082/conditionally-disabling-a-copy-constructor</a></p>
</li>
<li>
<p>stackoverflow上关于判断类内部是否存在给定签名的成员函数的问题链接<a href="http://stackoverflow.com/questions/87372/check-if-a-class-has-a-member-function-of-a-given-signature">http://stackoverflow.com/questions/87372/check-if-a-class-has-a-member-function-of-a-given-signature</a></p>
</li>
<li>
<p>关于C++11中SFINAE使用的ppt总结<a href="http://accu.org/content/conf2013/Jonathan_Wakely_sfinae.pdf">http://accu.org/content/conf2013/Jonathan_Wakely_sfinae.pdf</a></p>
</li>
<li>
<p>cplusplus上关于enable_if的参考文档<a href="http://www.cplusplus.com/reference/type_traits/enable_if/">http://www.cplusplus.com/reference/type_traits/enable_if/</a></p>
</li>
<li>
<p>gotw上关于判断两个类是否是继承关系的讨论<a href="http://www.gotw.ca/gotw/071.htm">http://www.gotw.ca/gotw/071.htm</a></p>
</li>
</ul>
    </div>
    <div id="content-comments">
</div>

</div>
<div class="niu2-right-container col-md-2">
    <div id="niu2-sidebar-meta" class="niu2-sidebar">
        <div class="niu2-sidebar-label"><i class="icon-calendar"></i>Published:</div>
        <div class="niu2-sidebar-value">2015-04-28 20:05</div>
        <div class="niu2-sidebar-label"><i class="icon-open-folder"></i>Category:</div>
        <div class="niu2-sidebar-value"><a href="./category/cpp.html">CPP</a></div>
        <div class="niu2-sidebar-label"><i class="icon-tag"></i>Tag:</div>
 
            <div class="niu2-sidebar-inter-value niu2-sidebar-tag"><a href="./tag/cpp.html">CPP</a><sup>15</sup></div>
            <div class="niu2-sidebar-inter-value niu2-sidebar-tag"><a href="./tag/template.html">Template</a><sup>1</sup></div>
    </div>

    <div id="niu2-sidebar-toc" class="niu2-sidebar" data-status="closed">
        <div class="niu2-sidebar-label">
            <i id="niu2-sidebar-toc-ctrl" class="icon-open-tocs"></i>TOC
        </div>
        <ol id="niu2-sidebar-toc-list">
            <li><a href="#content-heading">CPP SFINAE</a></li>
            <li><a href='#aaf1c5'>利用SFINAE实现内部类型判断</a></li><li><a href='#1b222c'>用SFINAE实现类内部函数判断</a></li><li><a href='#2eabc6'>利用SFINAE实现指针类型判断</a></li><li><a href='#73a8d0'>利用SFINAE实现类继承判断</a></li><li><a href='#c0178f'>利用SFINAE实现纯虚类判断</a></li><li><a href='#c84163'>利用SFINAE实现类模板特化</a></li><li><a href='#bb09be'>利用SFINAE实现函数模板特化</a></li><li><a href='#ea6f3b'>参考链接</a></li>
        </ol>
    </div>
</div>    </div>

    <div class="niu2-footer">
        <div id="body-footer" class="col-md-6 col-md-offset-2">
<hr/>
<p>
    Powered by <a href="https://github.com/getpelican/pelican">Pelican</a>, 
    <a href="https://github.com/mawenbao/niu-x2-sidebar">theme</a> built with <a href="http://getbootstrap.com">Bootstrap3</a>
    by <a href="http://blog.atime.me">Ma Wenbao</a>, icons by 
    <a href="http://fortawesome.github.io/Font-Awesome">Font Awesome</a>.
</p>
<p>
    ©
            2014-2017
    <a class="niu2-footer-link" href=".">Huiliang Huang</a>
</p>
<p class="niu2-icons">
</p>        </div>
    </div>
    
    <div id="niu2-pygments" data-theme="github"></div>

    <script type="text/javascript" src="./theme/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="./theme/js/niu2.min.js"></script>
    <script type="text/javascript" src="./theme/js/bootstrap.min.js"></script>
    <script type="text/javascript">onContentLoaded();</script>
  </body>
</html>
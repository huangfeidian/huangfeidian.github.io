<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Under the Hood : POGS - Spirits Away</title>
    <link rel="shortcut icon" type="image/x-icon" href="\favicon.ico">
    <link rel="stylesheet" href="http://spiritsaway.info/theme/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="http://spiritsaway.info/theme/font-icons/style.min.css" type="text/css" />
    <link rel="stylesheet" href="http://spiritsaway.info/theme/css/niu2.min.css" type="text/css" />

    <link rel="canonical" href="http://spiritsaway.info/code/under-the-hood-pogs.html" />
    
    <script type="text/javascript">window.onload=function(){};</script>
    <!--[if lt IE 9]>
        <script src="http://spiritsaway.info/theme/js/html5shiv.js"></script>
        <script src="http://spiritsaway.info/theme/js/respond.min.js"></script>
    <![endif]-->
  </head>
  <body> 
    <div id="body-header">
<div class="navbar navbar-inverse navbar-fixed-top">
<div class="col-md-12">
    <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="http://spiritsaway.info">
            <i class="icon-home"></i>Spirits Away
        </a>
    </div>
    <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
        <ul class="nav navbar-nav">
            <li><a href="/about.html" title="about">
                <i class="fa-anchor"></i>关于</a>
            </li>
            <li><a href="/archives.html" title="archives">
                <i class="fa-archive"></i>存档</a>
            </li>
            <li><a href="/tag/" title="tags">
                <i class="fa-tag"></i>标签</a>
            </li>
        <!-- category dropdown list -->
        <li class="dropdown">
           <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                <i class="icon-folder-open"></i>分类<b class="caret"></b>
           </a>
           <ul class="dropdown-menu">
               <li><a href="http://spiritsaway.info/ai/index.html">
                   <i class="icon-folder-close"></i>AI
                      (3)</a></li>
               <li><a href="http://spiritsaway.info/algorithm/index.html">
                   <i class="icon-folder-close"></i>Algorithm
                      (3)</a></li>
               <li><a href="http://spiritsaway.info/code/index.html">
                   <i class="icon-folder-close"></i>Code
                      (3)</a></li>
               <li><a href="http://spiritsaway.info/cpp/index.html">
                   <i class="icon-folder-close"></i>CPP
                      (6)</a></li>
               <li><a href="http://spiritsaway.info/math/index.html">
                   <i class="icon-folder-close"></i>Math
                      (4)</a></li>
           </ul>
        </li>
        <!--  self defined dropdown list -->
        </ul>
        
        <!-- right nav bar -->
        <ul class="nav navbar-nav navbar-right">
        <!-- google custom search -->
       </ul>
    </nav>
</div>
</div>    </div>
    
    <div id="body-content">
<div class="col-md-8 col-md-offset-2">
    <h1 id="content-heading">Under the Hood : POGS</h1>
</div>
<div id="niu2-left-container" class="col-md-6 col-md-offset-2 with-right-border">
    <div id="niu2-main-content">
        <h1 id="832cb9">POGS Introduction</h1>
<p>Proximal Graph Solver (POGS) is a solver for convex optimization problems in graph form using Alternating Direction Method of Multipliers (ADMM).  The graph form problem can be expressed as</p>
<div class="math">\begin{equation}\begin{aligned}&amp; minimize \quad &amp; f(y)+g(x)\\&amp; subject to \quad &amp; y=Ax\\\end{aligned}\end{equation}</div>
<p><br />
where <span class="math">\( f\)</span>  and <span class="math">\( g\)</span>  are convex and can take on the values  <span class="math">\(R \cup {∞}\)</span> . The solver requires that the proximal operators of <span class="math">\( f\)</span>  and  <span class="math">\(g\)</span>  are known and that  $f $ and  $g $ are separable, meaning that they can be written as</p>
<div class="math">\begin{equation}\begin{aligned}f(y)&amp; = \sum_{i=1}^m f_i(y_i)\\g(x) &amp; = \sum_{i=1}^n g_i(x_i)\end{aligned}\end{equation}</div>
<p><br />
The following functions are currently supported</p>
<p><img alt="支持函数列表" src="http://spiritsaway.info/code/image/POGS/functions.png" /></p>
<p>where  <span class="math">\(I(.)\)</span>  is the indicator function, taking on the value 0 if the condition is satisfied and infinity otherwise.</p>
<h1 id="bb96e3">util.h</h1>
<p>The content of <code>util.h</code> is mainly about some <code>ASSERT</code> macro,like <code>LEQ,LT,NEQ,GT,GEQ,EQ_EPS</code>. Beside the common c++ macro, some CUDA specific macro is here as well:</p>
<div class="codehilite"><pre><span class="cp">#ifdef __CUDACC__</span>
<span class="cp">#define CUDA_CHECK_ERR() \</span>
<span class="cp">  do { \</span>
<span class="cp">    cudaError_t err = cudaGetLastError(); \</span>
<span class="cp">    if (err != cudaSuccess) { \</span>
<span class="cp">      std::cout &lt;&lt; __FILE__ &lt;&lt; &quot;:&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;:&quot; \</span>
<span class="cp">                &lt;&lt; __BLUE &lt;&lt; __func__ &lt;&lt; &quot;\n&quot; \</span>
<span class="cp">                &lt;&lt; __RED &lt;&lt; &quot;ERROR_CUDA: &quot; &lt;&lt; cudaGetErrorString(err) \</span>
<span class="cp">                &lt;&lt; __RESET &lt;&lt; std::endl; \</span>
<span class="cp">      exit(EXIT_FAILURE); \</span>
<span class="cp">    } \</span>
<span class="cp">  } while (0)</span>
<span class="cp">#endif</span>
</pre></div>


<h1 id="adc0c1">prox_lib.h</h1>
<p>In this file , all kinds of loss function are defined. Currently pogs support 16 functions.</p>
<div class="codehilite"><pre><span class="k">enum</span> <span class="n">Function</span>
<span class="p">{</span>
    <span class="n">kAbs</span><span class="p">,</span>       <span class="c1">// f(x) = |x|</span>
    <span class="n">kExp</span><span class="p">,</span>       <span class="c1">// f(x) = e^x</span>
    <span class="n">kHuber</span><span class="p">,</span>     <span class="c1">// f(x) = huber(x)</span>
    <span class="n">kIdentity</span><span class="p">,</span>  <span class="c1">// f(x) = x</span>
    <span class="n">kIndBox01</span><span class="p">,</span>  <span class="c1">// f(x) = I(0 &lt;= x &lt;= 1)</span>
    <span class="n">kIndEq0</span><span class="p">,</span>    <span class="c1">// f(x) = I(x = 0)</span>
    <span class="n">kIndGe0</span><span class="p">,</span>    <span class="c1">// f(x) = I(x &gt;= 0)</span>
    <span class="n">kIndLe0</span><span class="p">,</span>    <span class="c1">// f(x) = I(x &lt;= 0)</span>
    <span class="n">kLogistic</span><span class="p">,</span>  <span class="c1">// f(x) = log(1 + e^x)</span>
    <span class="n">kMaxNeg0</span><span class="p">,</span>   <span class="c1">// f(x) = max(0, -x)</span>
    <span class="n">kMaxPos0</span><span class="p">,</span>   <span class="c1">// f(x) = max(0, x)</span>
    <span class="n">kNegEntr</span><span class="p">,</span>   <span class="c1">// f(x) = x log(x)</span>
    <span class="n">kNegLog</span><span class="p">,</span>    <span class="c1">// f(x) = -log(x)</span>
    <span class="n">kRecipr</span><span class="p">,</span>    <span class="c1">// f(x) = 1/x</span>
    <span class="n">kSquare</span><span class="p">,</span>    <span class="c1">// f(x) = (1/2) x^2</span>
    <span class="n">kZero</span>
<span class="p">};</span>
</pre></div>


<p>If we want to add our own loss function, we should extend this enum definition.</p>
<p>The optimization functions in pogs are in this form</p>
<div class="math">$$c * f(a * x - b) + d * x+e*x^2$$</div>
<p>. The enum stands for the<span class="math">\(f\)</span>. Parameters <span class="math">\(a,c,e\)</span> default to 1, while b and d default to 0. This optimization function is warpped in a <code>FunctionObj</code></p>
<div class="codehilite"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">FunctionObj</span>
<span class="p">{</span>
    <span class="n">Function</span> <span class="n">h</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">;</span>

    <span class="n">FunctionObj</span><span class="p">(</span><span class="n">Function</span> <span class="n">h</span><span class="p">,</span> <span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">,</span> <span class="n">T</span> <span class="n">c</span><span class="p">,</span> <span class="n">T</span> <span class="n">d</span><span class="p">,</span> <span class="n">T</span> <span class="n">e</span><span class="p">)</span> <span class="o">:</span>
            <span class="n">h</span><span class="p">(</span><span class="n">h</span><span class="p">),</span> <span class="n">a</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">c</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">d</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">e</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">CheckConsts</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">CheckConsts</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">Printf</span><span class="p">(</span><span class="s">&quot;WARNING c &lt; 0. Function not convex. Using c = 0&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">Printf</span><span class="p">(</span><span class="s">&quot;WARNING e &lt; 0. Function not convex. Using e = 0&quot;</span><span class="p">);</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>Then here comes some simple warpper of math functions,like</p>
<div class="codehilite"><pre><span class="n">__DEVICE__</span> <span class="kr">inline</span> <span class="kt">double</span> <span class="nf">Abs</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">fabs</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">__DEVICE__</span> <span class="kr">inline</span> <span class="kt">float</span> <span class="nf">Abs</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">fabsf</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>Apart from the common math functions, there are some interesting math functions as well. Like the implementation of <a href="http://keithbriggs.info/software/LambertW.c">Lambert function</a> and <a href="http://math.stackexchange.com/questions/60376">root of cubic function</a>.The lambert w function is the inverse function of</p>
<div class="math">\begin{equation}f(x)=xe^x\end{equation}</div>
<p><br />
 These two functions are used later.</p>
<p>Then all math functions' evaluation is warpped into a <code>FuncEval</code></p>
<div class="codehilite"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">__DEVICE__</span> <span class="kr">inline</span> <span class="n">T</span> <span class="n">FuncEval</span><span class="p">(</span><span class="k">const</span> <span class="n">FunctionObj</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">f_obj</span><span class="p">,</span> <span class="n">T</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">f_obj</span><span class="p">.</span><span class="n">d</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">ex</span> <span class="o">=</span> <span class="n">f_obj</span><span class="p">.</span><span class="n">e</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">f_obj</span><span class="p">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">f_obj</span><span class="p">.</span><span class="n">b</span><span class="p">;</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">f_obj</span><span class="p">.</span><span class="n">h</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="nl">kAbs</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">FuncAbs</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">FuncZero</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">f_obj</span><span class="p">.</span><span class="n">c</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dx</span> <span class="o">+</span> <span class="n">ex</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>These warppers are necessary because we want to run on CPU/GPU, while these two platform has different implementation for these function. We don't want to mess our logicflow code with some <code>ifdef endif</code> guards. So we just warp these function and leave the macro guards to implementation files.</p>
<p>The warppers are used by <code>proximal operator</code> definitions. The socalled <code>proximal operator</code> has such form </p>
<div class="math">$$Prox\{c * f(a * x - b) + d * x + e * x^2\}$$</div>
<p> where <span class="math">\(a,b,c,d,e\)</span> are parameters. For every function enum, there is a corresponding proximal operator function whoes signature is the concatenation of <code>Prox</code> prefix and function enum name. The rational behind  these 16 functions is that we can solve these functions analytically. These proximal operator is the result function of corresponding optimization problems.</p>
<p>The <code>cubic root</code> is used in <code>reciprocal</code> and the <code>lambert</code> is used in <code>expotional</code>. The only exception is <code>logistic</code> , it's implemented in  iteration :</p>
<div class="codehilite"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">__DEVICE__</span> <span class="kr">inline</span> <span class="n">T</span> <span class="n">ProxLogistic</span><span class="p">(</span><span class="n">T</span> <span class="n">v</span><span class="p">,</span> <span class="n">T</span> <span class="n">rho</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Initial guess based on piecewise approximation.</span>
    <span class="n">T</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mf">2.5</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">2.5</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">rho</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">v</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">rho</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">rho</span> <span class="o">*</span> <span class="n">v</span> <span class="o">-</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="p">);</span>

    <span class="c1">// Newton iteration.</span>
    <span class="n">T</span> <span class="n">l</span> <span class="o">=</span> <span class="n">v</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">rho</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">T</span> <span class="n">inv_ex</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">Exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">));</span>
        <span class="n">T</span> <span class="n">f</span> <span class="o">=</span> <span class="n">inv_ex</span> <span class="o">+</span> <span class="n">rho</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">v</span><span class="p">);</span>
        <span class="n">T</span> <span class="n">g</span> <span class="o">=</span> <span class="n">inv_ex</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">inv_ex</span><span class="p">)</span> <span class="o">+</span> <span class="n">rho</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">f</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">f</span> <span class="o">/</span> <span class="n">g</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">Min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">Max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Guarded method if not converged.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">u</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">Tol</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">T</span> <span class="n">g_rho</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">rho</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">Exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">)))</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">v</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">g_rho</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">Max</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">g_rho</span><span class="p">);</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">Min</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">g_rho</span><span class="p">);</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">+</span> <span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Finally, all optimiztion process is abtracted to one <code>ProxEval</code>,this function is a variation of oringinal proximal operator, with additional penalty parameter. So current problem can be constructed as such:</p>
<div class="math">\begin{equation}\label{eq:penalty}minimize\quad c*f(ax-b)+dx+ex^2+\rho (x-v)^2\end{equation}</div>
<p><br />
We can tranform this problem to the proximal operator that we are familar with. Letting<span class="math">\(y=ax+b\)</span>, the problem with penalty  can be transformed to</p>
<div class="math">\begin{equation}c*f(y)+d*\frac{y+b}{a}+e(\frac{y+b}{a})^2+\rho(\frac{y+b}{a}-v)^2\end{equation}</div>
<p><br />
We take derivation of <span class="math">\(y\)</span> except for the term <span class="math">\(c*f(y)\)</span> , and set it to 0. Then we get</p>
<div class="math">\begin{equation}\begin{aligned}&amp;\frac{d}{a}+\frac{2e}{a^2}(y+b)+\frac{2\rho}{a^2}*(y+b-av)=0\\\Rightarrow &amp;y=a*(v*\rho-d)/(e+\rho)-b\end{aligned}\end{equation}</div>
<p><br />
So the penalty proximal operator problem can be refractored to another proximal operator problem</p>
<div class="math">\begin{equation}c*(f(y)+\frac{e+\rho}{ca^2}(y-a*(v*\rho-d)/(e+\rho)-b)+k)\end{equation}</div>
<p><br />
where the <span class="math">\(k\)</span> is a const value, so we can neglect it. The cpp code implemention is just what we have analyzed.</p>
<div class="codehilite"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">__DEVICE__</span> <span class="kr">inline</span> <span class="n">T</span> <span class="n">ProxEval</span><span class="p">(</span><span class="k">const</span> <span class="n">FunctionObj</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">f_obj</span><span class="p">,</span> <span class="n">T</span> <span class="n">v</span><span class="p">,</span> <span class="n">T</span> <span class="n">rho</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">T</span> <span class="n">a</span> <span class="o">=</span> <span class="n">f_obj</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">f_obj</span><span class="p">.</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">f_obj</span><span class="p">.</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">f_obj</span><span class="p">.</span><span class="n">d</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">f_obj</span><span class="p">.</span><span class="n">e</span><span class="p">;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span> <span class="o">*</span> <span class="n">rho</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">e</span> <span class="o">+</span> <span class="n">rho</span><span class="p">)</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">rho</span> <span class="o">=</span> <span class="p">(</span><span class="n">e</span> <span class="o">+</span> <span class="n">rho</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span><span class="p">);</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">f_obj</span><span class="p">.</span><span class="n">h</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="c1">//here come all cases, I just list one for example</span>
    <span class="k">case</span> <span class="nl">kSquare</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">ProxSquare</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">rho</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">kZero</span><span class="p">:</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">ProxZero</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">rho</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">v</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>As well as the derivation of these functions,in pogs they are called subgradient. The derivation function signature is concatenation of ProjSubgrad and function enum name. The common evaluation warpper is the same as <code>FuncEval</code></p>
<div class="codehilite"><pre><span class="n">emplate</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">__DEVICE__</span> <span class="kr">inline</span> <span class="n">T</span> <span class="n">ProjSubgradEval</span><span class="p">(</span><span class="k">const</span> <span class="n">FunctionObj</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">f_obj</span><span class="p">,</span> <span class="n">T</span> <span class="n">v</span><span class="p">,</span> <span class="n">T</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">T</span> <span class="n">a</span> <span class="o">=</span> <span class="n">f_obj</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">f_obj</span><span class="p">.</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">f_obj</span><span class="p">.</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">f_obj</span><span class="p">.</span><span class="n">d</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">f_obj</span><span class="p">.</span><span class="n">e</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">0.</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">d</span> <span class="o">+</span> <span class="n">e</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">d</span> <span class="o">-</span> <span class="n">e</span> <span class="o">*</span> <span class="n">x</span><span class="p">);</span>
    <span class="n">T</span> <span class="n">axb</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">f_obj</span><span class="p">.</span><span class="n">h</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="nl">kAbs</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">ProjSubgradAbs</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axb</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">ProjSubgradZero</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axb</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span> <span class="o">*</span> <span class="n">v</span> <span class="o">+</span> <span class="n">d</span> <span class="o">+</span> <span class="n">e</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>After layers and layers warpper, this file finally defines some interface function to evaluate these functions parallelly. Yet another OPENMP/CUDA warpper. Here are some examples:</p>
<div class="codehilite"><pre><span class="c1">// CPU version</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">ProxEval</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">FunctionObj</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">f_obj</span><span class="p">,</span> <span class="n">T</span> <span class="n">rho</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">*</span><span class="n">x_in</span><span class="p">,</span>
        <span class="n">T</span> <span class="o">*</span><span class="n">x_out</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef _OPENMP</span>
<span class="cp">#pragma omp parallel for</span>
<span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">f_obj</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">x_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ProxEval</span><span class="p">(</span><span class="n">f_obj</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x_in</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">rho</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//GPU version</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">ProxEvalF</span><span class="p">:</span> <span class="n">thrust</span><span class="o">::</span><span class="n">binary_function</span><span class="o">&lt;</span><span class="n">FunctionObj</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
        <span class="n">T</span> <span class="n">rho</span><span class="p">;</span><span class="n">__device__</span> <span class="nf">ProxEvalF</span><span class="p">(</span><span class="n">T</span> <span class="n">rho</span><span class="p">)</span> <span class="o">:</span>
                <span class="n">rho</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="p">}</span>
        <span class="n">__device__</span> <span class="n">T</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">FunctionObj</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">f_obj</span><span class="p">,</span> <span class="n">T</span> <span class="n">x</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">ProxEval</span><span class="p">(</span><span class="n">f_obj</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">rho</span><span class="p">);</span>
        <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">ProxEval</span><span class="p">(</span><span class="k">const</span> <span class="n">thrust</span><span class="o">::</span><span class="n">device_vector</span><span class="o">&lt;</span><span class="n">FunctionObj</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">f_obj</span><span class="p">,</span> <span class="n">T</span> <span class="n">rho</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">T</span> <span class="o">*</span><span class="n">x_in</span><span class="p">,</span> <span class="n">T</span> <span class="o">*</span><span class="n">x_out</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">thrust</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">thrust</span><span class="o">::</span><span class="n">device</span><span class="p">,</span> <span class="n">f_obj</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">f_obj</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span>
            <span class="n">thrust</span><span class="o">::</span><span class="n">device_pointer_cast</span><span class="p">(</span><span class="n">x_in</span><span class="p">),</span>
            <span class="n">thrust</span><span class="o">::</span><span class="n">device_pointer_cast</span><span class="p">(</span><span class="n">x_out</span><span class="p">),</span> <span class="n">ProxEvalF</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rho</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>


<p>These implemetations are very interesting. Need more attention here.<br />
This file also defines the <code>eps</code></p>
<div class="codehilite"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">__DEVICE__</span> <span class="kr">inline</span> <span class="n">T</span> <span class="n">Epsilon</span><span class="p">();</span>
<span class="k">template</span><span class="o">&lt;&gt;</span>
<span class="n">__DEVICE__</span> <span class="kr">inline</span> <span class="kt">double</span> <span class="n">Epsilon</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mf">4e-16</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">template</span><span class="o">&lt;&gt;</span>
<span class="n">__DEVICE__</span> <span class="kr">inline</span> <span class="kt">float</span> <span class="n">Epsilon</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mf">1e-7</span><span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h1 id="e464b9">pogs.h</h1>
<p>The pogs.h defines some control variables and instructions:</p>
<div class="codehilite"><pre><span class="k">const</span> <span class="kt">double</span> <span class="n">kAbsTol</span> <span class="o">=</span> <span class="mf">1e-4</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">double</span> <span class="n">kRelTol</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">double</span> <span class="n">kRhoInit</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">kVerbose</span> <span class="o">=</span> <span class="mi">2u</span><span class="p">;</span>   <span class="c1">// 0...4</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">kMaxIter</span> <span class="o">=</span> <span class="mi">2500u</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">kInitIter</span> <span class="o">=</span> <span class="mi">10u</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">bool</span> <span class="n">kAdaptiveRho</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">bool</span> <span class="n">kGapStop</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</pre></div>


<p>Apparently the name schema is subject to Google C++ style. Aside from these const values, some enum status are defined as well.</p>
<div class="codehilite"><pre><span class="k">enum</span> <span class="n">PogsStatus</span>
<span class="p">{</span>
    <span class="n">POGS_SUCCESS</span><span class="p">,</span>    <span class="c1">// Converged succesfully.</span>
    <span class="n">POGS_INFEASIBLE</span><span class="p">,</span> <span class="c1">// Problem likely infeasible.</span>
    <span class="n">POGS_UNBOUNDED</span><span class="p">,</span>  <span class="c1">// Problem likely unbounded</span>
    <span class="n">POGS_MAX_ITER</span><span class="p">,</span>   <span class="c1">// Reached max iter.</span>
    <span class="n">POGS_NAN_FOUND</span><span class="p">,</span>  <span class="c1">// Encountered nan.</span>
    <span class="n">POGS_ERROR</span>
<span class="p">};</span>
</pre></div>


<p>Then there comes the problem warpper <code>Pogs</code></p>
<div class="codehilite"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">M</span><span class="p">,</span> <span class="k">typename</span> <span class="n">P</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Pogs</span>
<span class="p">{</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="c1">// Data</span>
        <span class="n">M</span> <span class="n">_A</span><span class="p">;</span>
        <span class="n">P</span> <span class="n">_P</span><span class="p">;</span>
        <span class="n">T</span> <span class="o">*</span><span class="n">_de</span><span class="p">,</span> <span class="o">*</span><span class="n">_z</span><span class="p">,</span> <span class="o">*</span><span class="n">_zt</span><span class="p">,</span> <span class="n">_rho</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">_done_init</span><span class="p">;</span>

        <span class="c1">// Setup matrix _A and solver _LS</span>
        <span class="kt">int</span> <span class="nf">_Init</span><span class="p">();</span>

        <span class="c1">// Output.</span>
        <span class="n">T</span> <span class="o">*</span><span class="n">_x</span><span class="p">,</span> <span class="o">*</span><span class="n">_y</span><span class="p">,</span> <span class="o">*</span><span class="n">_mu</span><span class="p">,</span> <span class="o">*</span><span class="n">_lambda</span><span class="p">,</span> <span class="n">_optval</span><span class="p">;</span>

        <span class="c1">// Parameters.</span>
        <span class="n">T</span> <span class="n">_abs_tol</span><span class="p">,</span> <span class="n">_rel_tol</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">_max_iter</span><span class="p">,</span> <span class="n">_init_iter</span><span class="p">,</span> <span class="n">_verbose</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">_adaptive_rho</span><span class="p">,</span> <span class="n">_gap_stop</span><span class="p">,</span> <span class="n">_init_x</span><span class="p">,</span> <span class="n">_init_lambda</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>When we use <code>Pogs</code>, we just use a warpper of it <code>PogsDirect</code> or <code>PogsIndirect</code></p>
<div class="codehilite"><pre><span class="cp">#ifndef __CUDACC__</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">M</span><span class="o">&gt;</span>
    <span class="k">using</span> <span class="n">PogsDirect</span> <span class="o">=</span> <span class="n">Pogs</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">ProjectorDirect</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">M</span><span class="o">&gt;</span>
    <span class="k">using</span> <span class="n">PogsIndirect</span> <span class="o">=</span> <span class="n">Pogs</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">ProjectorCgls</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span>
<span class="cp">#endif</span>
</pre></div>


<h1 id="923c14">pogs.cpp</h1>
<p>Firstly, it defines a<code>ApplyOp</code> in a anonymous namespace, yet another function warpper:</p>
<div class="codehilite"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Op</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nl">ApplyOp</span><span class="p">:</span> <span class="n">std</span><span class="o">::</span><span class="n">binary_function</span><span class="o">&lt;</span><span class="n">FunctionObj</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">FunctionObj</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="p">{</span>
        <span class="n">Op</span> <span class="n">binary_op</span><span class="p">;</span>
        <span class="n">ApplyOp</span><span class="p">(</span><span class="n">Op</span> <span class="n">binary_op</span><span class="p">)</span> <span class="o">:</span>
                <span class="n">binary_op</span><span class="p">(</span><span class="n">binary_op</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="p">}</span>
        <span class="n">FunctionObj</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">operator</span><span class="p">()(</span><span class="n">FunctionObj</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">,</span> <span class="n">T</span> <span class="n">x</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">h</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">binary_op</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
            <span class="n">h</span><span class="p">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">binary_op</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">d</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
            <span class="n">h</span><span class="p">.</span><span class="n">e</span> <span class="o">=</span> <span class="n">binary_op</span><span class="p">(</span><span class="n">binary_op</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">e</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">h</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>Well , I have no idea why we need it.</p>
<p>Then here is the default pogs constructor:</p>
<div class="codehilite"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">M</span><span class="p">,</span> <span class="k">typename</span> <span class="n">P</span><span class="o">&gt;</span>
<span class="n">Pogs</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">P</span><span class="o">&gt;::</span><span class="n">Pogs</span><span class="p">(</span><span class="k">const</span> <span class="n">M</span> <span class="o">&amp;</span><span class="n">A</span><span class="p">)</span> <span class="o">:</span>
        <span class="n">_A</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">_P</span><span class="p">(</span><span class="n">_A</span><span class="p">),</span> <span class="n">_de</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">_z</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">_zt</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">_rho</span><span class="p">(</span>
                <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">kRhoInit</span><span class="p">)),</span> <span class="n">_done_init</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span> <span class="n">_x</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">_y</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">_mu</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">),</span> <span class="n">_lambda</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">_optval</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">0.</span><span class="p">)),</span> <span class="n">_abs_tol</span><span class="p">(</span>
                <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">kAbsTol</span><span class="p">)),</span> <span class="n">_rel_tol</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">kRelTol</span><span class="p">)),</span> <span class="n">_max_iter</span><span class="p">(</span>
                <span class="n">kMaxIter</span><span class="p">),</span> <span class="n">_init_iter</span><span class="p">(</span><span class="n">kInitIter</span><span class="p">),</span> <span class="n">_verbose</span><span class="p">(</span><span class="n">kVerbose</span><span class="p">),</span> <span class="n">_adaptive_rho</span><span class="p">(</span>
                <span class="n">kAdaptiveRho</span><span class="p">),</span> <span class="n">_gap_stop</span><span class="p">(</span><span class="n">kGapStop</span><span class="p">),</span> <span class="n">_init_x</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span> <span class="n">_init_lambda</span><span class="p">(</span>
                <span class="nb">false</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">_x</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">_A</span><span class="p">.</span><span class="n">Cols</span><span class="p">()]();</span>
    <span class="n">_y</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">_A</span><span class="p">.</span><span class="n">Rows</span><span class="p">()]();</span>
    <span class="n">_mu</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">_A</span><span class="p">.</span><span class="n">Cols</span><span class="p">()]();</span>
    <span class="n">_lambda</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">_A</span><span class="p">.</span><span class="n">Rows</span><span class="p">()]();</span>
<span class="p">}</span>
</pre></div>


<p>The constructor list is insane! After the contruction, we call <code>pogs::init</code> to do some check and memory allocation.</p>
<div class="codehilite"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">M</span><span class="p">,</span> <span class="k">typename</span> <span class="n">P</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">Pogs</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">P</span><span class="o">&gt;::</span><span class="n">_Init</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">DEBUG_EXPECT</span><span class="p">(</span><span class="o">!</span><span class="n">_done_init</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_done_init</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">_done_init</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="kt">size_t</span> <span class="n">m</span> <span class="o">=</span> <span class="n">_A</span><span class="p">.</span><span class="n">Rows</span><span class="p">();</span>
    <span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">_A</span><span class="p">.</span><span class="n">Cols</span><span class="p">();</span>

    <span class="n">_de</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">];</span>
    <span class="n">ASSERT</span><span class="p">(</span><span class="n">_de</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">_z</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">];</span>
    <span class="n">ASSERT</span><span class="p">(</span><span class="n">_z</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">_zt</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">];</span>
    <span class="n">ASSERT</span><span class="p">(</span><span class="n">_zt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">_de</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">_z</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">_zt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>

    <span class="n">_A</span><span class="p">.</span><span class="n">Init</span><span class="p">();</span>
    <span class="n">_A</span><span class="p">.</span><span class="n">Equil</span><span class="p">(</span><span class="n">_de</span><span class="p">,</span> <span class="n">_de</span> <span class="o">+</span> <span class="n">m</span><span class="p">);</span>
    <span class="n">_P</span><span class="p">.</span><span class="n">Init</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>After all the preparation, we call <code>pogs::solve</code> to get everything done. The signature of such function is:</p>
<div class="codehilite"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">M</span><span class="p">,</span> <span class="k">typename</span> <span class="n">P</span><span class="o">&gt;</span>
<span class="n">PogsStatus</span> <span class="n">Pogs</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">P</span><span class="o">&gt;::</span><span class="n">Solve</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">FunctionObj</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">,</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">FunctionObj</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">g</span><span class="p">)</span>
</pre></div>


<p>At the beginning of this function, it sets some const vars and memory allocation.</p>
<div class="codehilite"><pre><span class="kt">double</span> <span class="n">t0</span> <span class="o">=</span> <span class="n">timer</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">();</span>
<span class="c1">// Constants for adaptive-rho and over-relaxation.</span>
<span class="k">const</span> <span class="n">T</span> <span class="n">kDeltaMin</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1.05</span><span class="p">);</span>
<span class="k">const</span> <span class="n">T</span> <span class="n">kGamma</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1.01</span><span class="p">);</span>
<span class="k">const</span> <span class="n">T</span> <span class="n">kTau</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">0.8</span><span class="p">);</span>
<span class="k">const</span> <span class="n">T</span> <span class="n">kAlpha</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1.7</span><span class="p">);</span>
<span class="k">const</span> <span class="n">T</span> <span class="n">kRhoMin</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1e-4</span><span class="p">);</span>
<span class="k">const</span> <span class="n">T</span> <span class="n">kRhoMax</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1e4</span><span class="p">);</span>
<span class="k">const</span> <span class="n">T</span> <span class="n">kKappa</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">0.9</span><span class="p">);</span>
<span class="k">const</span> <span class="n">T</span> <span class="n">kOne</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
<span class="k">const</span> <span class="n">T</span> <span class="n">kZero</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
<span class="k">const</span> <span class="n">T</span> <span class="n">kProjTolMax</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1e-8</span><span class="p">);</span>
<span class="k">const</span> <span class="n">T</span> <span class="n">kProjTolMin</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1e-2</span><span class="p">);</span>
<span class="k">const</span> <span class="n">T</span> <span class="n">kProjTolPow</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1.3</span><span class="p">);</span>
<span class="k">const</span> <span class="n">T</span> <span class="n">kProjTolIni</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">);</span>
<span class="kt">bool</span> <span class="n">use_exact_stop</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">m</span> <span class="o">=</span> <span class="n">_A</span><span class="p">.</span><span class="n">Rows</span><span class="p">();</span>
<span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">_A</span><span class="p">.</span><span class="n">Cols</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">FunctionObj</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">f_cpu</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">FunctionObj</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">g_cpu</span> <span class="o">=</span> <span class="n">g</span><span class="p">;</span>

<span class="c1">// Allocate data for ADMM variables.</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">de</span> <span class="o">=</span> <span class="n">gsl</span><span class="o">::</span><span class="n">vector_view_array</span><span class="p">(</span><span class="n">_de</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">z</span> <span class="o">=</span> <span class="n">gsl</span><span class="o">::</span><span class="n">vector_view_array</span><span class="p">(</span><span class="n">_z</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">zt</span> <span class="o">=</span> <span class="n">gsl</span><span class="o">::</span><span class="n">vector_view_array</span><span class="p">(</span><span class="n">_zt</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">zprev</span> <span class="o">=</span> <span class="n">gsl</span><span class="o">::</span><span class="n">vector_calloc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ztemp</span> <span class="o">=</span> <span class="n">gsl</span><span class="o">::</span><span class="n">vector_calloc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">z12</span> <span class="o">=</span> <span class="n">gsl</span><span class="o">::</span><span class="n">vector_calloc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>

<span class="c1">// Create views for x and y components.</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">gsl</span><span class="o">::</span><span class="n">vector_subvector</span><span class="p">(</span><span class="o">&amp;</span><span class="n">de</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">gsl</span><span class="o">::</span><span class="n">vector_subvector</span><span class="p">(</span><span class="o">&amp;</span><span class="n">de</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">gsl</span><span class="o">::</span><span class="n">vector_subvector</span><span class="p">(</span><span class="o">&amp;</span><span class="n">z</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">gsl</span><span class="o">::</span><span class="n">vector_subvector</span><span class="p">(</span><span class="o">&amp;</span><span class="n">z</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">x12</span> <span class="o">=</span> <span class="n">gsl</span><span class="o">::</span><span class="n">vector_subvector</span><span class="p">(</span><span class="o">&amp;</span><span class="n">z12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">y12</span> <span class="o">=</span> <span class="n">gsl</span><span class="o">::</span><span class="n">vector_subvector</span><span class="p">(</span><span class="o">&amp;</span><span class="n">z12</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">xprev</span> <span class="o">=</span> <span class="n">gsl</span><span class="o">::</span><span class="n">vector_subvector</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zprev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">yprev</span> <span class="o">=</span> <span class="n">gsl</span><span class="o">::</span><span class="n">vector_subvector</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zprev</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">xtemp</span> <span class="o">=</span> <span class="n">gsl</span><span class="o">::</span><span class="n">vector_subvector</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ztemp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ytemp</span> <span class="o">=</span> <span class="n">gsl</span><span class="o">::</span><span class="n">vector_subvector</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ztemp</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
</pre></div>


<p>The <code>gsl::vector_subvector</code> is to provide a vector slice with its begin idx and length. The most important piece of these memory allocation is that <span class="math">\(z\)</span> is concatenation of <span class="math">\(x,y\)</span>, ie</p>
<div class="math">\begin{equation}\begin{aligned}z_{temp}&amp;=x_{temp}+y_{temp}\\z_{prev}&amp;=x_{prev}+y_{prev}\\z_{12}&amp;=x_{12}+y_{12}\\z&amp;=x+y\\\end{aligned}\end{equation}</div>
<p><br />
And the vars' correspondance to the vars in paper is </p>
<div class="math">\begin{equation}\begin{aligned}z_{prev}&amp;=z^{k}\\z_{t}&amp;=\hat{z}^k\\z&amp;=z^{k+1}\\z_{12}&amp;=z^{k+1/2}\\\end{aligned}\end{equation}</div>
<p><br />
Some more attention should be payed to the scale.</p>
<div class="codehilite"><pre><span class="c1">// Scale f and g to account for diagonal scaling e and d.</span>
<span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">f_cpu</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">f_cpu</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">d</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">f_cpu</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
        <span class="n">ApplyOp</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">divides</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">divides</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()));</span>
<span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">g_cpu</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">g_cpu</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">e</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">g_cpu</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
        <span class="n">ApplyOp</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">multiplies</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">multiplies</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()));</span>
</pre></div>


<p>If we have already run the solver before and gotten some results, we can resume the solver by filling <span class="math">\(x,lambda\)</span> by reusing these results.</p>
<div class="codehilite"><pre><span class="k">if</span> <span class="p">(</span><span class="n">_init_x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">gsl</span><span class="o">::</span><span class="n">vector_memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xtemp</span><span class="p">,</span> <span class="n">_x</span><span class="p">);</span>
    <span class="n">gsl</span><span class="o">::</span><span class="n">vector_div</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xtemp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">);</span>
    <span class="n">_A</span><span class="p">.</span><span class="n">Mul</span><span class="p">(</span><span class="sc">&#39;n&#39;</span><span class="p">,</span> <span class="n">kOne</span><span class="p">,</span> <span class="n">xtemp</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">kZero</span><span class="p">,</span> <span class="n">ytemp</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
    <span class="n">gsl</span><span class="o">::</span><span class="n">vector_memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">z</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ztemp</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">_init_lambda</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">gsl</span><span class="o">::</span><span class="n">vector_memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ytemp</span><span class="p">,</span> <span class="n">_lambda</span><span class="p">);</span>
    <span class="n">gsl</span><span class="o">::</span><span class="n">vector_div</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ytemp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">);</span>
    <span class="n">_A</span><span class="p">.</span><span class="n">Mul</span><span class="p">(</span><span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="o">-</span><span class="n">kOne</span><span class="p">,</span> <span class="n">ytemp</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">kZero</span><span class="p">,</span> <span class="n">xtemp</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
    <span class="n">gsl</span><span class="o">::</span><span class="n">blas_scal</span><span class="p">(</span><span class="o">-</span><span class="n">kOne</span> <span class="o">/</span> <span class="n">_rho</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ztemp</span><span class="p">);</span>
    <span class="n">gsl</span><span class="o">::</span><span class="n">vector_memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ztemp</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>Otherwise, we make a initial guess for these two vars</p>
<div class="codehilite"><pre><span class="k">if</span> <span class="p">(</span><span class="n">_init_x</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">_init_lambda</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Alternating projections to satisfy </span>
    <span class="c1">//   1. \lambda \in \partial f(y), \mu \in \partial g(x)</span>
    <span class="c1">//   2. \mu = -A^T\lambda</span>
    <span class="n">gsl</span><span class="o">::</span><span class="n">vector_set_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zprev</span><span class="p">,</span> <span class="n">kZero</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kInitIter</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ProjSubgradEval</span><span class="p">(</span><span class="n">g_cpu</span><span class="p">,</span> <span class="n">xprev</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">xtemp</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
        <span class="n">ProjSubgradEval</span><span class="p">(</span><span class="n">f_cpu</span><span class="p">,</span> <span class="n">yprev</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">y</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">ytemp</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
        <span class="n">_P</span><span class="p">.</span><span class="n">Project</span><span class="p">(</span><span class="n">xtemp</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">ytemp</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">kOne</span><span class="p">,</span> <span class="n">xprev</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">yprev</span><span class="p">.</span><span class="n">data</span><span class="p">,</span>
                <span class="n">kProjTolIni</span><span class="p">);</span>
        <span class="n">gsl</span><span class="o">::</span><span class="n">blas_axpy</span><span class="p">(</span><span class="o">-</span><span class="n">kOne</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ztemp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zprev</span><span class="p">);</span>
        <span class="n">gsl</span><span class="o">::</span><span class="n">blas_scal</span><span class="p">(</span><span class="o">-</span><span class="n">kOne</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zprev</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// xt = -1 / \rho * \mu, yt = -1 / \rho * \lambda.</span>
    <span class="n">gsl</span><span class="o">::</span><span class="n">vector_memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zprev</span><span class="p">);</span>
    <span class="n">gsl</span><span class="o">::</span><span class="n">blas_scal</span><span class="p">(</span><span class="o">-</span><span class="n">kOne</span> <span class="o">/</span> <span class="n">_rho</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zt</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">_init_lambda</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">_init_x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ASSERT</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">_init_x</span> <span class="o">=</span> <span class="n">_init_lambda</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</pre></div>


<p>Then it defines the stop criteria.</p>
<div class="codehilite"><pre><span class="n">T</span> <span class="n">sqrtn_atol</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">*</span> <span class="n">_abs_tol</span><span class="p">;</span>
<span class="n">T</span> <span class="n">sqrtm_atol</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="o">*</span> <span class="n">_abs_tol</span><span class="p">;</span>
<span class="n">T</span> <span class="n">sqrtmn_atol</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">))</span> <span class="o">*</span> <span class="n">_abs_tol</span><span class="p">;</span>
<span class="n">T</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">kDeltaMin</span><span class="p">,</span> <span class="n">xi</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">,</span> <span class="n">kd</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">,</span> <span class="n">ku</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">converged</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="n">T</span> <span class="n">nrm_r</span><span class="p">,</span> <span class="n">nrm_s</span><span class="p">,</span> <span class="n">gap</span><span class="p">,</span> <span class="n">eps_gap</span><span class="p">,</span> <span class="n">eps_pri</span><span class="p">,</span> <span class="n">eps_dua</span><span class="p">;</span>
</pre></div>


<p>Finally, here is the big iteration loop. I'm going to examine it step by step.</p>
<div class="codehilite"><pre><span class="n">gsl</span><span class="o">::</span><span class="n">vector_memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zprev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">z</span><span class="p">);</span>
<span class="c1">// Evaluate Proximal Operators</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">blas_axpy</span><span class="p">(</span><span class="o">-</span><span class="n">kOne</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">z</span><span class="p">);</span>
<span class="n">ProxEval</span><span class="p">(</span><span class="n">g_cpu</span><span class="p">,</span> <span class="n">_rho</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">x12</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
<span class="n">ProxEval</span><span class="p">(</span><span class="n">f_cpu</span><span class="p">,</span> <span class="n">_rho</span><span class="p">,</span> <span class="n">y</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">y12</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
</pre></div>


<p>In math , these code are identical to </p>
<div class="math">\begin{equation}\begin{aligned}z_{prev}&amp;=z\\z&amp;=z-z_t\\x_{12}&amp;=\textbf{prox} (g,x,\rho)\\y_{12}&amp;=\textbf{prox}(f,y,\rho)\\\end{aligned}\end{equation}</div>
<p><br />
The <code>prox</code> is proximal operator. After the new value of <span class="math">\(x,y\)</span> are computed, we calculate the gap,optimal value and tolerance to decide if the stop criterion is meet.</p>
<div class="codehilite"><pre><span class="n">gsl</span><span class="o">::</span><span class="n">blas_axpy</span><span class="p">(</span><span class="o">-</span><span class="n">kOne</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">z12</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">z</span><span class="p">);</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">blas_dot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">z</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">z12</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gap</span><span class="p">);</span>
<span class="n">gap</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">gap</span><span class="p">);</span>
<span class="n">eps_gap</span> <span class="o">=</span> <span class="n">sqrtmn_atol</span><span class="o">+</span> <span class="n">_rel_tol</span> <span class="o">*</span> <span class="n">gsl</span><span class="o">::</span><span class="n">blas_nrm2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">z</span><span class="p">)</span> <span class="o">*</span> <span class="n">gsl</span><span class="o">::</span><span class="n">blas_nrm2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">z12</span><span class="p">);</span>
<span class="n">eps_pri</span> <span class="o">=</span> <span class="n">sqrtm_atol</span> <span class="o">+</span> <span class="n">_rel_tol</span> <span class="o">*</span> <span class="n">gsl</span><span class="o">::</span><span class="n">blas_nrm2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y12</span><span class="p">);</span>
<span class="n">eps_dua</span> <span class="o">=</span> <span class="n">sqrtn_atol</span> <span class="o">+</span> <span class="n">_rel_tol</span> <span class="o">*</span> <span class="n">_rho</span> <span class="o">*</span> <span class="n">gsl</span><span class="o">::</span><span class="n">blas_nrm2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="c1">// should be x12?</span>
</pre></div>


<p>The math procedure is</p>
<div class="math">\begin{equation}\begin{aligned}z&amp;=z-z_{12}\\gap&amp;=\vert z*z_{12}\vert \\\epsilon ^{gap}&amp;=\sqrt{m+n} +\epsilon ^{rel} * \Vert z\Vert_2^2 *\Vert z_{12}\Vert_2^2\\\epsilon ^{pri}&amp;=\sqrt{m} +\epsilon ^{rel} * \Vert y_{12}\Vert_2^2\\\epsilon ^{dual}&amp;=\sqrt{n} +\epsilon ^{rel} *\Vert x_{12}\Vert_2^2\\\end{aligned}\end{equation}</div>
<div class="codehilite"><pre><span class="c1">// Apply over relaxation.</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">vector_memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ztemp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zt</span><span class="p">);</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">blas_axpy</span><span class="p">(</span><span class="n">kAlpha</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">z12</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ztemp</span><span class="p">);</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">blas_axpy</span><span class="p">(</span><span class="n">kOne</span> <span class="o">-</span> <span class="n">kAlpha</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zprev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ztemp</span><span class="p">);</span>

<span class="c1">// Project onto y = Ax.</span>
<span class="n">T</span> <span class="n">proj_tol</span> <span class="o">=</span> <span class="n">kProjTolMin</span>
        <span class="o">/</span> <span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">kProjTolPow</span><span class="p">);</span>
<span class="n">proj_tol</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">proj_tol</span><span class="p">,</span> <span class="n">kProjTolMax</span><span class="p">);</span>
<span class="n">_P</span><span class="p">.</span><span class="n">Project</span><span class="p">(</span><span class="n">xtemp</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">ytemp</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">kOne</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">y</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">proj_tol</span><span class="p">);</span>
</pre></div>


<p>The corrosponding math procedure is</p>
<div class="math">\begin{equation}\begin{aligned}z_{temp}&amp;=z_{t}+\alpha * z_{12}+(1-\alpha)*z_{prev}\\proj_{tol}&amp;=\max(ProjTolMax,ProjTolMin/(k+1)^{ProjTolPow})\\(x,y)&amp;=\text{proj} (x_{temp},y_{temp},proj_tol)\\\end{aligned}\end{equation}</div>
<p><br />
The projector function is not fully discussed. We will dive into its details later.</p>
<p>Now we calculate the residual :</p>
<div class="codehilite"><pre><span class="c1">// Calculate residuals.</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">vector_memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ztemp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zprev</span><span class="p">);</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">blas_axpy</span><span class="p">(</span><span class="o">-</span><span class="n">kOne</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">z</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ztemp</span><span class="p">);</span>
<span class="n">nrm_s</span> <span class="o">=</span> <span class="n">_rho</span> <span class="o">*</span> <span class="n">gsl</span><span class="o">::</span><span class="n">blas_nrm2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ztemp</span><span class="p">);</span>

<span class="n">gsl</span><span class="o">::</span><span class="n">vector_memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ztemp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">z12</span><span class="p">);</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">blas_axpy</span><span class="p">(</span><span class="o">-</span><span class="n">kOne</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">z</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ztemp</span><span class="p">);</span>
<span class="n">nrm_r</span> <span class="o">=</span> <span class="n">gsl</span><span class="o">::</span><span class="n">blas_nrm2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ztemp</span><span class="p">);</span>
</pre></div>


<p>The math procudure is</p>
<div class="math">\begin{equation}\begin{aligned}\Vert s^k \Vert_2^2&amp;=\rho *\Vert z_{prev}-z\Vert _2^2\\\Vert r^k \Vert_2^2&amp;=\Vert z_{12}-z\Vert _2^2\\\end{aligned}\end{equation}</div>
<p><br />
Then the solver decide if it calculate the exact residual by comparing current rough residual to the eps</p>
<div class="codehilite"><pre><span class="c1">// Calculate exact residuals only if necessary.</span>
<span class="kt">bool</span> <span class="n">exact</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="k">if</span> <span class="p">((</span><span class="n">nrm_r</span> <span class="o">&lt;</span> <span class="n">eps_pri</span> <span class="o">&amp;&amp;</span> <span class="n">nrm_s</span> <span class="o">&lt;</span> <span class="n">eps_dua</span><span class="p">)</span> <span class="o">||</span> <span class="n">use_exact_stop</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">gsl</span><span class="o">::</span><span class="n">vector_memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ztemp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">z12</span><span class="p">);</span>
    <span class="n">_A</span><span class="p">.</span><span class="n">Mul</span><span class="p">(</span><span class="sc">&#39;n&#39;</span><span class="p">,</span> <span class="n">kOne</span><span class="p">,</span> <span class="n">x12</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="o">-</span><span class="n">kOne</span><span class="p">,</span> <span class="n">ytemp</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
    <span class="n">nrm_r</span> <span class="o">=</span> <span class="n">gsl</span><span class="o">::</span><span class="n">blas_nrm2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ytemp</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">nrm_r</span> <span class="o">&lt;</span> <span class="n">eps_pri</span><span class="p">)</span> <span class="o">||</span> <span class="n">use_exact_stop</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">gsl</span><span class="o">::</span><span class="n">vector_memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ztemp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">z12</span><span class="p">);</span>
        <span class="n">gsl</span><span class="o">::</span><span class="n">blas_axpy</span><span class="p">(</span><span class="n">kOne</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ztemp</span><span class="p">);</span>
        <span class="n">gsl</span><span class="o">::</span><span class="n">blas_axpy</span><span class="p">(</span><span class="o">-</span><span class="n">kOne</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zprev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ztemp</span><span class="p">);</span>
        <span class="n">_A</span><span class="p">.</span><span class="n">Mul</span><span class="p">(</span><span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="n">kOne</span><span class="p">,</span> <span class="n">ytemp</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">kOne</span><span class="p">,</span> <span class="n">xtemp</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
        <span class="n">nrm_s</span> <span class="o">=</span> <span class="n">_rho</span> <span class="o">*</span> <span class="n">gsl</span><span class="o">::</span><span class="n">blas_nrm2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xtemp</span><span class="p">);</span>
        <span class="n">exact</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>Frankly,I don't know where the exact residual come from!!!!</p>
<p>Finally we come to the stopping criterial</p>
<div class="codehilite"><pre><span class="n">converged</span> <span class="o">=</span> <span class="n">exact</span> <span class="o">&amp;&amp;</span> <span class="n">nrm_r</span> <span class="o">&lt;</span> <span class="n">eps_pri</span> <span class="o">&amp;&amp;</span> <span class="n">nrm_s</span> <span class="o">&lt;</span> <span class="n">eps_dua</span><span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">_gap_stop</span> <span class="o">||</span> <span class="n">gap</span> <span class="o">&lt;</span> <span class="n">eps_gap</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">converged</span> <span class="o">||</span> <span class="n">k</span> <span class="o">==</span> <span class="n">_max_iter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="k">break</span><span class="p">;</span>
</pre></div>


<p>If not converged yet, we should update the dual variable</p>
<div class="codehilite"><pre><span class="c1">// Update dual variable.</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">blas_axpy</span><span class="p">(</span><span class="n">kAlpha</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">z12</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zt</span><span class="p">);</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">blas_axpy</span><span class="p">(</span><span class="n">kOne</span> <span class="o">-</span> <span class="n">kAlpha</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zprev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zt</span><span class="p">);</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">blas_axpy</span><span class="p">(</span><span class="o">-</span><span class="n">kOne</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">z</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zt</span><span class="p">);</span>
</pre></div>


<p>In short, the z update is</p>
<div class="math">\begin{equation}z_t=\alpha * z_{12} +(1-\alpha)*z_{prev} -z\end{equation}</div>
<p><br />
Sometimes the <span class="math">\(\rho\)</span> is dynamic , we would update the <span class="math">\(\rho\)</span> as well. The detail is ad-hoc so I'm not going to explain it (It's just a mess).</p>
<p>The whole procedure is not straight to understand, especially with the different <span class="math">\(z\)</span> names. The workflow presented in paper is:</p>
<div class="math">\begin{equation}\begin{aligned}x^{k+1/2}&amp;=\text{prox}_g(x^k-\hat{x}^k)\\y^{k+1/2}&amp;=\text{prox}_f(y^k-\hat{y}^k)\\(x^{k+1},y^{k+1})&amp;=\prod _A (x^{k+1/2}+\hat{x}^k,y^{k+1/2}+\hat{y}^k)\\\hat{x}^{k+1}&amp;=\hat{x}^k+x^{k+1/2}-x^{k+1}\\\hat{y}^{k+1}&amp;=\hat{y}^k+y^{k+1/2}-y^{k+1}\\\end{aligned}\end{equation}</div>
<p><br />
The <span class="math">\(\prod\)</span> denotes projection onto <span class="math">\(\{(x,y)| y=Ax\}\)</span>.</p>
<p>The solver body is completed, and we instantiate some template at the end of this cpp file:</p>
<div class="codehilite"><pre><span class="c1">// Explicit template instantiation.</span>
<span class="c1">// Dense direct.</span>
<span class="k">template</span> <span class="k">class</span> <span class="nc">Pogs</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">MatrixDense</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">ProjectorDirect</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">MatrixDense</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">;</span>
<span class="k">template</span> <span class="k">class</span> <span class="nc">Pogs</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">MatrixDense</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">ProjectorDirect</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">MatrixDense</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">;</span>

<span class="c1">// Dense indirect.</span>
<span class="k">template</span> <span class="k">class</span> <span class="nc">Pogs</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">MatrixDense</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">ProjectorCgls</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">MatrixDense</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">;</span>
<span class="k">template</span> <span class="k">class</span> <span class="nc">Pogs</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">MatrixDense</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">ProjectorCgls</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">MatrixDense</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">;</span>

<span class="c1">// Sparse indirect.</span>
<span class="k">template</span> <span class="k">class</span> <span class="nc">Pogs</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">MatrixSparse</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">ProjectorCgls</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">MatrixSparse</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">;</span>
<span class="k">template</span> <span class="k">class</span> <span class="nc">Pogs</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">MatrixSparse</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">ProjectorCgls</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">MatrixSparse</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">;</span>
</pre></div>


<h1 id="68ac6b">projection.h</h1>
<p>The subspace projection problem is to project <span class="math">\(x_0,y_0\)</span> to one point <span class="math">\((x_1,y_1)\)</span> in subspace <span class="math">\(y=Ax\)</span>. Ie </p>
<div class="math">\begin{equation}minimize \quad \Vert (x_1,y_1)-(x_0,y_0)\Vert _2^2 \quad w.r.t. \quad y_1=Ax_1 \end{equation}</div>
<p><br />
Infact this subspace projection is a viaration of least squre projection <span class="math">\(Ax=b\)</span>. If we conside <span class="math">\(b=x_0++y_0\)</span> and <span class="math">\(A_1=I++A\)</span> where the <span class="math">\(++\)</span> is concatenation . So current problem is to solve the least square projection of <span class="math">\(A_1 x=b\)</span>.</p>
<p>But there is a cut through answer without the concatenation . We take derivation of </p>
<div class="math">\begin{equation}\Vert x-x_0\Vert _2^2 +\Vert Ax -y_0\Vert _2^2\end{equation}</div>
<p><br />
and set it to zero, we get</p>
<div class="math">\begin{equation}x(I+A^TA)=x_0+A^Ty_0\end{equation}</div>
<p><br />
That's a least square projection problem. If we solve the <span class="math">\(x\)</span> ,then <span class="math">\(y=Ax\)</span>.</p>
<p>The least square projection problem.r can be done in two manner: conjugate gradient and direct.</p>
<p>The conjugate gradient algorithm is detailed below for solving <span class="math">\(Ax = b\)</span> where <span class="math">\(A\)</span> is a real, symmetric, positive-definite matrix. The input vector <span class="math">\(x_0\)</span> can be an approximate initial solution or 0. </p>
<p><img alt="共轭梯度法" src="http://spiritsaway.info/code/image/POGS/conjugategradient.png" /></p>
<p>While the direct method is to compute</p>
<div class="math">\begin{equation}x=(A^TA)^{-1}Ab\end{equation}</div>
<p><br />
The code is straight forward. Here is the preparation work.</p>
<div class="codehilite"><pre><span class="kt">size_t</span> <span class="n">min_dim</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">_A</span><span class="p">.</span><span class="n">Rows</span><span class="p">(),</span> <span class="n">_A</span><span class="p">.</span><span class="n">Cols</span><span class="p">());</span>

<span class="n">info</span><span class="o">-&gt;</span><span class="n">AA</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">min_dim</span> <span class="o">*</span> <span class="n">min_dim</span><span class="p">];</span>
<span class="n">ASSERT</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">AA</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">info</span><span class="o">-&gt;</span><span class="n">L</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">min_dim</span> <span class="o">*</span> <span class="n">min_dim</span><span class="p">];</span>
<span class="n">ASSERT</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">L</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">memset</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">AA</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">min_dim</span> <span class="o">*</span> <span class="n">min_dim</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>
<span class="n">memset</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">min_dim</span> <span class="o">*</span> <span class="n">min_dim</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>

<span class="n">CBLAS_TRANSPOSE_t</span> <span class="n">op_type</span> <span class="o">=</span> <span class="n">_A</span><span class="p">.</span><span class="n">Rows</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">_A</span><span class="p">.</span><span class="n">Cols</span><span class="p">()</span> <span class="o">?</span> <span class="nl">CblasTrans</span> <span class="p">:</span> <span class="n">CblasNoTrans</span><span class="p">;</span>

<span class="c1">// Compute AA</span>
<span class="k">if</span> <span class="p">(</span><span class="n">_A</span><span class="p">.</span><span class="n">Order</span><span class="p">()</span> <span class="o">==</span> <span class="n">MatrixDense</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">ROW</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">gsl</span><span class="o">::</span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">CblasRowMajor</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span>
        <span class="n">gsl</span><span class="o">::</span><span class="n">matrix_view_array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">CblasRowMajor</span><span class="o">&gt;</span>
        <span class="p">(</span><span class="n">_A</span><span class="p">.</span><span class="n">Data</span><span class="p">(),</span> <span class="n">_A</span><span class="p">.</span><span class="n">Rows</span><span class="p">(),</span> <span class="n">_A</span><span class="p">.</span><span class="n">Cols</span><span class="p">());</span>
    <span class="n">gsl</span><span class="o">::</span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">CblasRowMajor</span><span class="o">&gt;</span> <span class="n">AA</span> <span class="o">=</span> <span class="n">gsl</span><span class="o">::</span><span class="n">matrix_view_array</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">CblasRowMajor</span> <span class="o">&gt;</span>
        <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">AA</span><span class="p">,</span> <span class="n">min_dim</span><span class="p">,</span> <span class="n">min_dim</span><span class="p">);</span>
    <span class="n">gsl</span><span class="o">::</span><span class="n">blas_syrk</span><span class="p">(</span><span class="n">CblasLower</span><span class="p">,</span> <span class="n">op_type</span><span class="p">,</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1.</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">A</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">0.</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">AA</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>In short, the pogs consider <span class="math">\(A\)</span> is <span class="math">\(m*n\)</span> ,while<span class="math">\(m\ge n\)</span>. If the input is not in that form, we would transpose <span class="math">\(A\)</span>(not transpose it in memory but logically). The<code>min_dim</code> is <span class="math">\(less(m,n)\)</span>. And the <span class="math">\(A^TA\)</span> is computed by a <code>syrk</code> call. </p>
<div class="codehilite"><pre><span class="k">const</span> <span class="n">gsl</span><span class="o">::</span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">CblasRowMajor</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span>
    <span class="n">gsl</span><span class="o">::</span><span class="n">matrix_view_array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">CblasRowMajor</span><span class="o">&gt;</span>
    <span class="p">(</span><span class="n">_A</span><span class="p">.</span><span class="n">Data</span><span class="p">(),</span> <span class="n">_A</span><span class="p">.</span><span class="n">Rows</span><span class="p">(),</span> <span class="n">_A</span><span class="p">.</span><span class="n">Cols</span><span class="p">());</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">CblasRowMajor</span><span class="o">&gt;</span> <span class="n">AA</span> <span class="o">=</span> <span class="n">gsl</span><span class="o">::</span><span class="n">matrix_view_array</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">CblasRowMajor</span> <span class="o">&gt;</span>
    <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">AA</span><span class="p">,</span> <span class="n">min_dim</span><span class="p">,</span> <span class="n">min_dim</span><span class="p">);</span>
<span class="n">gsl</span><span class="o">::</span><span class="n">matrix</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">CblasRowMajor</span><span class="o">&gt;</span> <span class="n">L</span> <span class="o">=</span> <span class="n">gsl</span><span class="o">::</span><span class="n">matrix_view_array</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">CblasRowMajor</span> <span class="o">&gt;</span>
    <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">L</span><span class="p">,</span> <span class="n">min_dim</span><span class="p">,</span> <span class="n">min_dim</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">gsl</span><span class="o">::</span><span class="n">matrix_memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">L</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">AA</span><span class="p">);</span>
    <span class="n">gsl</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">diagL</span> <span class="o">=</span> <span class="n">gsl</span><span class="o">::</span><span class="n">matrix_diagonal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">L</span><span class="p">);</span>
    <span class="n">gsl</span><span class="o">::</span><span class="n">vector_add_constant</span><span class="p">(</span><span class="o">&amp;</span><span class="n">diagL</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
    <span class="n">gsl</span><span class="o">::</span><span class="n">linalg_cholesky_decomp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">L</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">_A</span><span class="p">.</span><span class="n">Rows</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">_A</span><span class="p">.</span><span class="n">Cols</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">gsl</span><span class="o">::</span><span class="n">blas_gemv</span><span class="p">(</span><span class="n">CblasTrans</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1.</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">A</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y_vec</span><span class="p">,</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1.</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">x_vec</span><span class="p">);</span>
    <span class="n">gsl</span><span class="o">::</span><span class="n">linalg_cholesky_svx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">L</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x_vec</span><span class="p">);</span>
    <span class="n">gsl</span><span class="o">::</span><span class="n">blas_gemv</span><span class="p">(</span><span class="n">CblasNoTrans</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1.</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">A</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x_vec</span><span class="p">,</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">0.</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">y_vec</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>We must take care of row major or col major.</p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
    </div>
    <div id="content-comments">
<div id="disqus_thread"></div>
<script type="text/javascript">var disqus_shortname="SpiritsAway";(function(){var a=document.createElement("script");a.type="text/javascript";a.async=true;a.src="//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)})();</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</div>
<div class="niu2-right-container col-md-2">
    <div id="niu2-sidebar-meta" class="niu2-sidebar">
        <div class="niu2-sidebar-label"><i class="icon-calendar"></i>发布时间:</div>
        <div class="niu2-sidebar-value">2015-05-15 21:31</div>
        <div class="niu2-sidebar-label"><i class="icon-open-folder"></i>分类:</div>
        <div class="niu2-sidebar-value"><a href="http://spiritsaway.info/code/index.html">Code</a></div>
        <div class="niu2-sidebar-label"><i class="icon-tag"></i>标签:</div>
 
            <div class="niu2-sidebar-inter-value niu2-sidebar-tag"><a href="http://spiritsaway.info/tag/code.html">Code</a><sup>3</sup></div>
            <div class="niu2-sidebar-inter-value niu2-sidebar-tag"><a href="http://spiritsaway.info/tag/admm.html">ADMM</a><sup>2</sup></div>
    </div>

    <div id="niu2-sidebar-toc" class="niu2-sidebar" data-status="closed">
        <div class="niu2-sidebar-label">
            <i id="niu2-sidebar-toc-ctrl" class="icon-open-tocs"></i>目录
        </div>
        <ol id="niu2-sidebar-toc-list">
            <li><a href="#content-heading">Under the Hood : POGS</a></li>
            <li><a href='#832cb9'>POGS Introduction</a></li><li><a href='#bb96e3'>util.h</a></li><li><a href='#adc0c1'>prox_lib.h</a></li><li><a href='#e464b9'>pogs.h</a></li><li><a href='#923c14'>pogs.cpp</a></li><li><a href='#68ac6b'>projection.h</a></li>
            <li><a href="#content-comments">评论</a></li>
        </ol>
    </div>
</div>    </div>

    <div class="niu2-footer">
        <div id="body-footer" class="col-md-6 col-md-offset-2">
<hr/>
<p>
    Powered by <a href="https://github.com/getpelican/pelican">Pelican</a>, 
    <a href="https://github.com/mawenbao/niu-x2-sidebar">theme</a> built with <a href="http://getbootstrap.com">Bootstrap3</a>
    by <a href="http://blog.atime.me">Ma Wenbao</a>, icons by 
    <a href="http://fortawesome.github.io/Font-Awesome">Font Awesome</a>.
</p>
<p>
    ©
            2014-2015
    <a class="niu2-footer-link" href="http://spiritsaway.info">Huiliang Huang</a>
</p>
<p class="niu2-icons">
        <a class="niu2-footer-icon" href="mailto: spiritsaway@outlook.com" title="my email address">
            <i class="fa-envelope-alt icon-lg"></i>
        </a>
        <a class="niu2-footer-icon" href="https://github.com/huangfeidian" title="my github page">
            <i class="fa-github-alt icon-lg"></i>
        </a>
</p>        </div>
    </div>
    
    <div id="niu2-pygments" data-theme="github"></div>

    <script type="text/javascript" src="http://spiritsaway.info/theme/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="http://spiritsaway.info/theme/js/niu2.min.js"></script>
    <script type="text/javascript" src="http://spiritsaway.info/theme/js/bootstrap.min.js"></script>
    <script type="text/javascript">onContentLoaded();</script>
  </body>
</html>
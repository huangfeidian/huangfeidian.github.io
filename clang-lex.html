<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clang Lex - spirits away</title>
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.png">
    <link rel="stylesheet" href="./theme/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="./theme/font-icons/style.min.css" type="text/css" />
    <link rel="stylesheet" href="./theme/css/niu2.min.css" type="text/css" />

    <link rel="canonical" href="./clang-lex.html" />
    
    <script type="text/javascript">window.onload=function(){};</script>
    <!--[if lt IE 9]>
        <script src="./theme/js/html5shiv.js"></script>
        <script src="./theme/js/respond.min.js"></script>
    <![endif]-->
  </head>
  <body> 
    <div id="body-header">
<div class="navbar navbar-inverse navbar-fixed-top">
<div class="col-md-12">
    <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href=".">
            <i class="icon-home"></i>spirits away
        </a>
    </div>
    <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
        <ul class="nav navbar-nav">
            <li><a href="/pages/about.html" title="about">
                <i class="icon-anchor"></i>关于</a>
            </li>
            <li><a href="/archives.html" title="archives">
                <i class="icon-archive"></i>存档</a>
            </li>
            <li><a href="/tags.html" title="tags">
                <i class="icon-tag"></i>标签</a>
            </li>
        <!-- category dropdown list -->
        <!--  self defined dropdown list -->
        </ul>
        
        <!-- right nav bar -->
        <ul class="nav navbar-nav navbar-right">
        <!-- google custom search -->
       </ul>
    </nav>
</div>
</div>    </div>
    
    <div id="body-content">
<div class="col-md-8 col-md-offset-2">
    <h1 id="content-heading">Clang Lex</h1>
</div>
<div id="niu2-left-container" class="col-md-6 col-md-offset-2 with-right-border">
    <div id="niu2-main-content">
        <h1 id="c99c80">Lexer</h1>
<p>在cpp语言标准中，词法分析分为了多道。</p>
<ol>
<li>
<p>phase 1.操作系统将源文件里的每个字节从源文件编码转换为标准编码。主要包括平台相关的换行符替换、宽字节（UCN）映射和trigraph映射。</p>
</li>
<li>
<p>phase 2.每个以<span class="math">\(\backslash\)</span>为结束的行，都会与之后的那一行进行拼接。但是这里每一行只处理一次这个情况，末尾是<span class="math">\(\backslash\)</span><span class="math">\(\backslash\)</span>且下一行是空行的情况下不会自动拼接到第二行。同时对于行拼接可能引发的UCN编码结果都是未定义行为。如果源文件最后一行是以<span class="math">\(\backslash\)</span>结尾的，则这个也是一个未定义行为。</p>
</li>
<li>
<p>phase 3.源文件内容被分为了：注释、空白和预处理词法单元。这些预处理此法单元包括：</p>
<ol>
<li>
<p>在 #include 后面的头文件名字</p>
</li>
<li>
<p>标识符</p>
</li>
<li>
<p>预处理数字</p>
</li>
<li>
<p>字符常量和字符串常量，包括用户自定义类型</p>
</li>
<li>
<p>操作符和标点符号， 这里又引入了<a href="http://en.cppreference.com/w/cpp/language/operator_alternative">alternative tokens</a>这种形式，</p>
</li>
<li>
<p>不属于上述归类的的字符串</p>
</li>
</ol>
<p>注意这里从cpp11开始规定了<a href="http://en.cppreference.com/w/cpp/language/string_literal">raw string literal</a>，对于phase 1和phase 2中对于这个raw string literal的替换操作都要重新revert一下。</p>
</li>
<li>
<p>phase 4. 预处理器开始执行。每个include的文件都要递归的走phase1-phase 4。在完整的执行完之后，文件中不能再包含预处理指令</p>
</li>
<li>
<p>phase 5.源文件中的字符常量和字符串常量编码都会转换为执行期的字符串编码。此时会对字符进行转义。</p>
</li>
<li>
<p>phase 6. 相邻的字符串常量会被拼接起来。</p>
</li>
<li>
<p>phase 7.每个词法单元根据语法约束变为语法单元，最后转变为翻译单元(translation
    unit)。</p>
</li>
<li>
<p>phase 8.每个翻译单元都会实例化所用的模板，并成为了实例单元(instantiation unit)</p>
</li>
<li>
<p>phase 9. 将实例单元翻译单元以及引用的库组件合并为一个执行单元</p>
</li>
</ol>
<p>这9道过程中，前6道都与词法分析相关，下面对这些道进行分析</p>
<h1 id="6382f8">phase 1-2 字符处理与行拼接</h1>
<p>对于lexer的分析，首先要处理的是字符集。当前标准里规定了如下几类的字符处理：</p>
<ol>
<li>普通ASCII码字符</li>
<li>UCN(universal character name) 这个用来代表多字节编码的字符，形式为<span class="math">\(\backslash\)</span> uXXXX和<span class="math">\(\backslash\)</span>UXXXXXXXX。这里的X代表一个十六进制数，大写u和小写U代表了双字节和四字节.同时<span class="math">\(\backslash\)</span>uXXXX等价于<span class="math">\(\backslash\)</span>U0000XXXX。这里的值还有限制，不能落在0xD800-0xDFFF之内，因为这些值是用来规定代码点的。对于UCN的具体要求参见ISO/IEC 10646。这部分对应的代码在LiteralSupport.cpp里的clang::expandUCNS和ProcessUCNEscape。clang会把UCN编码为一个uint32<span class="math">\(\_\)</span>t，也就是UTF32类型，但是后面好需要转换为UTF8/16等，这部分函数仍然在LiteralSupport里，MeasureUCNEscape和EncodeUCNEscape</li>
<li>trigraph 三字符。形式为??开头的三个连续字符，最后一个字符只有9种选择，这三个字符合起来会转换为一个新的符号。这个部分已经被新的cpp标准所废弃，但是IBM那边为了兼容性活生生的拖到了cpp17才执行。相关代码在Lexer.cpp里的GetTrigraphCharForLetter,很简单</li>
</ol>
<p>对于字符的处理，相关代码放在Lexer.h里的getAndAdvanceChar和ConsumeChar这两个函数里，涉及到的函数包括：</p>
<ol>
<li>
<p>isObviouslySimpleCharacter 其实就是判断一个字符是不是?或者<span class="math">\(\backslash\)</span> 因为只有这两个开头的字符才会引起trigraph、ucn以及行拼接的转换</p>
</li>
<li>
<p>getAndAdvanceChar 从buffer中读取下一个可以拿出的字符，如果下一个字符是简单字符(也就是isObviouslySimpleCharacter返回true)，则直接返回下一个字符，否则调用getCharAndSizeSlow来处理可能的多字符的情况，处理完成之后对应的Buffer指针前进道下一个字符的位置。</p>
</li>
<li>
<p>ConsumeChar 这个跟前一个函数差不多</p>
</li>
<li>
<p>getCharAndSize 这个只peek下一个字符，并不修改buffer指针，逻辑也与之前的一样，都会过一下obvious
    simple判断。</p>
</li>
<li>
<p>getEscapedNewLineSize 这个处理<span class="math">\(\backslash\)</span>和下一个空行之间的白空间大小，这个会触发警告</p>
</li>
<li>
<p>getCharAndSizeSlow 这个函数负责处理可能的行拼接和trigraph，但是拼接之后可能还是空白字符，所以需要递归调用。至于trigraph的处理则放到了DecodeTrigraphChar这个函数里面，但是处理trigrah也可能会涉及到行拼接的问题（虽然标准里说这是未定义的），此处使用了goto来避免行拼接之后再调用trigraph的处理。</p>
</li>
<li>
<p>DecodeTrigraphChar 其实基本就是一个switch case语句来查询转换表，同时根据语言选项来给出trigraph的使用警告。</p>
</li>
<li>
<p>tryReadUCN 这个会被用来处理UCN的读取并检查生成的代码点的有效性，内部会调用getCharSize来处理行拼接的情况，其实按照标准行拼接引起的ucn是未定义行为。</p>
</li>
</ol>
<h1 id="128a22">phase 3 基础词法</h1>
<h2 id="0b361c">Literal Support</h2>
<p>对于数值常量、字符常量、字符串常量部分的代码都在LiteralSupport之中。</p>
<h3 id="813397">数值常量</h3>
<p>数值常量的处理定义在LiteralSupport的NumericLiteralParser里面。将初始位置和预处理器传进去构造一个这样的对象，在这个对象的构造函数里就会自动处理数值的parse问题。内部还定义了ParseNumberStartingWithZero 处理开头数字是0的数，包括基数为2，8，16的整数和一些小数。这个构造函数里并不直接计算数值，而是记录一些格式信息：是否遇到了小数点、指数，后缀是否合法（包括用户自定义后缀）等。真正获得值则需要调用GetIntegerValue,GetFloatValue这两个函数来处理。GetFloatValue这里其实并没有做多少工作，而是委托到了APFloat::convertFromString中去处理这段数值文本。</p>
<p>对于整数的处理这里还有一个优化，这个优化是用来避免判断数值是否溢出的：</p>
<div class="codehilite"><pre><span></span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">alwaysFitsInto64Bits</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">Radix</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">NumDigits</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">Radix</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
        <span class="k">return</span> <span class="n">NumDigits</span> <span class="o">&lt;=</span> <span class="mi">64</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">8</span><span class="o">:</span>
        <span class="k">return</span> <span class="n">NumDigits</span> <span class="o">&lt;=</span> <span class="mi">64</span> <span class="o">/</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// Digits are groups of 3 bits.</span>
    <span class="k">case</span> <span class="mi">10</span><span class="o">:</span>
        <span class="k">return</span> <span class="n">NumDigits</span> <span class="o">&lt;=</span> <span class="mi">19</span><span class="p">;</span> <span class="c1">// floor(log10(2^64))</span>
    <span class="k">case</span> <span class="mi">16</span><span class="o">:</span>
        <span class="k">return</span> <span class="n">NumDigits</span> <span class="o">&lt;=</span> <span class="mi">64</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// Digits are groups of 4 bits.</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;impossible Radix&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>这个函数计算出了每一种进制下的绝对不会溢出的数字长度值范围，获得值的时候则首先计算一下当前整数的字符长度是否超过了对应的范围。如果没超过则直接返回计算出来的值，如果超过了则需要每一步进行检查是否溢出。因为一般情况下我们提供的基本都是小整数，这样做就可以避免很多关于溢出的检测。</p>
<h3 id="d02921">字符常量和字符串常量</h3>
<p>字符常量也有一个对应的对象构造CharLiteralParser。这里主要是要小心多字节的字符和带UCN的字符，其他的没什么需要注意的。</p>
<p>对于字符串的处理这里还是比较复杂的，都放在StringLiteralParser的init函数里，会处理自定义字符串常量后缀、字符串内转义、多字节编码、Raw string等各种情况。</p>
<h2 id="414fa3">lex 辅助函数</h2>
<p>在lexer中，定义了如下的一些辅助函数来专门处理各种类型的词法单元：</p>
<div class="codehilite"><pre><span></span>    <span class="c1">// Helper functions to lex the remainder of a token of the specific type.</span>
    <span class="kt">bool</span> <span class="nf">LexIdentifier</span><span class="p">(</span><span class="n">Token</span> <span class="o">&amp;</span><span class="n">Result</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">CurPtr</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="nf">LexNumericConstant</span><span class="p">(</span><span class="n">Token</span> <span class="o">&amp;</span><span class="n">Result</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">CurPtr</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="nf">LexStringLiteral</span><span class="p">(</span><span class="n">Token</span> <span class="o">&amp;</span><span class="n">Result</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">CurPtr</span><span class="p">,</span>
    <span class="n">tok</span><span class="o">::</span><span class="n">TokenKind</span> <span class="n">Kind</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="nf">LexRawStringLiteral</span><span class="p">(</span><span class="n">Token</span> <span class="o">&amp;</span><span class="n">Result</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">CurPtr</span><span class="p">,</span>
    <span class="n">tok</span><span class="o">::</span><span class="n">TokenKind</span> <span class="n">Kind</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="nf">LexAngledStringLiteral</span><span class="p">(</span><span class="n">Token</span> <span class="o">&amp;</span><span class="n">Result</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">CurPtr</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="nf">LexCharConstant</span><span class="p">(</span><span class="n">Token</span> <span class="o">&amp;</span><span class="n">Result</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">CurPtr</span><span class="p">,</span>
    <span class="n">tok</span><span class="o">::</span><span class="n">TokenKind</span> <span class="n">Kind</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="nf">LexEndOfFile</span><span class="p">(</span><span class="n">Token</span> <span class="o">&amp;</span><span class="n">Result</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">CurPtr</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="nf">SkipWhitespace</span><span class="p">(</span><span class="n">Token</span> <span class="o">&amp;</span><span class="n">Result</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">CurPtr</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="o">&amp;</span><span class="n">TokAtPhysicalStartOfLine</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="nf">SkipLineComment</span><span class="p">(</span><span class="n">Token</span> <span class="o">&amp;</span><span class="n">Result</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">CurPtr</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="o">&amp;</span><span class="n">TokAtPhysicalStartOfLine</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="nf">SkipBlockComment</span><span class="p">(</span><span class="n">Token</span> <span class="o">&amp;</span><span class="n">Result</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">CurPtr</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="o">&amp;</span><span class="n">TokAtPhysicalStartOfLine</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="nf">SaveLineComment</span><span class="p">(</span><span class="n">Token</span> <span class="o">&amp;</span><span class="n">Result</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">CurPtr</span><span class="p">);</span>
</pre></div>


<ol>
<li>
<p>LexIdentifier 这个函数用来lex一个identifier，内部分为了fast path和slow path。fast path是只处理ASCII符号，而slow path则需要处理宽字符集、UCN、trigraph等情况，这些情况都是由getCharAndSize来内部处理的。处理完slow
    path后会复用fast path的一些代码，这里为了避免代码重复就使用了goto。</p>
</li>
<li>
<p>LexNumericConstant 由于数值部分可能有多个子部分都符合数值要求，所以这个函数是会递归的调用自己，把所有可能的数字形式都包容进来。这里有很多奇葩情况，如16进制的浮点，’分割的数字，含有ucn的用户自定义后缀等等。当无法递归下去的时候，则把开头的位置设置到token里。</p>
</li>
<li>
<p>LexStringLiteral 这个倒没什么可说的，一路调用getAndAdvanceChar即可。</p>
</li>
<li>
<p>LexRawStringLiteral 这里不能利用getAndAdvanceChar这个函数，因为cpp标准里规定在raw
    string里任何phase 1和phase 2所引起的转换都会被revert。</p>
</li>
<li>
<p>LexAngledStringLiteral 这个是用来处理# include 头文件名称的。</p>
</li>
<li>
<p>LexCharConstant 这个用来获得单个字符，也是调用getAndAdvanceChar即可</p>
</li>
<li>
<p>SkipBlockComment 这个用来处理/*开头的注释，处理时就是一路扫描/字符，如果前一个字符是*则认为处理完毕。这里主要的代码在处理扫描/时的优化，可以使用里的函数来加快扫描，一次可以使用16个字符。</p>
</li>
</ol>
<p>这些函数结束之后都会生成一个token。</p>
<h2 id="4222f4">lex入口函数</h2>
<p>整个lexer的入口函数是Lexer::lex，调用之后会返回一个Token。但是其实这个函数几乎什么事都不干，完全转接到Lexer::LexTokenInternal这个函数里面。这个函数主要的函数体就是一个大switch
case。根据开头的字母来启动上面的某个辅助lex函数：</p>
<ol>
<li>
<p>0 这个是EOF符号，直接调用LexEndOfFile即可。</p>
</li>
<li>
<p>26 也就是\^ z字符，这个是很老的一种行尾符号，跟上面流程一样。</p>
</li>
<li>
<p>换行符相关，这里会直接终止当前行的预处理导言的处理。</p>
</li>
<li>
<p>空白符号，这里如果后面接着注释末尾，则直接把后面的注释符号吃掉，其实就是为了加速处理。</p>
</li>
<li>
<p>0-9 的数字, 调用LexNumericConstant</p>
</li>
<li>
<p>u，这里会根据当前标准对字符串开头的编码标识来选择的将这个u归类为开始处理utf16的string
    literal还是归类为普通的identifier的开头</p>
</li>
<li>
<p>U，跟上一个一样，只不过是UTF 32。</p>
</li>
<li>
<p>R，根据语言选项来处理无编码的Raw string Literal 或者identifier</p>
</li>
<li>
<p>L，这里也会涉及到是否是字符常量还是identifier的判断</p>
</li>
<li>
<p>其他可以用在identifier里的字母，调用LexIdentifier</p>
</li>
<li>
<p>‘ , 字符常量，LexCharConstant</p>
</li>
<li>
<p>"， 字符串常量，LexStringLiteral</p>
</li>
<li>
<p>?[]()，直接标识为普通标点符号</p>
</li>
<li>
<p>., 可能是LexNumericConstant</p>
</li>
<li>
<p>算数操作符相关的，都需要向后看才能确定符号类型</p>
</li>
<li>
<p>#, 分为了##，#@， # 三种情况</p>
</li>
<li>
<p><span class="math">\(\backslash\)</span>, 可能是UCN，调用tryReadUCN和LexUnicode</p>
</li>
</ol>
<h2 id="459a6f">Token</h2>
<p>也称为词法单元，是将源代码经过操作之后所分隔出来的基本信息单位。在clang中，Token的数据成员如下：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Token</span>
<span class="p">{</span>
    <span class="c1">/// The location of the token. This is actually a SourceLocation.</span>
    <span class="kt">unsigned</span> <span class="n">Loc</span><span class="p">;</span>

    <span class="c1">/// UintData - This holds either the length of the token text, when</span>
    <span class="c1">/// a normal token, or the end of the SourceRange when an annotation</span>
    <span class="c1">/// token.</span>
    <span class="c1">// 话说没必要啊，长度加偏移不就是end了么</span>
    <span class="kt">unsigned</span> <span class="n">UintData</span><span class="p">;</span>

    <span class="c1">/// PtrData - This is a union of four different pointer types, which depends</span>
    <span class="c1">/// on what type of token this is:</span>
    <span class="c1">///  Identifiers, keywords, etc:</span>
    <span class="c1">///    This is an IdentifierInfo*, which contains the uniqued identifier</span>
    <span class="c1">///    spelling.</span>
    <span class="c1">///  Literals:  isLiteral() returns true.</span>
    <span class="c1">///    This is a pointer to the start of the token in a text buffer, which</span>
    <span class="c1">///    may be dirty (have trigraphs / escaped newlines).</span>
    <span class="c1">///  Annotations (resolved type names, C++ scopes, etc): isAnnotation().</span>
    <span class="c1">///    This is a pointer to sema-specific data for the annotation token.</span>
    <span class="c1">///  Eof:</span>
    <span class="c1">//     This is a pointer to a Decl.</span>
    <span class="c1">///  Other:</span>
    <span class="c1">///    This is null.</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">PtrData</span><span class="p">;</span>

    <span class="c1">/// Kind - The actual flavor of token this is.</span>
    <span class="n">tok</span><span class="o">::</span><span class="n">TokenKind</span> <span class="n">Kind</span><span class="p">;</span>

    <span class="c1">/// Flags - Bits we track about this token, members of the TokenFlags enum.</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">Flags</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>需要注意的是这里的相关信息，主要包括如下几类：</p>
<ol>
<li>
<p>Identifier 或者Keywords；</p>
</li>
<li>
<p>Literal，这个是常量值，包括字符常量、字符串常量、数值常量等；</p>
</li>
<li>
<p>Annotations，这个包含的东西比较杂，如名字空间，带限定的类型说明，特化模板函数以及decltype等，剩下的就都是pragma。</p>
</li>
<li>
<p>eof，代表结尾。</p>
</li>
</ol>
<p>对于TokenKind的完整定义参见TokenKinds.def，这里把宏处理用的天花乱坠！</p>
<p>同时，这里的代表的是一个压缩的枚举标记，他的值由这些枚举值确定：</p>
<div class="codehilite"><pre><span></span><span class="c1">// Various flags set per token:</span>
<span class="k">enum</span> <span class="n">TokenFlags</span>
<span class="p">{</span>
    <span class="n">StartOfLine</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>  <span class="c1">// At start of line or only after whitespace</span>
   <span class="c1">// (considering the line after macro expansion).</span>
    <span class="n">LeadingSpace</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>  <span class="c1">// Whitespace exists before this token (considering </span>
   <span class="c1">// whitespace after macro expansion).</span>
    <span class="n">DisableExpand</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>  <span class="c1">// This identifier may never be macro expanded.</span>
    <span class="n">NeedsCleaning</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>  <span class="c1">// Contained an escaped newline or trigraph.</span>
    <span class="n">LeadingEmptyMacro</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span> <span class="c1">// Empty macro exists before this token.</span>
    <span class="n">HasUDSuffix</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>    <span class="c1">// This string or character literal has a ud-suffix.</span>
    <span class="n">HasUCN</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">,</span>         <span class="c1">// This identifier contains a UCN.</span>
    <span class="n">IgnoredComma</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">,</span>   <span class="c1">// This comma is not a macro argument separator (MS).</span>
    <span class="n">StringifiedInMacro</span> <span class="o">=</span> <span class="mh">0x100</span><span class="p">,</span> <span class="c1">// This string or character literal is formed by</span>
                                <span class="c1">// macro stringizing or charizing operator.</span>
<span class="p">};</span>
</pre></div>


<p>这里绝大部分的标志都是用来处理Macro展开的。具体的意义需要参考C99中关于宏展开的章节来看，此外这里的代码还考虑了GCC和MSVC的各种预处理扩展。</p>
<h1 id="fbe6a1">预处理辅助结构</h1>
<p>在预处理阶段，需要做头文件插入和宏展开操作。为了处理这些操作，clang提供了多个辅助结构：</p>
<ol>
<li>
<p>符号管理 用来处理Identifier</p>
</li>
<li>
<p>头文件管理 用来处理头文件的插入</p>
</li>
<li>
<p>宏管理 用来处理宏展开</p>
</li>
</ol>
<h1 id="4985e4">头文件管理</h1>
<h2 id="028d64">Multiple Include Optimization</h2>
<p>这个文件处理的是头文件的多次插入的情况，这里的主要管理信息包括如下几个：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief Implements the simple state machine that the Lexer class uses to</span>
<span class="c1">/// detect files subject to the &#39;multiple-include&#39; optimization.</span>
<span class="c1">///</span>
<span class="c1">/// The public methods in this class are triggered by various</span>
<span class="c1">/// events that occur when a file is lexed, and after the entire file is lexed,</span>
<span class="c1">/// information about which macro (if any) controls the header is returned.</span>
<span class="k">class</span> <span class="nc">MultipleIncludeOpt</span>
<span class="p">{</span>
    <span class="c1">/// ReadAnyTokens - This is set to false when a file is first opened and true</span>
    <span class="c1">/// any time a token is returned to the client or a (non-multiple-include)</span>
    <span class="c1">/// directive is parsed.  When the final \#endif is parsed this is reset back</span>
    <span class="c1">/// to false, that way any tokens before the first \#ifdef or after the last</span>
    <span class="c1">/// \#endif can be easily detected.</span>
    <span class="kt">bool</span> <span class="n">ReadAnyTokens</span><span class="p">;</span>

    <span class="c1">/// ImmediatelyAfterTopLevelIfndef - This is true when the only tokens</span>
    <span class="c1">/// processed in the file so far is an #ifndef and an identifier.  Used in</span>
    <span class="c1">/// the detection of header guards in a file.</span>
    <span class="kt">bool</span> <span class="n">ImmediatelyAfterTopLevelIfndef</span><span class="p">;</span>

    <span class="c1">/// ReadAnyTokens - This is set to false when a file is first opened and true</span>
    <span class="c1">/// any time a token is returned to the client or a (non-multiple-include)</span>
    <span class="c1">/// directive is parsed.  When the final #endif is parsed this is reset back</span>
    <span class="c1">/// to false, that way any tokens before the first #ifdef or after the last</span>
    <span class="c1">/// #endif can be easily detected.</span>
    <span class="kt">bool</span> <span class="n">DidMacroExpansion</span><span class="p">;</span>

    <span class="c1">/// TheMacro - The controlling macro for a file, if valid.</span>
    <span class="c1">///</span>
    <span class="k">const</span> <span class="n">IdentifierInfo</span> <span class="o">*</span><span class="n">TheMacro</span><span class="p">;</span>

    <span class="c1">/// DefinedMacro - The macro defined right after TheMacro, if any.</span>
    <span class="k">const</span> <span class="n">IdentifierInfo</span> <span class="o">*</span><span class="n">DefinedMacro</span><span class="p">;</span>

    <span class="n">SourceLocation</span> <span class="n">MacroLoc</span><span class="p">;</span>
    <span class="n">SourceLocation</span> <span class="n">DefinedLoc</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<ol>
<li>
<p>ReadAnyTokens用来检测在Header Guard之外的词法单元。一个文件在打开时设置这个值为false，在lex过程中返回了一个token之后设置为true，在遇到#endif之后再设置为false。</p>
</li>
<li>
<p>ImmediatelyAfterTopLevelIfndef用来表明我们刚处理了#ifndef Header Guard。</p>
</li>
<li>
<p>DidMacroExpansion这个字段表示的是我们处理Header Guard对应#ifnd的期间是否进行了宏展开。如果进行了宏展开那就说明，那就说明当前Header Guard无法使用。</p>
</li>
<li>
<p>TheMacro代表的是Header Guar的那个宏，这命名跟The One一样啊。</p>
</li>
<li>
<p>DefinedMacro这个是在#ifnde后面的那个，如果没有#define就为空。</p>
</li>
</ol>
<p>在初始化的时候，我们必须保守的设置这些值：</p>
<div class="codehilite"><pre><span></span><span class="n">MultipleIncludeOpt</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ReadAnyTokens</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">ImmediatelyAfterTopLevelIfndef</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">DidMacroExpansion</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">TheMacro</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">DefinedMacro</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>如果我们发现当前文件无法使用Header Guard，则标记一下：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// Invalidate - Permanently mark this file as not being suitable for the</span>
<span class="c1">/// include-file optimization.</span>
<span class="kt">void</span> <span class="nf">Invalidate</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// If we have read tokens but have no controlling macro, the state-machine</span>
    <span class="c1">// below can never &quot;accept&quot;.</span>
    <span class="n">ReadAnyTokens</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">ImmediatelyAfterTopLevelIfndef</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">DefinedMacro</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">TheMacro</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>然后整个Invalidate过程是由下面两个状态机函数控制的。一个是EnterTopLevelIfndef:</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief Called when entering a top-level \#ifndef directive (or the</span>
<span class="c1">/// &quot;\#if !defined&quot; equivalent) without any preceding tokens.</span>
<span class="c1">///</span>
<span class="c1">/// Note, we don&#39;t care about the input value of &#39;ReadAnyTokens&#39;.  The caller</span>
<span class="c1">/// ensures that this is only called if there are no tokens read before the</span>
<span class="c1">/// \#ifndef.  The caller is required to do this, because reading the \#if</span>
<span class="c1">/// line obviously reads in in tokens.</span>
<span class="kt">void</span> <span class="nf">EnterTopLevelIfndef</span><span class="p">(</span><span class="k">const</span> <span class="n">IdentifierInfo</span> <span class="o">*</span><span class="n">M</span><span class="p">,</span> <span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// If the macro is already set, this is after the top-level #endif.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">TheMacro</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Invalidate</span><span class="p">();</span>

    <span class="c1">// If we have already expanded a macro by the end of the #ifndef line, then</span>
    <span class="c1">// there is a macro expansion *in* the #ifndef line.  This means that the</span>
    <span class="c1">// condition could evaluate differently when subsequently #included.  Reject</span>
    <span class="c1">// this.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">DidMacroExpansion</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Invalidate</span><span class="p">();</span>

    <span class="c1">// Remember that we&#39;re in the #if and that we have the macro.</span>
    <span class="n">ReadAnyTokens</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">ImmediatelyAfterTopLevelIfndef</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">TheMacro</span> <span class="o">=</span> <span class="n">M</span><span class="p">;</span>
    <span class="n">MacroLoc</span> <span class="o">=</span> <span class="n">Loc</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>另外一个是ExitTopLevelConditional:</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief Called when the lexer exits the top-level conditional.</span>
<span class="kt">void</span> <span class="nf">ExitTopLevelConditional</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// If we have a macro, that means the top of the file was ok.  Set our state</span>
    <span class="c1">// back to &quot;not having read any tokens&quot; so we can detect anything after the</span>
    <span class="c1">// #endif.</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TheMacro</span><span class="p">)</span> <span class="k">return</span> <span class="n">Invalidate</span><span class="p">();</span>

    <span class="c1">// At this point, we haven&#39;t &quot;read any tokens&quot; but we do have a controlling</span>
    <span class="c1">// macro.</span>
    <span class="n">ReadAnyTokens</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">ImmediatelyAfterTopLevelIfndef</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h2 id="c5d09e">HeaderMap</h2>
<p>这里的类是用来对头文件进行抽象的，代表了Apple header ma的概念，以抹平底层的文件系统。其数据成员如下：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// This class represents an Apple concept known as a &#39;header map&#39;.  To the</span>
<span class="c1">/// \#include file resolution process, it basically acts like a directory of</span>
<span class="c1">/// symlinks to files.  Its advantages are that it is dense and more efficient</span>
<span class="c1">/// to create and process than a directory of symlinks.</span>
<span class="k">class</span> <span class="nc">HeaderMap</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">llvm</span><span class="o">::</span><span class="n">MemoryBuffer</span><span class="o">&gt;</span> <span class="n">FileBuffer</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">NeedsBSwap</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>一个代表文件内存区，一个表明是否需要处理字节序问题（大端或小端）。</p>
<p>在使用时，需要定义其他的结构来辅助HeaderMap的使用:</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">HMapBucket</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">Key</span><span class="p">;</span>          <span class="c1">// Offset (into strings) of key.</span>

    <span class="kt">uint32_t</span> <span class="n">Prefix</span><span class="p">;</span>     <span class="c1">// Offset (into strings) of value prefix.</span>
    <span class="kt">uint32_t</span> <span class="n">Suffix</span><span class="p">;</span>     <span class="c1">// Offset (into strings) of value suffix.</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">HMapHeader</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">Magic</span><span class="p">;</span>           <span class="c1">// Magic word, also indicates byte order.</span>
    <span class="kt">uint16_t</span> <span class="n">Version</span><span class="p">;</span>         <span class="c1">// Version number -- currently 1.</span>
    <span class="kt">uint16_t</span> <span class="n">Reserved</span><span class="p">;</span>        <span class="c1">// Reserved for future use - zero for now.</span>
    <span class="kt">uint32_t</span> <span class="n">StringsOffset</span><span class="p">;</span>   <span class="c1">// Offset to start of string pool.</span>
    <span class="kt">uint32_t</span> <span class="n">NumEntries</span><span class="p">;</span>      <span class="c1">// Number of entries in the string table.</span>
    <span class="kt">uint32_t</span> <span class="n">NumBuckets</span><span class="p">;</span>      <span class="c1">// Number of buckets (always a power of 2).</span>
    <span class="kt">uint32_t</span> <span class="n">MaxValueLength</span><span class="p">;</span>  <span class="c1">// Length of longest result path (excluding nul).</span>
    <span class="c1">// An array of &#39;NumBuckets&#39; HMapBucket objects follows this header.</span>
    <span class="c1">// Strings follow the buckets, at StringsOffset.</span>
<span class="p">};</span>
</pre></div>


<p>这里的HMapHeader代表的是HeadMap序列化之后的文件头，如果从FileEntry反序列化出HeaderMap的话，首先判断这个文件开始的那些字节是否是一个合法的HMapHeader。这里有一个Magic和Version，他们的值定义在一个枚举之中：</p>
<div class="codehilite"><pre><span></span><span class="k">enum</span>
<span class="p">{</span>
    <span class="n">HMAP_HeaderMagicNumber</span> <span class="o">=</span> <span class="p">(</span><span class="sc">&#39;h&#39;</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="sc">&#39;m&#39;</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="sc">&#39;a&#39;</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="sc">&#39;p&#39;</span><span class="p">,</span>
    <span class="n">HMAP_HeaderVersion</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

    <span class="n">HMAP_EmptyBucketKey</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">};</span>
</pre></div>


<p>所以HeaderMap的静态构造函数可以以下方式实现，首先判断文件大小是否能够保存一个HMapHeader，然后就是版本号和MagicNumber的比较：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// HeaderMap::Create - This attempts to load the specified file as a header</span>
<span class="c1">/// map.  If it doesn&#39;t look like a HeaderMap, it gives up and returns null.</span>
<span class="c1">/// If it looks like a HeaderMap but is obviously corrupted, it puts a reason</span>
<span class="c1">/// into the string error argument and returns null.</span>
<span class="k">const</span> <span class="n">HeaderMap</span> <span class="o">*</span><span class="n">HeaderMap</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="k">const</span> <span class="n">FileEntry</span> <span class="o">*</span><span class="n">FE</span><span class="p">,</span> <span class="n">FileManager</span> <span class="o">&amp;</span><span class="n">FM</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// If the file is too small to be a header map, ignore it.</span>
    <span class="kt">unsigned</span> <span class="n">FileSize</span> <span class="o">=</span> <span class="n">FE</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FileSize</span> <span class="o">&lt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HMapHeader</span><span class="p">))</span> <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="k">auto</span> <span class="n">FileBuffer</span> <span class="o">=</span> <span class="n">FM</span><span class="p">.</span><span class="n">getBufferForFile</span><span class="p">(</span><span class="n">FE</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FileBuffer</span><span class="p">)</span> <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>  <span class="c1">// Unreadable file?</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">FileStart</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">FileBuffer</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getBufferStart</span><span class="p">();</span>

    <span class="c1">// We know the file is at least as big as the header, check it now.</span>
    <span class="k">const</span> <span class="n">HMapHeader</span> <span class="o">*</span><span class="n">Header</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">HMapHeader</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">FileStart</span><span class="p">);</span>

    <span class="c1">// Sniff it to see if it&#39;s a headermap by checking the magic number and</span>
    <span class="c1">// version.</span>
    <span class="kt">bool</span> <span class="n">NeedsByteSwap</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Header</span><span class="o">-&gt;</span><span class="n">Magic</span> <span class="o">==</span> <span class="n">HMAP_HeaderMagicNumber</span> <span class="o">&amp;&amp;</span>
    <span class="n">Header</span><span class="o">-&gt;</span><span class="n">Version</span> <span class="o">==</span> <span class="n">HMAP_HeaderVersion</span><span class="p">)</span>
    <span class="n">NeedsByteSwap</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">Header</span><span class="o">-&gt;</span><span class="n">Magic</span> <span class="o">==</span> <span class="n">llvm</span><span class="o">::</span><span class="n">ByteSwap_32</span><span class="p">(</span><span class="n">HMAP_HeaderMagicNumber</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
    <span class="n">Header</span><span class="o">-&gt;</span><span class="n">Version</span> <span class="o">==</span> <span class="n">llvm</span><span class="o">::</span><span class="n">ByteSwap_16</span><span class="p">(</span><span class="n">HMAP_HeaderVersion</span><span class="p">))</span>
    <span class="n">NeedsByteSwap</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>  <span class="c1">// Mixed endianness headermap.</span>
    <span class="k">else</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>  <span class="c1">// Not a header map.</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Header</span><span class="o">-&gt;</span><span class="n">Reserved</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="c1">// Okay, everything looks good, create the header map.</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">HeaderMap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">FileBuffer</span><span class="p">),</span> <span class="n">NeedsByteSwap</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>在这个HeaderMap中存储的是一个HashMap，这个哈希表中基本单位为HMapBucket，其结构定义如下。</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">HMapBucket</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">Key</span><span class="p">;</span>          <span class="c1">// Offset (into strings) of key.</span>

    <span class="kt">uint32_t</span> <span class="n">Prefix</span><span class="p">;</span>     <span class="c1">// Offset (into strings) of value prefix.</span>
    <span class="kt">uint32_t</span> <span class="n">Suffix</span><span class="p">;</span>     <span class="c1">// Offset (into strings) of value suffix.</span>
<span class="p">};</span>
</pre></div>


<p>此时基本单元的获取函数如下，很简单，就是首先获取哈希表的偏移，然后加上索引偏移，判断是否越界：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// getBucket - Return the specified hash table bucket from the header map,</span>
<span class="c1">/// bswap&#39;ing its fields as appropriate.  If the bucket number is not valid,</span>
<span class="c1">/// this return a bucket with an empty key (0).</span>
<span class="n">HMapBucket</span> <span class="n">HeaderMap</span><span class="o">::</span><span class="n">getBucket</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">BucketNo</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">HMapBucket</span> <span class="n">Result</span><span class="p">;</span>
    <span class="n">Result</span><span class="p">.</span><span class="n">Key</span> <span class="o">=</span> <span class="n">HMAP_EmptyBucketKey</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">HMapBucket</span> <span class="o">*</span><span class="n">BucketArray</span> <span class="o">=</span>
    <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">HMapBucket</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">FileBuffer</span><span class="o">-&gt;</span><span class="n">getBufferStart</span><span class="p">()</span> <span class="o">+</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">HMapHeader</span><span class="p">));</span>

    <span class="k">const</span> <span class="n">HMapBucket</span> <span class="o">*</span><span class="n">BucketPtr</span> <span class="o">=</span> <span class="n">BucketArray</span> <span class="o">+</span> <span class="n">BucketNo</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="n">BucketPtr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">FileBuffer</span><span class="o">-&gt;</span><span class="n">getBufferEnd</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">Result</span><span class="p">.</span><span class="n">Prefix</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">Result</span><span class="p">.</span><span class="n">Suffix</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>  <span class="c1">// Invalid buffer, corrupt hmap.</span>
    <span class="p">}</span>

    <span class="c1">// Otherwise, the bucket is valid.  Load the values, bswapping as needed.</span>
    <span class="n">Result</span><span class="p">.</span><span class="n">Key</span> <span class="o">=</span> <span class="n">getEndianAdjustedWord</span><span class="p">(</span><span class="n">BucketPtr</span><span class="o">-&gt;</span><span class="n">Key</span><span class="p">);</span>
    <span class="n">Result</span><span class="p">.</span><span class="n">Prefix</span> <span class="o">=</span> <span class="n">getEndianAdjustedWord</span><span class="p">(</span><span class="n">BucketPtr</span><span class="o">-&gt;</span><span class="n">Prefix</span><span class="p">);</span>
    <span class="n">Result</span><span class="p">.</span><span class="n">Suffix</span> <span class="o">=</span> <span class="n">getEndianAdjustedWord</span><span class="p">(</span><span class="n">BucketPtr</span><span class="o">-&gt;</span><span class="n">Suffix</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>整个HeaderMap相当于把头文件目录中的子文件名都存储于内存之中，这样每次查询头文件位置的时候就没有必要去访问文件系统了。在HeaderMap中查找一个文件名是否存在可以这样实现，就是一个简单hash的查询。：</p>
<div class="codehilite"><pre><span></span><span class="n">StringRef</span> <span class="n">HeaderMap</span><span class="o">::</span><span class="n">lookupFilename</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Filename</span><span class="p">,</span>
<span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">DestPath</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">HMapHeader</span> <span class="o">&amp;</span><span class="n">Hdr</span> <span class="o">=</span> <span class="n">getHeader</span><span class="p">();</span>
    <span class="kt">unsigned</span> <span class="n">NumBuckets</span> <span class="o">=</span> <span class="n">getEndianAdjustedWord</span><span class="p">(</span><span class="n">Hdr</span><span class="p">.</span><span class="n">NumBuckets</span><span class="p">);</span>

    <span class="c1">// If the number of buckets is not a power of two, the headermap is corrupt.</span>
    <span class="c1">// Don&#39;t probe infinitely.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">NumBuckets</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">NumBuckets</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">StringRef</span><span class="p">();</span>

    <span class="c1">// Linearly probe the hash table.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">Bucket</span> <span class="o">=</span> <span class="n">HashHMapKey</span><span class="p">(</span><span class="n">Filename</span><span class="p">);;</span> <span class="o">++</span><span class="n">Bucket</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">HMapBucket</span> <span class="n">B</span> <span class="o">=</span> <span class="n">getBucket</span><span class="p">(</span><span class="n">Bucket</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">NumBuckets</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">Key</span> <span class="o">==</span> <span class="n">HMAP_EmptyBucketKey</span><span class="p">)</span> <span class="k">return</span> <span class="n">StringRef</span><span class="p">();</span> <span class="c1">// Hash miss.</span>

        <span class="c1">// See if the key matches.  If not, probe on.</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Filename</span><span class="p">.</span><span class="n">equals_lower</span><span class="p">(</span><span class="n">getString</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">Key</span><span class="p">)))</span>
        <span class="k">continue</span><span class="p">;</span>

        <span class="c1">// If so, we have a match in the hash table.  Construct the destination</span>
        <span class="c1">// path.</span>
        <span class="n">StringRef</span> <span class="n">Prefix</span> <span class="o">=</span> <span class="n">getString</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">Prefix</span><span class="p">);</span>
        <span class="n">StringRef</span> <span class="n">Suffix</span> <span class="o">=</span> <span class="n">getString</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">Suffix</span><span class="p">);</span>
        <span class="n">DestPath</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="n">DestPath</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Prefix</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">Prefix</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        <span class="n">DestPath</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Suffix</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">Suffix</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        <span class="k">return</span> <span class="nf">StringRef</span><span class="p">(</span><span class="n">DestPath</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">DestPath</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h2 id="82fdcc">头文件定位</h2>
<p>头文件定位相关操作在HeaderSearch.h中被描述，里面有一个比较大的类HeaderSearch。一部分一部分的分析吧。</p>
<p>首先是头文件信息相关的结构HeaderFileInfo，里面基本都是一些标志位：</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">HeaderFileInfo</span>
<span class="p">{</span>
    <span class="c1">/// \brief True if this is a \#import&#39;d or \#pragma once file.</span>
    <span class="kt">unsigned</span> <span class="nl">isImport</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">/// \brief True if this is a \#pragma once file.</span>
    <span class="kt">unsigned</span> <span class="nl">isPragmaOnce</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">/// DirInfo - Keep track of whether this is a system header, and if so,</span>
    <span class="c1">/// whether it is C++ clean or not.  This can be set by the include paths or</span>
    <span class="c1">/// by \#pragma gcc system_header.  This is an instance of</span>
    <span class="c1">/// SrcMgr::CharacteristicKind.</span>
    <span class="kt">unsigned</span> <span class="nl">DirInfo</span> <span class="p">:</span> <span class="mi">2</span><span class="p">;</span>

    <span class="c1">/// \brief Whether this header file info was supplied by an external source,</span>
    <span class="c1">/// and has not changed since.</span>
    <span class="kt">unsigned</span> <span class="nl">External</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">/// \brief Whether this header is part of a module.</span>
    <span class="kt">unsigned</span> <span class="nl">isModuleHeader</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">/// \brief Whether this header is part of the module that we are building.</span>
    <span class="kt">unsigned</span> <span class="nl">isCompilingModuleHeader</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">/// \brief Whether this structure is considered to already have been</span>
    <span class="c1">/// &quot;resolved&quot;, meaning that it was loaded from the external source.</span>
    <span class="kt">unsigned</span> <span class="nl">Resolved</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">/// \brief Whether this is a header inside a framework that is currently</span>
    <span class="c1">/// being built. </span>
    <span class="c1">///</span>
    <span class="c1">/// When a framework is being built, the headers have not yet been placed</span>
    <span class="c1">/// into the appropriate framework subdirectories, and therefore are</span>
    <span class="c1">/// provided via a header map. This bit indicates when this is one of</span>
    <span class="c1">/// those framework headers.</span>
    <span class="kt">unsigned</span> <span class="nl">IndexHeaderMapHeader</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">/// \brief Whether this file has been looked up as a header.</span>
    <span class="kt">unsigned</span> <span class="nl">IsValid</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">/// \brief The number of times the file has been included already.</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">NumIncludes</span><span class="p">;</span>

    <span class="c1">/// \brief The ID number of the controlling macro.</span>
    <span class="c1">///</span>
    <span class="c1">/// This ID number will be non-zero when there is a controlling</span>
    <span class="c1">/// macro whose IdentifierInfo may not yet have been loaded from</span>
    <span class="c1">/// external storage.</span>
    <span class="kt">unsigned</span> <span class="n">ControllingMacroID</span><span class="p">;</span>

    <span class="c1">/// If this file has a \#ifndef XXX (or equivalent) guard that</span>
    <span class="c1">/// protects the entire contents of the file, this is the identifier</span>
    <span class="c1">/// for the macro that controls whether or not it has any effect.</span>
    <span class="c1">///</span>
    <span class="c1">/// Note: Most clients should use getControllingMacro() to access</span>
    <span class="c1">/// the controlling macro of this header, since</span>
    <span class="c1">/// getControllingMacro() is able to load a controlling macro from</span>
    <span class="c1">/// external storage.</span>
    <span class="k">const</span> <span class="n">IdentifierInfo</span> <span class="o">*</span><span class="n">ControllingMacro</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>比较特殊的就是ControllingMacro，也就是常说的Header Guard。</p>
<p>该文件剩下的内容就是HeaderSearch相关的内容了，里面有很多我们并不需要的字段，因此只看重点：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \#include search path information.  Requests for \#include &quot;x&quot; search the</span>
<span class="c1">/// directory of the \#including file first, then each directory in SearchDirs</span>
<span class="c1">/// consecutively. Requests for &lt;x&gt; search the current dir first, then each</span>
<span class="c1">/// directory in SearchDirs, starting at AngledDirIdx, consecutively.  If</span>
<span class="c1">/// NoCurDirSearch is true, then the check for the file in the current</span>
<span class="c1">/// directory is suppressed.</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">DirectoryLookup</span><span class="o">&gt;</span> <span class="n">SearchDirs</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="n">AngledDirIdx</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="n">SystemDirIdx</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">NoCurDirSearch</span><span class="p">;</span>
</pre></div>


<p>注释里面把搜索逻辑已经描述清楚了，所有的头文件路径存储于SearchDirs，相当于AngleDir系统头文件路径的开始索引。</p>
<p>其他比较重要的东西就是所有的头文件信息和头文件与FileEntry的映射：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief All of the preprocessor-specific data about files that are</span>
<span class="c1">/// included, indexed by the FileEntry&#39;s UID.</span>
<span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">HeaderFileInfo</span><span class="o">&gt;</span> <span class="n">FileInfo</span><span class="p">;</span>
<span class="c1">/// HeaderMaps - This is a mapping from FileEntry -&gt; HeaderMap, uniquing</span>
<span class="c1">/// headermaps.  This vector owns the headermap.</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">FileEntry</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">HeaderMap</span><span class="o">*&gt;</span> <span class="o">&gt;</span> <span class="n">HeaderMaps</span><span class="p">;</span>
</pre></div>


<p>剩下的都是Module和Framework以及Statistic相关的内容，不是核心问题，故略去。</p>
<p>真正的核心问题是查询函数：</p>
<div class="codehilite"><pre><span></span><span class="k">const</span> <span class="n">FileEntry</span> <span class="o">*</span><span class="nf">LookupFile</span><span class="p">(</span>
<span class="n">StringRef</span> <span class="n">Filename</span><span class="p">,</span> <span class="n">SourceLocation</span> <span class="n">IncludeLoc</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isAngled</span><span class="p">,</span>
<span class="k">const</span> <span class="n">DirectoryLookup</span> <span class="o">*</span><span class="n">FromDir</span><span class="p">,</span> <span class="k">const</span> <span class="n">DirectoryLookup</span> <span class="o">*&amp;</span><span class="n">CurDir</span><span class="p">,</span>
<span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">FileEntry</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">DirectoryEntry</span> <span class="o">*&gt;&gt;</span> <span class="n">Includers</span><span class="p">,</span>
<span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">SearchPath</span><span class="p">,</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">RelativePath</span><span class="p">,</span>
<span class="n">Module</span> <span class="o">*</span><span class="n">RequestingModule</span><span class="p">,</span> <span class="n">ModuleMap</span><span class="o">::</span><span class="n">KnownHeader</span> <span class="o">*</span><span class="n">SuggestedModule</span><span class="p">,</span>
<span class="kt">bool</span> <span class="n">SkipCache</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</pre></div>


<p>这个函数相关的说明也是非常的长，大概有300多行实现代码。首先是判断文件路径是不是绝对路径，如果是绝对路径则直接判断该路径是否存在：</p>
<div class="codehilite"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">sys</span><span class="o">::</span><span class="n">path</span><span class="o">::</span><span class="n">is_absolute</span><span class="p">(</span><span class="n">Filename</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">CurDir</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="c1">// If this was an #include_next &quot;/absolute/file&quot;, fail.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FromDir</span><span class="p">)</span> <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">SearchPath</span><span class="p">)</span>
    <span class="n">SearchPath</span><span class="o">-&gt;</span><span class="n">clear</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">RelativePath</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">RelativePath</span><span class="o">-&gt;</span><span class="n">clear</span><span class="p">();</span>
        <span class="n">RelativePath</span><span class="o">-&gt;</span><span class="n">append</span><span class="p">(</span><span class="n">Filename</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">Filename</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="c1">// Otherwise, just return the file.</span>
    <span class="k">return</span> <span class="n">getFileAndSuggestModule</span><span class="p">(</span><span class="n">Filename</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span>
    <span class="cm">/*IsSystemHeaderDir*/</span><span class="nb">false</span><span class="p">,</span>
    <span class="n">RequestingModule</span><span class="p">,</span> <span class="n">SuggestedModule</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>如果是相对路径，则需要区分是否是尖括号头文件还是双引号头文件。如果是双引号头文件，则需要在所有头文件的路径中递归子文件夹来查找，而尖括号头文件则不需要在子文件夹中递归查找。</p>
<p>如果是尖括号头文件搜索，则还需要考虑微软的include_next扩展，具体的执行流程我们就不去深究了。</p>
<p>对于framework和module的支持当前我就先不考虑，目前不感兴趣。</p>
<h1 id="d72670">预编译头文件</h1>
<h2 id="a7d57d">PTH 文件格式</h2>
<p>这个PTH文件还有一个功能就是建立FileEntry与PTH offset之间的映射，实际映射时使用的都是uint32_t，所以里面存储的信息也是这样的：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">PTHFileData</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">TokenOff</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">PPCondOff</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>很简单，就两个索引字段，完整的信息需要配合文件管理器才能解释。读取文件的时候也非常简单：</p>
<div class="codehilite"><pre><span></span><span class="k">static</span> <span class="n">PTHFileData</span> <span class="nf">ReadData</span><span class="p">(</span><span class="k">const</span> <span class="n">internal_key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">d</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">k</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="mh">0x1</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Only file lookups can match!&quot;</span><span class="p">);</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">x</span> <span class="o">=</span> <span class="n">endian</span><span class="o">::</span><span class="n">readNext</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">little</span><span class="p">,</span> <span class="n">unaligned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
    <span class="kt">uint32_t</span> <span class="n">y</span> <span class="o">=</span> <span class="n">endian</span><span class="o">::</span><span class="n">readNext</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">little</span><span class="p">,</span> <span class="n">unaligned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">PTHFileData</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h2 id="fd1ea3">PTHLexer</h2>
<p>这个文件是用来处理Pre Tokenized input的，也就是用来处理预编译头文件！最重要的是，这个类继承自PreprocessorLexer:</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">PTHLexer</span> <span class="o">:</span> <span class="k">public</span> <span class="n">PreprocessorLexer</span>
<span class="p">{</span>
    <span class="n">SourceLocation</span> <span class="n">FileStartLoc</span><span class="p">;</span>

    <span class="c1">/// TokBuf - Buffer from PTH file containing raw token data.</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">TokBuf</span><span class="p">;</span>

    <span class="c1">/// CurPtr - Pointer into current offset of the token buffer where</span>
    <span class="c1">///  the next token will be read.</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">CurPtr</span><span class="p">;</span>

    <span class="c1">/// LastHashTokPtr - Pointer into TokBuf of the last processed &#39;#&#39;</span>
    <span class="c1">///  token that appears at the start of a line.</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">LastHashTokPtr</span><span class="p">;</span>

    <span class="c1">/// PPCond - Pointer to a side table in the PTH file that provides a</span>
    <span class="c1">///  a consise summary of the preproccessor conditional block structure.</span>
    <span class="c1">///  This is used to perform quick skipping of conditional blocks.</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">PPCond</span><span class="p">;</span>

    <span class="c1">/// CurPPCondPtr - Pointer inside PPCond that refers to the next entry</span>
    <span class="c1">///  to process when doing quick skipping of preprocessor blocks.</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">CurPPCondPtr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这个类是用来处理Pretokenized Header的，这个文件格式是llvm自己设计的。所以我这也不想说太多只对PTH有效的功能，毕竟不是标准里面的东西。</p>
<p>当前头文件的实现文件约有900行，挑重点的几个函数说一下。以难易程度来说，最简单的是LexEndOfFile：</p>
<div class="codehilite"><pre><span></span><span class="kt">bool</span> <span class="n">PTHLexer</span><span class="o">::</span><span class="n">LexEndOfFile</span><span class="p">(</span><span class="n">Token</span> <span class="o">&amp;</span><span class="n">Result</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// If we hit the end of the file while parsing a preprocessor directive,</span>
    <span class="c1">// end the preprocessor directive first.  The next token returned will</span>
    <span class="c1">// then be the end of file.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ParsingPreprocessorDirective</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ParsingPreprocessorDirective</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Done parsing the &quot;line&quot;.</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>  <span class="c1">// Have a token.</span>
    <span class="p">}</span>

    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">LexingRawMode</span><span class="p">);</span>

    <span class="c1">// If we are in a #if directive, emit an error.</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ConditionalStack</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">PP</span><span class="o">-&gt;</span><span class="n">getCodeCompletionFileLoc</span><span class="p">()</span> <span class="o">!=</span> <span class="n">FileStartLoc</span><span class="p">)</span>
        <span class="n">PP</span><span class="o">-&gt;</span><span class="n">Diag</span><span class="p">(</span><span class="n">ConditionalStack</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">IfLoc</span><span class="p">,</span>
        <span class="n">diag</span><span class="o">::</span><span class="n">err_pp_unterminated_conditional</span><span class="p">);</span>
        <span class="n">ConditionalStack</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// Finally, let the preprocessor handle this.</span>
    <span class="k">return</span> <span class="n">PP</span><span class="o">-&gt;</span><span class="n">HandleEndOfFile</span><span class="p">(</span><span class="n">Result</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>这个函数处理的是：如果我们走到了一个文件的末尾怎么处理的问题。返回值用来表示我们是否应该继续调用Lex函数来获得下一个Token。如果在处理预处理导言（#line）时到了文件末尾，直接返回真。如果当前的条件编译栈中还有#if，向错误诊断中报告相应信息，并持续弹出。然后我们让预处理器来处理EOF问题，其签名如下：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief Callback invoked when the lexer hits the end of the current file.</span>
<span class="c1">///</span>
<span class="c1">/// This either returns the EOF token and returns true, or</span>
<span class="c1">/// pops a level off the include stack and returns false, at which point the</span>
<span class="c1">/// client should call lex again.</span>
<span class="kt">bool</span> <span class="nf">HandleEndOfFile</span><span class="p">(</span><span class="n">Token</span> <span class="o">&amp;</span><span class="n">Result</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isEndOfMacro</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</pre></div>


<p>这个函数的大意就是进行头文件栈的弹栈，处理过程中我们还可以插入自定义的call_bacl。</p>
<p>处理了这种例外行为之后我们来处理普通的PTH.lex操作，该操作分为多步，第一步是从PTH中获得一个Token的相关信息：</p>
<div class="codehilite"><pre><span></span><span class="c1">//===--------------------------------------==//</span>
<span class="c1">// Read the raw token data.</span>
<span class="c1">//===--------------------------------------==//</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="p">;</span>

<span class="c1">// Shadow CurPtr into an automatic variable.</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">CurPtrShadow</span> <span class="o">=</span> <span class="n">CurPtr</span><span class="p">;</span>

<span class="c1">// Read in the data for the token.</span>
<span class="kt">unsigned</span> <span class="n">Word0</span> <span class="o">=</span> <span class="n">endian</span><span class="o">::</span><span class="n">readNext</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">little</span><span class="p">,</span> <span class="n">aligned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">CurPtrShadow</span><span class="p">);</span>
<span class="kt">uint32_t</span> <span class="n">IdentifierID</span> <span class="o">=</span>
<span class="n">endian</span><span class="o">::</span><span class="n">readNext</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">little</span><span class="p">,</span> <span class="n">aligned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">CurPtrShadow</span><span class="p">);</span>
<span class="kt">uint32_t</span> <span class="n">FileOffset</span> <span class="o">=</span>
<span class="n">endian</span><span class="o">::</span><span class="n">readNext</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">little</span><span class="p">,</span> <span class="n">aligned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">CurPtrShadow</span><span class="p">);</span>

<span class="n">tok</span><span class="o">::</span><span class="n">TokenKind</span> <span class="n">TKind</span> <span class="o">=</span> <span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">TokenKind</span><span class="p">)</span> <span class="p">(</span><span class="n">Word0</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
<span class="n">Token</span><span class="o">::</span><span class="n">TokenFlags</span> <span class="n">TFlags</span> <span class="o">=</span> <span class="p">(</span><span class="n">Token</span><span class="o">::</span><span class="n">TokenFlags</span><span class="p">)</span> <span class="p">((</span><span class="n">Word0</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
<span class="kt">uint32_t</span> <span class="n">Len</span> <span class="o">=</span> <span class="n">Word0</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>

<span class="n">CurPtr</span> <span class="o">=</span> <span class="n">CurPtrShadow</span><span class="p">;</span>
</pre></div>


<p>这里的代码展示了PTH文件的具体实现，三个uint32_t存储了Token的基本信息。剩下的就是根据这些信息构造Token:</p>
<div class="codehilite"><pre><span></span><span class="c1">//===--------------------------------------==//</span>
<span class="c1">// Construct the token itself.</span>
<span class="c1">//===--------------------------------------==//</span>

<span class="n">Tok</span><span class="p">.</span><span class="n">startToken</span><span class="p">();</span>
<span class="n">Tok</span><span class="p">.</span><span class="n">setKind</span><span class="p">(</span><span class="n">TKind</span><span class="p">);</span>
<span class="n">Tok</span><span class="p">.</span><span class="n">setFlag</span><span class="p">(</span><span class="n">TFlags</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">LexingRawMode</span><span class="p">);</span>
<span class="n">Tok</span><span class="p">.</span><span class="n">setLocation</span><span class="p">(</span><span class="n">FileStartLoc</span><span class="p">.</span><span class="n">getLocWithOffset</span><span class="p">(</span><span class="n">FileOffset</span><span class="p">));</span>
<span class="n">Tok</span><span class="p">.</span><span class="n">setLength</span><span class="p">(</span><span class="n">Len</span><span class="p">);</span>

<span class="c1">// Handle identifiers.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">isLiteral</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">Tok</span><span class="p">.</span><span class="n">setLiteralData</span><span class="p">((</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="n">PTHMgr</span><span class="p">.</span><span class="n">SpellingBase</span> <span class="o">+</span> <span class="n">IdentifierID</span><span class="p">));</span>
<span class="p">}</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IdentifierID</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">MIOpt</span><span class="p">.</span><span class="n">ReadToken</span><span class="p">();</span>
    <span class="n">IdentifierInfo</span> <span class="o">*</span><span class="n">II</span> <span class="o">=</span> <span class="n">PTHMgr</span><span class="p">.</span><span class="n">GetIdentifierInfo</span><span class="p">(</span><span class="n">IdentifierID</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

    <span class="n">Tok</span><span class="p">.</span><span class="n">setIdentifierInfo</span><span class="p">(</span><span class="n">II</span><span class="p">);</span>

    <span class="c1">// Change the kind of this identifier to the appropriate token kind, e.g.</span>
    <span class="c1">// turning &quot;for&quot; into a keyword.</span>
    <span class="n">Tok</span><span class="p">.</span><span class="n">setKind</span><span class="p">(</span><span class="n">II</span><span class="o">-&gt;</span><span class="n">getTokenID</span><span class="p">());</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">II</span><span class="o">-&gt;</span><span class="n">isHandleIdentifierCase</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">PP</span><span class="o">-&gt;</span><span class="n">HandleIdentifier</span><span class="p">(</span><span class="n">Tok</span><span class="p">);</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这个Token所对应的IdentifierInfo是由PTHMgr管理的。</p>
<p>在构造完这个Token之后，我们再进行进一步的处理，主要是处理特殊TokenKind：</p>
<div class="codehilite"><pre><span></span><span class="c1">//===--------------------------------------==//</span>
<span class="c1">// Process the token.</span>
<span class="c1">//===--------------------------------------==//</span>
<span class="k">if</span> <span class="p">(</span><span class="n">TKind</span> <span class="o">==</span> <span class="n">tok</span><span class="o">::</span><span class="n">eof</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Save the end-of-file token.</span>
    <span class="n">EofToken</span> <span class="o">=</span> <span class="n">Tok</span><span class="p">;</span>

    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">ParsingPreprocessorDirective</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">LexingRawMode</span><span class="p">);</span>

    <span class="k">return</span> <span class="nf">LexEndOfFile</span><span class="p">(</span><span class="n">Tok</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">TKind</span> <span class="o">==</span> <span class="n">tok</span><span class="o">::</span><span class="n">hash</span> <span class="o">&amp;&amp;</span> <span class="n">Tok</span><span class="p">.</span><span class="n">isAtStartOfLine</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">LastHashTokPtr</span> <span class="o">=</span> <span class="n">CurPtr</span> <span class="o">-</span> <span class="n">StoredTokenSize</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">LexingRawMode</span><span class="p">);</span>
    <span class="n">PP</span><span class="o">-&gt;</span><span class="n">HandleDirective</span><span class="p">(</span><span class="n">Tok</span><span class="p">);</span>

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">TKind</span> <span class="o">==</span> <span class="n">tok</span><span class="o">::</span><span class="n">eod</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">ParsingPreprocessorDirective</span><span class="p">);</span>
    <span class="n">ParsingPreprocessorDirective</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">MIOpt</span><span class="p">.</span><span class="n">ReadToken</span><span class="p">();</span>
<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</pre></div>


<p>这里的执行流程又调用了预处理器中HandleDirective的，这个是处理#开头的行的，其签名如下：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief Callback invoked when the lexer sees a # token at the start of a</span>
<span class="c1">/// line.</span>
<span class="c1">///</span>
<span class="c1">/// This consumes the directive, modifies the lexer/preprocessor state, and</span>
<span class="c1">/// advances the lexer(s) so that the next token read is the correct one</span>
<span class="kt">void</span> <span class="nf">HandleDirective</span><span class="p">(</span><span class="n">Token</span> <span class="o">&amp;</span><span class="n">Result</span><span class="p">);</span>
</pre></div>


<p>在PTHLexer.cpp中还有一个比较重要的函数，来处理条件编译的跳过。该函数比较长，这里就不贴实现，只贴签名了。</p>
<div class="codehilite"><pre><span></span><span class="c1">/// SkipBlock - Used by Preprocessor to skip the current conditional block.</span>
<span class="kt">bool</span> <span class="n">PTHLexer</span><span class="o">::</span><span class="n">SkipBlock</span><span class="p">()</span>
</pre></div>


<h2 id="d5c82d">PTHManager</h2>
<p>这个PTHManager类似于之前的SourceManager，里面保留了大量的智能指针来管理相关的各种资源。同时提供由String到的IdentifierInfo映射接口，该接口继承自IdentifierInfoLookup类。完整的PTHManager数据成员见下：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">PTHManager</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IdentifierInfoLookup</span>
<span class="p">{</span>

    <span class="k">class</span> <span class="nc">PTHStringLookupTrait</span><span class="p">;</span>
    <span class="k">class</span> <span class="nc">PTHFileLookupTrait</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">llvm</span><span class="o">::</span><span class="n">OnDiskChainedHashTable</span><span class="o">&lt;</span><span class="n">PTHStringLookupTrait</span><span class="o">&gt;</span> <span class="n">PTHStringIdLookup</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">llvm</span><span class="o">::</span><span class="n">OnDiskChainedHashTable</span><span class="o">&lt;</span><span class="n">PTHFileLookupTrait</span><span class="o">&gt;</span> <span class="n">PTHFileLookup</span><span class="p">;</span>

    <span class="c1">/// The memory mapped PTH file.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">llvm</span><span class="o">::</span><span class="n">MemoryBuffer</span><span class="o">&gt;</span> <span class="n">Buf</span><span class="p">;</span>

    <span class="c1">/// Alloc - Allocator used for IdentifierInfo objects.</span>
    <span class="n">llvm</span><span class="o">::</span><span class="n">BumpPtrAllocator</span> <span class="n">Alloc</span><span class="p">;</span>

    <span class="c1">/// IdMap - A lazily generated cache mapping from persistent identifiers to</span>
    <span class="c1">///  IdentifierInfo*.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IdentifierInfo</span> <span class="o">*</span><span class="p">[],</span> <span class="n">llvm</span><span class="o">::</span><span class="n">FreeDeleter</span><span class="o">&gt;</span> <span class="n">PerIDCache</span><span class="p">;</span>

    <span class="c1">/// FileLookup - Abstract data structure used for mapping between files</span>
    <span class="c1">///  and token data in the PTH file.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">PTHFileLookup</span><span class="o">&gt;</span> <span class="n">FileLookup</span><span class="p">;</span>

    <span class="c1">/// IdDataTable - Array representing the mapping from persistent IDs to the</span>
    <span class="c1">///  data offset within the PTH file containing the information to</span>
    <span class="c1">///  reconsitute an IdentifierInfo.</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">IdDataTable</span><span class="p">;</span>

    <span class="c1">/// SortedIdTable - Abstract data structure mapping from strings to</span>
    <span class="c1">///  persistent IDs.  This is used by get().</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">PTHStringIdLookup</span><span class="o">&gt;</span> <span class="n">StringIdLookup</span><span class="p">;</span>

    <span class="c1">/// NumIds - The number of identifiers in the PTH file.</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">NumIds</span><span class="p">;</span>

    <span class="c1">/// PP - The Preprocessor object that will use this PTHManager to create</span>
    <span class="c1">///  PTHLexer objects.</span>
    <span class="n">Preprocessor</span><span class="o">*</span> <span class="n">PP</span><span class="p">;</span>

    <span class="c1">/// SpellingBase - The base offset within the PTH memory buffer that</span>
    <span class="c1">///  contains the cached spellings for literals.</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">SpellingBase</span><span class="p">;</span>

    <span class="c1">/// OriginalSourceFile - A null-terminated C-string that specifies the name</span>
    <span class="c1">///  if the file (if any) that was to used to generate the PTH cache.</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">OriginalSourceFile</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里有两个用来管理资源的智能指针：</p>
<ol>
<li>
<p>Buf:保存了所有的PTH对应的MemoryBuffer;</p>
</li>
<li>
<p>PerIDCache：一些IdentifierInfo的cache;</p>
</li>
</ol>
<p>这里还有两个用来维持抽象查询接口的智能指针：</p>
<ol>
<li>
<p>FileLookUp：管理各个文件与Token之间的映射。</p>
</li>
<li>
<p>StringIdLookup:管理ID与字符串之间的映射，虽然现在我还不知道这个ID是什么，看样子是PTH自己维护的一套ID。</p>
</li>
</ol>
<h3 id="91ad3f">对象构造</h3>
<p>这个很复杂的类的构造被封装在了一个非常复杂的函数里面：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// Create - This method creates PTHManager objects.  The &#39;file&#39; argument</span>
<span class="c1">///  is the name of the PTH file.  This method returns NULL upon failure.</span>
<span class="k">static</span> <span class="n">PTHManager</span> <span class="o">*</span><span class="nf">Create</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">file</span><span class="p">,</span> <span class="n">DiagnosticsEngine</span> <span class="o">&amp;</span><span class="n">Diags</span><span class="p">);</span>
</pre></div>


<p>由于函数实现太长，这里就大概说一下步骤：</p>
<ol>
<li>
<p>首先根据传入的File参数读取PTH文件，这里有一些格式检查。</p>
</li>
<li>
<p>过了格式检查之后，读取开头的ID-&gt;NameOffset的映射表，构建FileTable、spellingBase、StringIdTable和IDTable，这几个表的Offset是连在一起的，具体的格式参见OnDiskHashTable中的说明。</p>
</li>
<li>
<p>计算原始文件的长度</p>
</li>
</ol>
<h3 id="fbe7e3">名字映射</h3>
<p>在PTHManager中主要包含四个功能，首先就是get函数，用来从标识符名得到标识符，其签名如下：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// get - Return the identifier token info for the specified named identifier.</span>
<span class="c1">///  Unlike the version in IdentifierTable, this returns a pointer instead</span>
<span class="c1">///  of a reference.  If the pointer is NULL then the IdentifierInfo cannot</span>
<span class="c1">///  be found.</span>
<span class="n">IdentifierInfo</span> <span class="o">*</span><span class="nf">get</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Name</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</pre></div>


<p>其实这里实现的时候，是通过一个中间层来做两层映射的：String-&gt;ID-&gt;IdentifierInfo。</p>
<div class="codehilite"><pre><span></span><span class="c1">// Double check our assumption that the last character isn&#39;t &#39;\0&#39;.</span>
<span class="n">assert</span><span class="p">(</span><span class="n">Name</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">Name</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">);</span>
<span class="n">PTHStringIdLookup</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span> <span class="o">=</span>
<span class="n">StringIdLookup</span><span class="o">-&gt;</span><span class="n">find</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">Name</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">Name</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>
<span class="k">if</span> <span class="p">(</span><span class="n">I</span> <span class="o">==</span> <span class="n">StringIdLookup</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span> <span class="c1">// No identifier found?</span>
<span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

<span class="c1">// Match found.  Return the identifier!</span>
<span class="n">assert</span><span class="p">(</span><span class="o">*</span><span class="n">I</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">return</span> <span class="nf">GetIdentifierInfo</span><span class="p">(</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>


<p>这个StringIDLookup处理了第一层的映射，第二层的映射委托在了GetIdentifierInfo里面，其实现代码如下：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// GetIdentifierInfo - Used to reconstruct IdentifierInfo objects from the</span>
<span class="c1">///  PTH file.</span>
<span class="kr">inline</span> <span class="n">IdentifierInfo</span><span class="o">*</span> <span class="nf">GetIdentifierInfo</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">PersistentID</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Check if the IdentifierInfo has already been resolved.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IdentifierInfo</span><span class="o">*</span> <span class="n">II</span> <span class="o">=</span> <span class="n">PerIDCache</span><span class="p">[</span><span class="n">PersistentID</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">II</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">LazilyCreateIdentifierInfo</span><span class="p">(</span><span class="n">PersistentID</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>这里又是一层调用，可以看出PerIDCache里面存储着ID-&gt;IdentifierInfo的映射，但是这个映射不一定已经装载进来了。为了装载我们还需要调用下面的函数：</p>
<div class="codehilite"><pre><span></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="p">;</span>
<span class="c1">// Look in the PTH file for the string data for the IdentifierInfo object.</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">TableEntry</span> <span class="o">=</span> <span class="n">IdDataTable</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="o">*</span><span class="n">PersistentID</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">IDData</span> <span class="o">=</span>
<span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">Buf</span><span class="o">-&gt;</span><span class="n">getBufferStart</span><span class="p">()</span> <span class="o">+</span>
<span class="n">endian</span><span class="o">::</span><span class="n">readNext</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">little</span><span class="p">,</span> <span class="n">aligned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">TableEntry</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="n">IDData</span> <span class="o">&lt;</span> <span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">Buf</span><span class="o">-&gt;</span><span class="n">getBufferEnd</span><span class="p">());</span>

<span class="c1">// Allocate the object.</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">IdentifierInfo</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*&gt;</span> <span class="o">*</span><span class="n">Mem</span> <span class="o">=</span>
<span class="n">Alloc</span><span class="p">.</span><span class="n">Allocate</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">IdentifierInfo</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*&gt;</span> <span class="o">&gt;</span><span class="p">();</span>

<span class="n">Mem</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">=</span> <span class="n">IDData</span><span class="p">;</span>
<span class="n">assert</span><span class="p">(</span><span class="n">IDData</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">);</span>
<span class="n">IdentifierInfo</span> <span class="o">*</span><span class="n">II</span> <span class="o">=</span> <span class="k">new</span> <span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">Mem</span><span class="p">)</span> <span class="n">IdentifierInfo</span><span class="p">();</span>

<span class="c1">// Store the new IdentifierInfo in the cache.</span>
<span class="n">PerIDCache</span><span class="p">[</span><span class="n">PersistentID</span><span class="p">]</span> <span class="o">=</span> <span class="n">II</span><span class="p">;</span>
<span class="n">assert</span><span class="p">(</span><span class="n">II</span><span class="o">-&gt;</span><span class="n">getNameStart</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">II</span><span class="o">-&gt;</span><span class="n">getNameStart</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">);</span>
<span class="k">return</span> <span class="n">II</span><span class="p">;</span>
</pre></div>


<p>这里的IdDataTable里面存的是每个ID对应的String在MemoryBuffer中的偏移值，然后分配相应的空间来构造pair\<IdentifierInfo,char*>，并返回这个新构造的地址。总的来说，只是为了得到一个IdentifierInfo的坑，具体怎么填看后面的造化了。</p>
<h3 id="0bcaa4">CreateLexer</h3>
<p>这个函数的作用就是根据特定的PTHFile构造出对应的Lexer，过程很直白，不解释：</p>
<div class="codehilite"><pre><span></span><span class="n">PTHLexer</span> <span class="o">*</span><span class="n">PTHManager</span><span class="o">::</span><span class="n">CreateLexer</span><span class="p">(</span><span class="n">FileID</span> <span class="n">FID</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">FileEntry</span> <span class="o">*</span><span class="n">FE</span> <span class="o">=</span> <span class="n">PP</span><span class="o">-&gt;</span><span class="n">getSourceManager</span><span class="p">().</span><span class="n">getFileEntryForID</span><span class="p">(</span><span class="n">FID</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FE</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="p">;</span>

    <span class="c1">// Lookup the FileEntry object in our file lookup data structure.  It will</span>
    <span class="c1">// return a variant that indicates whether or not there is an offset within</span>
    <span class="c1">// the PTH file that contains cached tokens.</span>
    <span class="n">PTHFileLookup</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">FileLookup</span><span class="o">-&gt;</span><span class="n">find</span><span class="p">(</span><span class="n">FE</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">I</span> <span class="o">==</span> <span class="n">FileLookup</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span> <span class="c1">// No tokens available?</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">PTHFileData</span><span class="o">&amp;</span> <span class="n">FileData</span> <span class="o">=</span> <span class="o">*</span><span class="n">I</span><span class="p">;</span>

    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">BufStart</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">Buf</span><span class="o">-&gt;</span><span class="n">getBufferStart</span><span class="p">();</span>
    <span class="c1">// Compute the offset of the token data within the buffer.</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">data</span> <span class="o">=</span> <span class="n">BufStart</span> <span class="o">+</span> <span class="n">FileData</span><span class="p">.</span><span class="n">getTokenOffset</span><span class="p">();</span>

    <span class="c1">// Get the location of pp-conditional table.</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">ppcond</span> <span class="o">=</span> <span class="n">BufStart</span> <span class="o">+</span> <span class="n">FileData</span><span class="p">.</span><span class="n">getPPCondOffset</span><span class="p">();</span>
    <span class="kt">uint32_t</span> <span class="n">Len</span> <span class="o">=</span> <span class="n">endian</span><span class="o">::</span><span class="n">readNext</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">little</span><span class="p">,</span> <span class="n">aligned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ppcond</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">ppcond</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="n">assert</span><span class="p">(</span><span class="n">PP</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;No preprocessor set yet!&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">PTHLexer</span><span class="p">(</span><span class="o">*</span><span class="n">PP</span><span class="p">,</span> <span class="n">FID</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">ppcond</span><span class="p">,</span> <span class="o">*</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h1 id="806e13">符号管理</h1>
<h2 id="09e252">符号定义</h2>
<p>用来处理标识符的类型叫Identifier，但是这么重要的类型定义是放在IdentifierTable中的，跟这个IdentifierTable符号表一起存储的。其实这个Identifier的数据成员不算很多，基本就是一些标志位：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">IdentifierInfo</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="nl">TokenID</span> <span class="p">:</span> <span class="mi">9</span><span class="p">;</span> <span class="c1">// Front-end token ID or tok::identifier.</span>
    <span class="c1">// Objective-C keyword (&#39;protocol&#39; in &#39;@protocol&#39;) or builtin (__builtin_inf).</span>
    <span class="c1">// First NUM_OBJC_KEYWORDS values are for Objective-C, the remaining values</span>
    <span class="c1">// are for builtins.</span>
    <span class="kt">unsigned</span> <span class="nl">ObjCOrBuiltinID</span> <span class="p">:</span> <span class="mi">13</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="nl">HasMacro</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// True if there is a #define for this.</span>
    <span class="kt">bool</span> <span class="nl">HadMacro</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// True if there was a #define for this.</span>
    <span class="kt">bool</span> <span class="nl">IsExtension</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// True if identifier is a lang extension.</span>
    <span class="kt">bool</span> <span class="nl">IsFutureCompatKeyword</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// True if identifier is a keyword in a</span>
                                 <span class="c1">// newer Standard or proposed Standard.</span>
    <span class="kt">bool</span> <span class="nl">IsPoisoned</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// True if identifier is poisoned.</span>
    <span class="kt">bool</span> <span class="nl">IsCPPOperatorKeyword</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// True if ident is a C++ operator keyword.</span>
    <span class="kt">bool</span> <span class="nl">NeedsHandleIdentifier</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// See &quot;RecomputeNeedsHandleIdentifier&quot;.</span>
    <span class="kt">bool</span> <span class="nl">IsFromAST</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// True if identifier was loaded (at least </span>
                                 <span class="c1">// partially) from an AST file.</span>
    <span class="kt">bool</span> <span class="nl">ChangedAfterLoad</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// True if identifier has changed from the</span>
                                 <span class="c1">// definition loaded from an AST file.</span>
    <span class="kt">bool</span> <span class="nl">RevertedTokenID</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// True if revertTokenIDToIdentifier was</span>
                                 <span class="c1">// called.</span>
    <span class="kt">bool</span> <span class="nl">OutOfDate</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// True if there may be additional</span>
                                 <span class="c1">// information about this identifier</span>
                                 <span class="c1">// stored externally.</span>
    <span class="kt">bool</span> <span class="nl">IsModulesImport</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// True if this is the &#39;import&#39; contextual</span>
                                 <span class="c1">// keyword.</span>
    <span class="c1">// 30 bit left in 64-bit word.</span>

    <span class="kt">void</span> <span class="o">*</span><span class="n">FETokenInfo</span><span class="p">;</span>               <span class="c1">// Managed by the language front-end.</span>
    <span class="n">llvm</span><span class="o">::</span><span class="n">StringMapEntry</span><span class="o">&lt;</span><span class="n">IdentifierInfo</span><span class="o">*&gt;</span> <span class="o">*</span><span class="n">Entry</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里的TokenID其实就类似于TokenKind，这里也牵涉到了宏处理，重复利用了TokenKinds.def文件。isPoison的作用是用来指明当前标识符是否有问题，如果有问题则之后的使用都会爆错误或者警告。还有一个需要特别提到的地方就是Entry这个成员，它其实指向的是当前IdentifierInfo在StringMapEntry中的存储位点，也就是一个互指结构。根据当前类中所定义的一些函数即可猜测出IdentifierTable更多的的信息。例如下面这个获得标识符名称的实现：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief Return the beginning of the actual null-terminated string for this</span>
<span class="c1">/// identifier.</span>
<span class="c1">///</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">getNameStart</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Entry</span><span class="p">)</span> <span class="k">return</span> <span class="n">Entry</span><span class="o">-&gt;</span><span class="n">getKeyData</span><span class="p">();</span>
    <span class="c1">// FIXME: This is gross. It would be best not to embed specific details</span>
    <span class="c1">// of the PTH file format here.</span>
    <span class="c1">// The &#39;this&#39; pointer really points to a</span>
    <span class="c1">// std::pair&lt;IdentifierInfo, const char*&gt;, where internal pointer</span>
    <span class="c1">// points to the external string data.</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">IdentifierInfo</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span> <span class="n">actualtype</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">((</span><span class="k">const</span> <span class="n">actualtype</span><span class="o">*</span><span class="p">)</span> <span class="k">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里有两个路径，一个是当前标识符放在了IdentifierTable之中时直接返回Keydata，一个是当前标识符来自PTH于时直接返回当前对象后面的第一个字节。第二个执行路径暴露了PTH的实现，注释里面也说这么干不好。</p>
<p>同样的，getLength函数也复用了这个性质：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief Efficiently return the length of this identifier info.</span>
<span class="c1">///</span>
<span class="kt">unsigned</span> <span class="nf">getLength</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Entry</span><span class="p">)</span> <span class="k">return</span> <span class="n">Entry</span><span class="o">-&gt;</span><span class="n">getKeyLength</span><span class="p">();</span>
    <span class="c1">// FIXME: This is gross. It would be best not to embed specific details</span>
    <span class="c1">// of the PTH file format here.</span>
    <span class="c1">// The &#39;this&#39; pointer really points to a</span>
    <span class="c1">// std::pair&lt;IdentifierInfo, const char*&gt;, where internal pointer</span>
    <span class="c1">// points to the external string data.</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">IdentifierInfo</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span> <span class="n">actualtype</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">((</span><span class="k">const</span> <span class="n">actualtype</span><span class="o">*</span><span class="p">)</span> <span class="k">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="p">(((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里的长度操作我只能说掉渣天，这个const char*的头两个字节居然编码了长度，虽然是逆序的。同时也暴露了一个问题，标识符长度藏在了this指针的两字节padding中，同时标识符长度上限是256*256，虽然正常情况下这不是一个问题。</p>
<h2 id="ceb0aa">符号表</h2>
<p>符号表的类型是IdentifierTable,其基本数据成员就两个：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief Implements an efficient mapping from strings to IdentifierInfo nodes.</span>
<span class="c1">///</span>
<span class="c1">/// This has no other purpose, but this is an extremely performance-critical</span>
<span class="c1">/// piece of the code, as each occurrence of every identifier goes through</span>
<span class="c1">/// here when lexed.</span>
<span class="k">class</span> <span class="nc">IdentifierTable</span>
<span class="p">{</span>
    <span class="c1">// Shark shows that using MallocAllocator is *much* slower than using this</span>
    <span class="c1">// BumpPtrAllocator!</span>
    <span class="k">typedef</span> <span class="n">llvm</span><span class="o">::</span><span class="n">StringMap</span><span class="o">&lt;</span><span class="n">IdentifierInfo</span><span class="o">*</span><span class="p">,</span> <span class="n">llvm</span><span class="o">::</span><span class="n">BumpPtrAllocator</span><span class="o">&gt;</span> <span class="n">HashTableTy</span><span class="p">;</span>
    <span class="n">HashTableTy</span> <span class="n">HashTable</span><span class="p">;</span>

    <span class="n">IdentifierInfoLookup</span><span class="o">*</span> <span class="n">ExternalLookup</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里的HashTable就是一个map\<string,IdentifierInfo*>，所有本地的名称与标识符的映射信息就存在里面。如果是外部标识符，则需要经过ExternalLookUp这个位置来访问。所以，总的查询函数为：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief Return the identifier token info for the specified named</span>
<span class="c1">/// identifier.</span>
<span class="n">IdentifierInfo</span> <span class="o">&amp;</span><span class="n">get</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="o">&amp;</span><span class="n">Entry</span> <span class="o">=</span> <span class="o">*</span><span class="n">HashTable</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">Name</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">)).</span><span class="n">first</span><span class="p">;</span>

    <span class="n">IdentifierInfo</span> <span class="o">*&amp;</span><span class="n">II</span> <span class="o">=</span> <span class="n">Entry</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">II</span><span class="p">)</span> <span class="k">return</span> <span class="o">*</span><span class="n">II</span><span class="p">;</span>

    <span class="c1">// No entry; if we have an external lookup, look there first.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ExternalLookup</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">II</span> <span class="o">=</span> <span class="n">ExternalLookup</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="n">Name</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">II</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">*</span><span class="n">II</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Lookups failed, make a new IdentifierInfo.</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">Mem</span> <span class="o">=</span> <span class="n">getAllocator</span><span class="p">().</span><span class="n">Allocate</span><span class="o">&lt;</span><span class="n">IdentifierInfo</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">II</span> <span class="o">=</span> <span class="k">new</span> <span class="p">(</span><span class="n">Mem</span><span class="p">)</span> <span class="n">IdentifierInfo</span><span class="p">();</span>

    <span class="c1">// Make sure getName() knows how to find the IdentifierInfo</span>
    <span class="c1">// contents.</span>
    <span class="n">II</span><span class="o">-&gt;</span><span class="n">Entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Entry</span><span class="p">;</span>

    <span class="k">return</span> <span class="o">*</span><span class="n">II</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>大概流程就是先查本地，然后查外部，如果都没有就在本地插入一个。注意最后的II-&gt;Entry = &Entry;，这个是用来维持自引用的。</p>
<p>对于查询方法还有另外一个版本，这个版本专门用来处理本地查询，相关代码与之前函数的基本一样，不再谈。</p>
<p>在符号表里面还有一个非常重要的类，DeclarationNameExtra。这个类存储了类内部函数的类型信息：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// DeclarationNameExtra - Common base of the MultiKeywordSelector,</span>
<span class="c1">/// CXXSpecialName, and CXXOperatorIdName classes, all of which are</span>
<span class="c1">/// private classes that describe different kinds of names.</span>
<span class="k">class</span> <span class="nc">DeclarationNameExtra</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">/// ExtraKind - The kind of &quot;extra&quot; information stored in the</span>
    <span class="c1">/// DeclarationName. See @c ExtraKindOrNumArgs for an explanation of</span>
    <span class="c1">/// how these enumerator values are used.</span>
    <span class="k">enum</span> <span class="n">ExtraKind</span>
    <span class="p">{</span>
        <span class="n">CXXConstructor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">CXXDestructor</span><span class="p">,</span>
        <span class="n">CXXConversionFunction</span><span class="p">,</span>
<span class="cp">#define OVERLOADED_OPERATOR(Name,Spelling,Token,Unary,Binary,MemberOnly) \</span>
<span class="cp">CXXOperator##Name,</span>
<span class="cp">#include</span> <span class="cpf">&quot;clang/Basic/OperatorKinds.def&quot;</span><span class="cp"></span>
        <span class="n">CXXLiteralOperator</span><span class="p">,</span>
        <span class="n">CXXUsingDirective</span><span class="p">,</span>
        <span class="n">NUM_EXTRA_KINDS</span>
    <span class="p">};</span>

    <span class="c1">/// ExtraKindOrNumArgs - Either the kind of C++ special name or</span>
    <span class="c1">/// operator-id (if the value is one of the CXX* enumerators of</span>
    <span class="c1">/// ExtraKind), in which case the DeclarationNameExtra is also a</span>
    <span class="c1">/// CXXSpecialName, (for CXXConstructor, CXXDestructor, or</span>
    <span class="c1">/// CXXConversionFunction) CXXOperatorIdName, or CXXLiteralOperatorName,</span>
    <span class="c1">/// it may be also name common to C++ using-directives (CXXUsingDirective),</span>
    <span class="c1">/// otherwise it is NUM_EXTRA_KINDS+NumArgs, where NumArgs is the number of</span>
    <span class="c1">/// arguments in the Objective-C selector, in which case the</span>
    <span class="c1">/// DeclarationNameExtra is also a MultiKeywordSelector.</span>
    <span class="kt">unsigned</span> <span class="n">ExtraKindOrNumArgs</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>大家看到这里的#define没，简直魔性啊。利用这个宏定义和OperatorKinds.def文件就活生生的造出了100多个新的枚举值。同时OperatorKinds.def能够根据不同的宏定义衍生出不同的枚举值类型，所支持的宏定义都在文件头的Header guard中。</p>
<h1 id="af6598">宏管理</h1>
<p>在宏管理方面，主要有两个类，一个是<em>MacroInfo</em>，一个是<em>MacroArgs</em>。对于宏来说，主要分为两类：对象型和函数型，区别就在于有没有参数。<em>MacroInfo</em>描述的就是这些。而<em>MacroArgs</em>则存储了宏的参数列表。</p>
<h2 id="887c57">MacroArgs</h2>
<p>这个类的组成还是比较简单的：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">MacroArgs</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">NumUnexpArgTokens</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">VarargsElided</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">PreExpArgTokens</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span> <span class="n">StringifiedArgs</span><span class="p">;</span>
    <span class="n">MacroArgs</span> <span class="o">*</span><span class="n">ArgCache</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<ol>
<li>NumUnexpArgTokens：宏参数的数量，实际的参数<em>Token</em>在内存中会紧接着当前的<em>MacroArgs</em>对象分配，每个宏实际参数都是以<em>EOF</em>来作为终结符的。</li>
<li>VarargsElided: 这个是<em>C99</em>的变参宏的参数形式，不用管。</li>
<li>PreExpArgTokens:这个是预展开的实际参数，由于展开之后的参数可能有多个<em>token</em>，所以每个参数是<em>token</em>的<em>vector</em>，并以<em>EOF</em>为结尾，总的实参就是<em>vector<vector<token>&gt;</em>，对于还没计算的参数展开，保留为空。</li>
<li>StringifiedArgs:这个是处理<em>#</em>操作符的。</li>
<li>ArgCache:这个是空闲的<em>MacroArgs</em>内存区域的头指针。</li>
</ol>
<p>首先需要说一下<em>UnexpArgTokens</em>这个的存储区域，注释里面说这些<em>token</em>是存储于当前对象末尾的，导致了这些区域的内存访问变得非常诡异...</p>
<div class="codehilite"><pre><span></span><span class="k">const</span> <span class="n">Token</span> <span class="o">*</span><span class="n">MacroArgs</span><span class="o">::</span><span class="n">getUnexpArgument</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">Arg</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// The unexpanded argument tokens start immediately after the MacroArgs object</span>
    <span class="c1">// in memory.</span>
    <span class="c1">//这又是一个依赖于实现的东西啊，内存对齐呢！ 谁说当前对象末尾一定无缝隙链接Token啊</span>
    <span class="k">const</span> <span class="n">Token</span> <span class="o">*</span><span class="n">Start</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Token</span> <span class="o">*</span><span class="p">)(</span><span class="k">this</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">Token</span> <span class="o">*</span><span class="n">Result</span> <span class="o">=</span> <span class="n">Start</span><span class="p">;</span>
    <span class="c1">// Scan to find Arg.</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">Arg</span><span class="p">;</span> <span class="o">++</span><span class="n">Result</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">Result</span> <span class="o">&lt;</span> <span class="n">Start</span> <span class="o">+</span> <span class="n">NumUnexpArgTokens</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Invalid arg #&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Result</span><span class="o">-&gt;</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">eof</span><span class="p">))</span>
            <span class="o">--</span><span class="n">Arg</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">Result</span> <span class="o">&lt;</span> <span class="n">Start</span> <span class="o">+</span> <span class="n">NumUnexpArgTokens</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Invalid arg #&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>强制了内存布局和对齐啊：<em>(const Token </em>)(this +1)<em>。从这个实现中我们可以看出，每个</em>UnexpArgument<em>是一个以</em>EOF<em>分割的</em>Token*数组，内存区域连续分配。</p>
<p>这个<em>MacroArgs</em>类型对象的生命周期是被预处理器<em>Preprocessor</em>托管的，所以他的创建需要下面的静态函数：</p>
<div class="codehilite"><pre><span></span><span class="k">static</span> <span class="n">MacroArgs</span> <span class="o">*</span><span class="nf">create</span><span class="p">(</span><span class="k">const</span> <span class="n">MacroInfo</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span>
        <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span> <span class="n">UnexpArgTokens</span><span class="p">,</span>
        <span class="kt">bool</span> <span class="n">VarargsElided</span><span class="p">,</span> <span class="n">Preprocessor</span> <span class="o">&amp;</span><span class="n">PP</span><span class="p">);</span>
</pre></div>


<p>其具体执行流程就是从预处理器的空闲内存列表<em>&amp;PP.MacroArgCache</em>中找到能够满足条件<em>*Entry)-&gt;NumUnexpArgTokens &gt;= UnexpArgTokens.size()</em>且内存区域最小的<em>Entry</em>，如果找不到就调用<em>malloc</em>，然后就是<em>placement new</em>。对象构造完成之后，将<em>unexpArgTokens</em>复制到<em>result</em>的内存区域后面，其实这样做很不好，暴露了<em>Token</em>的具体存储区！</p>
<p>对象的创建是通过<em>Preprocessor</em>来处理的，那么对象的销毁也是通过<em>Preprocessor</em>来处理。</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">MacroArgs</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span><span class="n">Preprocessor</span> <span class="o">&amp;</span><span class="n">PP</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">StringifiedArgs</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

    <span class="c1">// Don&#39;t clear PreExpArgTokens, just clear the entries.  Clearing the entries</span>
    <span class="c1">// would deallocate the element vectors.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">PreExpArgTokens</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">PreExpArgTokens</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">clear</span><span class="p">();</span>

    <span class="c1">// Add this to the preprocessor&#39;s free list.</span>
    <span class="c1">//总的空闲头节点存储在PP.MacroArgCache里面</span>
    <span class="c1">//感觉这样的话只能进行头节点处理啊，多节点分配就崩了</span>
    <span class="n">ArgCache</span> <span class="o">=</span> <span class="n">PP</span><span class="p">.</span><span class="n">MacroArgCache</span><span class="p">;</span>
    <span class="n">PP</span><span class="p">.</span><span class="n">MacroArgCache</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里的<em>destroy</em>只是用来释放展开之后的宏参数<em>token</em>的，同时将当前节点挂载到预处理器的空闲链表头。</p>
<p>真正完整的销毁是这个：</p>
<div class="codehilite"><pre><span></span><span class="n">MacroArgs</span> <span class="o">*</span><span class="n">MacroArgs</span><span class="o">::</span><span class="n">deallocate</span><span class="p">()</span>

<span class="n">MacroArgs</span> <span class="o">*</span><span class="n">Next</span> <span class="o">=</span> <span class="n">ArgCache</span><span class="p">;</span>

<span class="c1">// Run the dtor to deallocate the vectors. this-&gt; MacroArgs(); //</span>

<span class="n">Release</span> <span class="n">the</span> <span class="n">memory</span> <span class="k">for</span> <span class="n">the</span> <span class="n">object</span><span class="p">.</span> <span class="n">free</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

<span class="k">return</span> <span class="n">Next</span><span class="p">;</span>
</pre></div>


<p><em>free this</em>与<em>delete this</em>有异曲同工之妙啊，用错了可是蹦的相当惨，所以该函数只能在<em>Preprocessor</em>中调用。</p>
<p>对于展开后参数的访问，是与参数展开过程合并的，即参数展开只有在需要时才展开，是<em>lazy</em>的。</p>
<div class="codehilite"><pre><span></span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span> <span class="o">&amp;</span>
<span class="n">MacroArgs</span><span class="o">::</span><span class="n">getPreExpArgument</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">Arg</span><span class="p">,</span> <span class="k">const</span> <span class="n">MacroInfo</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span>
    <span class="n">Preprocessor</span> <span class="o">&amp;</span><span class="n">PP</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">Arg</span> <span class="o">&lt;</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getNumArgs</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Invalid argument number!&quot;</span><span class="p">);</span>

    <span class="c1">// If we have already computed this, return it.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PreExpArgTokens</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getNumArgs</span><span class="p">())</span>
        <span class="n">PreExpArgTokens</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">MI</span><span class="o">-&gt;</span><span class="n">getNumArgs</span><span class="p">());</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Result</span> <span class="o">=</span> <span class="n">PreExpArgTokens</span><span class="p">[</span><span class="n">Arg</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Result</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>

    <span class="n">SaveAndRestore</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">PreExpandingMacroArgs</span><span class="p">(</span><span class="n">PP</span><span class="p">.</span><span class="n">InMacroArgPreExpansion</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

    <span class="k">const</span> <span class="n">Token</span> <span class="o">*</span><span class="n">AT</span> <span class="o">=</span> <span class="n">getUnexpArgument</span><span class="p">(</span><span class="n">Arg</span><span class="p">);</span>
    <span class="kt">unsigned</span> <span class="n">NumToks</span> <span class="o">=</span> <span class="n">getArgLength</span><span class="p">(</span><span class="n">AT</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// Include the EOF.</span>

    <span class="c1">// Otherwise, we have to pre-expand this argument, populating Result.  To do</span>
    <span class="c1">// this, we set up a fake TokenLexer to lex from the unexpanded argument</span>
    <span class="c1">// list.  With this installed, we lex expanded tokens until we hit the EOF</span>
    <span class="c1">// token at the end of the unexp list.</span>
    <span class="n">PP</span><span class="p">.</span><span class="n">EnterTokenStream</span><span class="p">(</span><span class="n">AT</span><span class="p">,</span> <span class="n">NumToks</span><span class="p">,</span> <span class="nb">false</span> <span class="cm">/*disable expand*/</span><span class="p">,</span>
        <span class="nb">false</span> <span class="cm">/*owns tokens*/</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>访问时，首先判断是否已经展开了:<em>PreExpArgTokens[Arg]</em>，否则需要进行展开操作。这里用的是一个临时的预处理器，结果通过<em>PP.lex()</em>一个一个吐出来。最后把展开后的<em>token</em>存进来。</p>
<div class="codehilite"><pre><span></span><span class="n">PP</span><span class="p">.</span><span class="n">EnterTokenStream</span><span class="p">(</span><span class="n">AT</span><span class="p">,</span> <span class="n">NumToks</span><span class="p">,</span> <span class="nb">false</span> <span class="cm">/*disable expand*/</span><span class="p">,</span>
    <span class="nb">false</span> <span class="cm">/*owns tokens*/</span><span class="p">);</span>
<span class="c1">// Lex all of the macro-expanded tokens into Result.</span>
<span class="k">do</span>
<span class="p">{</span>
    <span class="n">Result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Token</span><span class="p">());</span>
    <span class="n">Token</span> <span class="o">&amp;</span><span class="n">Tok</span> <span class="o">=</span> <span class="n">Result</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
    <span class="n">PP</span><span class="p">.</span><span class="n">Lex</span><span class="p">(</span><span class="n">Tok</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">while</span> <span class="p">(</span><span class="n">Result</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">isNot</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">eof</span><span class="p">));</span>

<span class="c1">// Pop the token stream off the top of the stack.  We know that the internal</span>
<span class="c1">// pointer inside of it is to the &quot;end&quot; of the token stream, but the stack</span>
<span class="c1">// will not otherwise be popped until the next token is lexed.  The problem is</span>
<span class="c1">// that the token may be lexed sometime after the vector of tokens itself is</span>
<span class="c1">// destroyed, which would be badness.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">PP</span><span class="p">.</span><span class="n">InCachingLexMode</span><span class="p">())</span>
    <span class="n">PP</span><span class="p">.</span><span class="n">ExitCachingLexMode</span><span class="p">();</span>
<span class="n">PP</span><span class="p">.</span><span class="n">RemoveTopOfLexerStack</span><span class="p">();</span>
<span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
</pre></div>


<p>这里还有一个重量级的函数<em>stringinify</em>，用来处理<em>#</em>连接的，将连接起来的<em>token</em>组合成一个<em>string</em>。代码逻辑比较扭曲，这里就不谈了。相关逻辑见<em>C99</em>标准的<em>6.10.3.2p2</em>。</p>
<h2 id="426eb0">MacroInfo</h2>
<p>这个类的格局就比<em>MacroArgs</em>大了很多，不过很多都是标识位，不用管太多。主要的数据成员如下：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">MacroInfo</span>
<span class="p">{</span>
    <span class="c1">//===--------------------------------------------------------------------===//</span>
    <span class="c1">// State set when the macro is defined.</span>

    <span class="c1">/// \brief The location the macro is defined.</span>
    <span class="n">SourceLocation</span> <span class="n">Location</span><span class="p">;</span>
    <span class="c1">/// \brief The location of the last token in the macro.</span>
    <span class="n">SourceLocation</span> <span class="n">EndLocation</span><span class="p">;</span>

    <span class="c1">/// \brief The list of arguments for a function-like macro.</span>
    <span class="c1">///</span>
    <span class="c1">/// ArgumentList points to the first of NumArguments pointers.</span>
    <span class="c1">///</span>
    <span class="c1">/// This can be empty, for, e.g. &quot;#define X()&quot;.  In a C99-style variadic</span>
    <span class="c1">/// macro, this includes the \c __VA_ARGS__ identifier on the list.</span>
    <span class="n">IdentifierInfo</span> <span class="o">**</span><span class="n">ArgumentList</span><span class="p">;</span>

    <span class="c1">/// \see ArgumentList</span>
    <span class="kt">unsigned</span> <span class="n">NumArguments</span><span class="p">;</span>

    <span class="c1">/// \brief This is the list of tokens that the macro is defined to.</span>
    <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Token</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">ReplacementTokens</span><span class="p">;</span>

    <span class="c1">/// \brief Length in characters of the macro definition.</span>
    <span class="k">mutable</span> <span class="kt">unsigned</span> <span class="n">DefinitionLength</span><span class="p">;</span>
    <span class="k">mutable</span> <span class="kt">bool</span> <span class="nl">IsDefinitionLengthCached</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>对于函数型宏来说，他是有参数列表的，所有参数的指针按序排在以<em>ArgumentList</em>的内存区域中，总共<em>NumArguments</em>个。整个宏的长度是<em>DefinitionLength</em>，这个是延迟计算的，紧接着的<em>IsDefinitionLengthCached</em>就是这个长度是否已经计算的标记值。这个延迟计算的代码也很直白,就是获得头<em>Token</em>和尾<em>token</em>，然后获得展开位置，计算差值：</p>
<div class="codehilite"><pre><span></span><span class="kt">unsigned</span> <span class="n">MacroInfo</span><span class="o">::</span><span class="n">getDefinitionLengthSlow</span><span class="p">(</span><span class="n">SourceManager</span> <span class="o">&amp;</span><span class="n">SM</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">IsDefinitionLengthCached</span><span class="p">);</span>
    <span class="n">IsDefinitionLengthCached</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ReplacementTokens</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">DefinitionLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">const</span> <span class="n">Token</span> <span class="o">&amp;</span><span class="n">firstToken</span> <span class="o">=</span> <span class="n">ReplacementTokens</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">Token</span> <span class="o">&amp;</span><span class="n">lastToken</span> <span class="o">=</span> <span class="n">ReplacementTokens</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
    <span class="n">SourceLocation</span> <span class="n">macroStart</span> <span class="o">=</span> <span class="n">firstToken</span><span class="p">.</span><span class="n">getLocation</span><span class="p">();</span>
    <span class="n">SourceLocation</span> <span class="n">macroEnd</span> <span class="o">=</span> <span class="n">lastToken</span><span class="p">.</span><span class="n">getLocation</span><span class="p">();</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">macroStart</span><span class="p">.</span><span class="n">isValid</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">macroEnd</span><span class="p">.</span><span class="n">isValid</span><span class="p">());</span>
    <span class="n">assert</span><span class="p">((</span><span class="n">macroStart</span><span class="p">.</span><span class="n">isFileID</span><span class="p">()</span> <span class="o">||</span> <span class="n">firstToken</span><span class="p">.</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">comment</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
        <span class="s">&quot;Macro defined in macro?&quot;</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">((</span><span class="n">macroEnd</span><span class="p">.</span><span class="n">isFileID</span><span class="p">()</span> <span class="o">||</span> <span class="n">lastToken</span><span class="p">.</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">comment</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
        <span class="s">&quot;Macro defined in macro?&quot;</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">FileID</span><span class="p">,</span> <span class="kt">unsigned</span><span class="o">&gt;</span>
        <span class="n">startInfo</span> <span class="o">=</span> <span class="n">SM</span><span class="p">.</span><span class="n">getDecomposedExpansionLoc</span><span class="p">(</span><span class="n">macroStart</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">FileID</span><span class="p">,</span> <span class="kt">unsigned</span><span class="o">&gt;</span>
        <span class="n">endInfo</span> <span class="o">=</span> <span class="n">SM</span><span class="p">.</span><span class="n">getDecomposedExpansionLoc</span><span class="p">(</span><span class="n">macroEnd</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">startInfo</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="n">endInfo</span><span class="p">.</span><span class="n">first</span> <span class="o">&amp;&amp;</span>
        <span class="s">&quot;Macro definition spanning multiple FileIDs ?&quot;</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">startInfo</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;=</span> <span class="n">endInfo</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
    <span class="n">DefinitionLength</span> <span class="o">=</span> <span class="n">endInfo</span><span class="p">.</span><span class="n">second</span> <span class="o">-</span> <span class="n">startInfo</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
    <span class="n">DefinitionLength</span> <span class="o">+=</span> <span class="n">lastToken</span><span class="p">.</span><span class="n">getLength</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">DefinitionLength</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>剩下的就是一些位标记了，分为两种：一种是宏的自身属性，另外一种是使用属性。下面的是自身属性：</p>
<div class="codehilite"><pre><span></span><span class="c1">//是否是函数宏还是对象宏.</span>
<span class="kt">bool</span> <span class="nl">IsFunctionLike</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// 是否是C99的变参宏</span>
<span class="kt">bool</span> <span class="nl">IsC99Varargs</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">//是否是GNU的变参宏</span>
<span class="kt">bool</span> <span class="nl">IsGNUVarargs</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">//是否是语言内置宏，如__FILE__ __LINE__等</span>
<span class="kt">bool</span> <span class="nl">IsBuiltinMacro</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">/// \brief Whether this macro contains the sequence &quot;, ## __VA_ARGS__&quot;</span>
<span class="kt">bool</span> <span class="nl">HasCommaPasting</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>


<p>下面的是使用属性：</p>
<div class="codehilite"><pre><span></span><span class="c1">//===--------------------------------------------------------------------===//</span>
<span class="c1">// State that changes as the macro is used.</span>

<span class="c1">/// \brief True if we have started an expansion of this macro already.</span>
<span class="c1">///</span>
<span class="c1">/// This disables recursive expansion, which would be quite bad for things</span>
<span class="c1">/// like \#define A A.</span>
<span class="kt">bool</span> <span class="nl">IsDisabled</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">/// \brief True if this macro is either defined in the main file and has</span>
<span class="c1">/// been used, or if it is not defined in the main file.</span>
<span class="c1">///</span>
<span class="c1">/// This is used to emit -Wunused-macros diagnostics.</span>
<span class="kt">bool</span> <span class="nl">IsUsed</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">/// \brief True if this macro can be redefined without emitting a warning.</span>
<span class="kt">bool</span> <span class="nl">IsAllowRedefinitionsWithoutWarning</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">/// \brief Must warn if the macro is unused at the end of translation unit.</span>
<span class="kt">bool</span> <span class="nl">IsWarnIfUnused</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">/// \brief Whether this macro info was loaded from an AST file.</span>
<span class="kt">unsigned</span> <span class="nl">FromASTFile</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">/// \brief Whether this macro was used as header guard.</span>
<span class="kt">bool</span> <span class="nl">UsedForHeaderGuard</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>


<p>类中还有很多函数来操作这些可更改的位，但是内容很简单，这里就不详谈了。</p>
<p>对于<em>MacroInfo</em>来说，比较重要的操作是判断两个宏是否相等。相等又分为两种，一种是语义上的相等，此时函数参数名可以变化；另外一种是词法上的相等，就是一个一个<em>Token</em>的比较。因此在比较的时候，如果函数体里面遇到函数参数，就查看函数参数的索引是否相等。</p>
<div class="codehilite"><pre><span></span><span class="kt">bool</span> <span class="n">MacroInfo</span><span class="o">::</span><span class="n">isIdenticalTo</span><span class="p">(</span><span class="k">const</span> <span class="n">MacroInfo</span> <span class="o">&amp;</span><span class="n">Other</span><span class="p">,</span> <span class="n">Preprocessor</span> <span class="o">&amp;</span><span class="n">PP</span><span class="p">,</span>
<span class="kt">bool</span> <span class="n">Syntactically</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">Lexically</span> <span class="o">=</span> <span class="o">!</span><span class="n">Syntactically</span><span class="p">;</span>

    <span class="c1">// Check # tokens in replacement, number of args, and various flags all match.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ReplacementTokens</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Other</span><span class="p">.</span><span class="n">ReplacementTokens</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span>
        <span class="n">getNumArgs</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Other</span><span class="p">.</span><span class="n">getNumArgs</span><span class="p">()</span> <span class="o">||</span>
        <span class="n">isFunctionLike</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Other</span><span class="p">.</span><span class="n">isFunctionLike</span><span class="p">()</span> <span class="o">||</span>
        <span class="n">isC99Varargs</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Other</span><span class="p">.</span><span class="n">isC99Varargs</span><span class="p">()</span> <span class="o">||</span>
        <span class="n">isGNUVarargs</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Other</span><span class="p">.</span><span class="n">isGNUVarargs</span><span class="p">())</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Lexically</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Check arguments.</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">arg_iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">arg_begin</span><span class="p">(),</span> <span class="n">OI</span> <span class="o">=</span> <span class="n">Other</span><span class="p">.</span><span class="n">arg_begin</span><span class="p">(),</span> <span class="n">E</span> <span class="o">=</span> <span class="n">arg_end</span><span class="p">();</span>
        <span class="n">I</span> <span class="o">!=</span> <span class="n">E</span><span class="p">;</span> <span class="o">++</span><span class="n">I</span><span class="p">,</span> <span class="o">++</span><span class="n">OI</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">I</span> <span class="o">!=</span> <span class="o">*</span><span class="n">OI</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Check all the tokens.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">ReplacementTokens</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">Token</span> <span class="o">&amp;</span><span class="n">A</span> <span class="o">=</span> <span class="n">ReplacementTokens</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">const</span> <span class="n">Token</span> <span class="o">&amp;</span><span class="n">B</span> <span class="o">=</span> <span class="n">Other</span><span class="p">.</span><span class="n">ReplacementTokens</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">getKind</span><span class="p">()</span> <span class="o">!=</span> <span class="n">B</span><span class="p">.</span><span class="n">getKind</span><span class="p">())</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="c1">// If this isn&#39;t the first first token, check that the whitespace and</span>
        <span class="c1">// start-of-line characteristics match.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
            <span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">isAtStartOfLine</span><span class="p">()</span> <span class="o">!=</span> <span class="n">B</span><span class="p">.</span><span class="n">isAtStartOfLine</span><span class="p">()</span> <span class="o">||</span>
                <span class="n">A</span><span class="p">.</span><span class="n">hasLeadingSpace</span><span class="p">()</span> <span class="o">!=</span> <span class="n">B</span><span class="p">.</span><span class="n">hasLeadingSpace</span><span class="p">()))</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="c1">// If this is an identifier, it is easy.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">getIdentifierInfo</span><span class="p">()</span> <span class="o">||</span> <span class="n">B</span><span class="p">.</span><span class="n">getIdentifierInfo</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">getIdentifierInfo</span><span class="p">()</span> <span class="o">==</span> <span class="n">B</span><span class="p">.</span><span class="n">getIdentifierInfo</span><span class="p">())</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">Lexically</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="c1">// With syntactic equivalence the parameter names can be different as long</span>
            <span class="c1">// as they are used in the same place.</span>
            <span class="kt">int</span> <span class="n">AArgNum</span> <span class="o">=</span> <span class="n">getArgumentNum</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">getIdentifierInfo</span><span class="p">());</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">AArgNum</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">AArgNum</span> <span class="o">!=</span> <span class="n">Other</span><span class="p">.</span><span class="n">getArgumentNum</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">getIdentifierInfo</span><span class="p">()))</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Otherwise, check the spelling.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">PP</span><span class="p">.</span><span class="n">getSpelling</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">!=</span> <span class="n">PP</span><span class="p">.</span><span class="n">getSpelling</span><span class="p">(</span><span class="n">B</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h2 id="a15340">MacroDirective</h2>
<p>这个<em>MacroDirective</em>类似于名字空间的存在，用来界定宏的可见性。在宏的可见性方面，定义了以下的枚举类型：</p>
<div class="codehilite"><pre><span></span><span class="k">enum</span> <span class="n">Kind</span>
<span class="p">{</span>
    <span class="n">MD_Define</span><span class="p">,</span> <span class="n">MD_Undefine</span><span class="p">,</span> <span class="n">MD_Visibility</span>
<span class="p">};</span>
</pre></div>


<p>而整个<em>MacroDirective</em>的数据成员也比较少，包括如下：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">MacroDirective</span>
<span class="p">{</span>
    <span class="c1">/// \brief Previous macro directive for the same identifier, or NULL.</span>
    <span class="n">MacroDirective</span> <span class="o">*</span><span class="n">Previous</span><span class="p">;</span>

    <span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">;</span>

    <span class="c1">/// \brief MacroDirective kind.</span>
    <span class="kt">unsigned</span> <span class="nl">MDKind</span> <span class="p">:</span> <span class="mi">2</span><span class="p">;</span>

    <span class="c1">/// \brief True if the macro directive was loaded from a PCH file.</span>
    <span class="kt">bool</span> <span class="nl">IsFromPCH</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// Used by VisibilityMacroDirective ----------------------------------------//</span>

    <span class="c1">/// \brief Whether the macro has public visibility (when described in a</span>
    <span class="c1">/// module).</span>
    <span class="kt">bool</span> <span class="nl">IsPublic</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>其实相关的内容也就三个：类型，位置，串联指针。没有什么特殊的，就不解释了。</p>
<p>同时根据<em>MDKind</em>的具体类型，特化了三种形式，即子类：<em>DefMacroDirective, UndefMacroDirective, VisibilityMacroDirective</em>。
这个是<em>define</em>的<em>MacroDirective</em>形式，所以他的定义是直接继承过来的：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">DefMacroDirective</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MacroDirective</span>
<span class="p">{</span>
    <span class="n">MacroInfo</span> <span class="o">*</span><span class="n">Info</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>里面还夹带了一个<em>MacroInfo</em>。</p>
<p>类似的有UndefMacroDirective:</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">UndefMacroDirective</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MacroDirective</span>
</pre></div>


<p>这里就没有<em>MacroInfo</em>那个数据成员了，不科学。对于VisibilityMacroDirective来说也是如此：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">VisibilityMacroDirective</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MacroDirective</span>
</pre></div>


<p>下面的这个寻找宏定义的函数就利用了这几种类型之间的动态类型转换。</p>
<div class="codehilite"><pre><span></span><span class="n">MacroDirective</span><span class="o">::</span><span class="n">DefInfo</span> <span class="n">MacroDirective</span><span class="o">::</span><span class="n">getDefinition</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">MacroDirective</span> <span class="o">*</span><span class="n">MD</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="n">SourceLocation</span> <span class="n">UndefLoc</span><span class="p">;</span>
    <span class="n">Optional</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">isPublic</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">MD</span><span class="p">;</span> <span class="n">MD</span> <span class="o">=</span> <span class="n">MD</span><span class="o">-&gt;</span><span class="n">getPrevious</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">DefMacroDirective</span> <span class="o">*</span><span class="n">DefMD</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">DefMacroDirective</span><span class="o">&gt;</span><span class="p">(</span><span class="n">MD</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">DefInfo</span><span class="p">(</span><span class="n">DefMD</span><span class="p">,</span> <span class="n">UndefLoc</span><span class="p">,</span>
                <span class="o">!</span><span class="n">isPublic</span><span class="p">.</span><span class="n">hasValue</span><span class="p">()</span> <span class="o">||</span> <span class="n">isPublic</span><span class="p">.</span><span class="n">getValue</span><span class="p">());</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">UndefMacroDirective</span> <span class="o">*</span><span class="n">UndefMD</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">UndefMacroDirective</span><span class="o">&gt;</span><span class="p">(</span><span class="n">MD</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">UndefLoc</span> <span class="o">=</span> <span class="n">UndefMD</span><span class="o">-&gt;</span><span class="n">getLocation</span><span class="p">();</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">VisibilityMacroDirective</span> <span class="o">*</span><span class="n">VisMD</span> <span class="o">=</span> <span class="n">cast</span><span class="o">&lt;</span><span class="n">VisibilityMacroDirective</span><span class="o">&gt;</span><span class="p">(</span><span class="n">MD</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isPublic</span><span class="p">.</span><span class="n">hasValue</span><span class="p">())</span>
            <span class="n">isPublic</span> <span class="o">=</span> <span class="n">VisMD</span><span class="o">-&gt;</span><span class="n">isPublic</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">DefInfo</span><span class="p">(</span><span class="k">nullptr</span><span class="p">,</span> <span class="n">UndefLoc</span><span class="p">,</span>
        <span class="o">!</span><span class="n">isPublic</span><span class="p">.</span><span class="n">hasValue</span><span class="p">()</span> <span class="o">||</span> <span class="n">isPublic</span><span class="p">.</span><span class="n">getValue</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>


<h2 id="84847d">MuduleMacro</h2>
<p>这个<em>ModuleMacro</em>代表的是在外部模块导入进来的宏导言。多个模块中可能会对同一个宏做多次定义，这里我们还要记录定义覆盖路径：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">ModuleMacro</span> <span class="o">:</span> <span class="k">public</span> <span class="n">llvm</span><span class="o">::</span><span class="n">FoldingSetNode</span>
<span class="p">{</span>
    <span class="c1">/// The name defined by the macro.</span>
    <span class="n">IdentifierInfo</span> <span class="o">*</span><span class="n">II</span><span class="p">;</span>
    <span class="c1">/// The body of the #define, or nullptr if this is a #undef.</span>
    <span class="n">MacroInfo</span> <span class="o">*</span><span class="n">Macro</span><span class="p">;</span>
    <span class="c1">/// The module that exports this macro.</span>
    <span class="n">Module</span> <span class="o">*</span><span class="n">OwningModule</span><span class="p">;</span>
    <span class="c1">/// The number of module macros that override this one.</span>
    <span class="kt">unsigned</span> <span class="n">NumOverriddenBy</span><span class="p">;</span>
    <span class="c1">/// The number of modules whose macros are directly overridden by this one.</span>
    <span class="kt">unsigned</span> <span class="n">NumOverrides</span><span class="p">;</span>
    <span class="c1">// ModuleMacro *OverriddenMacros[NumOverrides];</span>
<span class="p">}</span>
</pre></div>


<p>从这个的类型继承自<em>FoldingSetNode</em>可以看出，所有的<em>ModuleMacro</em>都是组织为一个<em>FoldingSet</em>之中的。</p>
<h2 id="b7345d">MacroDefinition</h2>
<p>这个类型用来记录当前宏的定义，此外还保留了各个定义历史信息。</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">MacroDefinition</span>
<span class="p">{</span>
    <span class="n">llvm</span><span class="o">::</span><span class="n">PointerIntPair</span><span class="o">&lt;</span><span class="n">DefMacroDirective</span> <span class="o">*</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">LatestLocalAndAmbiguous</span><span class="p">;</span>
    <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">ModuleMacro</span> <span class="o">*&gt;</span> <span class="n">ModuleMacros</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里的<em>LatestLocalAndAmbiguous</em>的最后一位是用来记录当前定义是否有歧义（宏的歧义？）。最新的定义存储在<em>ModuleMacro</em>的<em>back</em>。</p>
<h1 id="713060">宏处理与TokenLexer</h1>
<p>这个类型是用来处理宏展开和<em>_Pragma</em>的，由于我们当前只关心常用的C语法，因此只介绍宏展开这部分。</p>
<p><em>TokenLexer</em>这个类相对来说不算复杂，主要的宏相关数据成员包括：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// Macro - The macro we are expanding from.  This is null if expanding a</span>
<span class="c1">/// token stream.</span>
<span class="c1">///</span>
<span class="n">MacroInfo</span> <span class="o">*</span><span class="n">Macro</span><span class="p">;</span>

<span class="c1">/// ActualArgs - The actual arguments specified for a function-like macro, or</span>
<span class="c1">/// null.  The TokenLexer owns the pointed-to object.</span>
<span class="n">MacroArgs</span> <span class="o">*</span><span class="n">ActualArgs</span><span class="p">;</span>

<span class="c1">/// PP - The current preprocessor object we are expanding for.</span>
<span class="c1">///</span>
<span class="n">Preprocessor</span> <span class="o">&amp;</span><span class="n">PP</span><span class="p">;</span>

<span class="c1">/// Tokens - This is the pointer to an array of tokens that the macro is</span>
<span class="c1">/// defined to, with arguments expanded for function-like macros.  If this is</span>
<span class="c1">/// a token stream, these are the tokens we are returning.  This points into</span>
<span class="c1">/// the macro definition we are lexing from, a cache buffer that is owned by</span>
<span class="c1">/// the preprocessor, or some other buffer that we may or may not own</span>
<span class="c1">/// (depending on OwnsTokens).</span>
<span class="c1">/// Note that if it points into Preprocessor&#39;s cache buffer, the Preprocessor</span>
<span class="c1">/// may update the pointer as needed.</span>
<span class="k">const</span> <span class="n">Token</span> <span class="o">*</span><span class="n">Tokens</span><span class="p">;</span>
</pre></div>


<p>也就是宏名，相关实参和宏体。</p>
<p>主要的源代码位置相关成员包括：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// NumTokens - This is the length of the Tokens array.</span>
<span class="c1">///</span>
<span class="kt">unsigned</span> <span class="n">NumTokens</span><span class="p">;</span>

<span class="c1">/// CurToken - This is the next token that Lex will return.</span>
<span class="c1">///</span>
<span class="kt">unsigned</span> <span class="n">CurToken</span><span class="p">;</span>

<span class="c1">/// ExpandLocStart/End - The source location range where this macro was</span>
<span class="c1">/// expanded.</span>
<span class="n">SourceLocation</span> <span class="n">ExpandLocStart</span><span class="p">,</span> <span class="n">ExpandLocEnd</span><span class="p">;</span>

<span class="c1">/// \brief Source location pointing at the source location entry chunk that</span>
<span class="c1">/// was reserved for the current macro expansion.</span>
<span class="n">SourceLocation</span> <span class="n">MacroExpansionStart</span><span class="p">;</span>

<span class="c1">/// \brief The offset of the macro expansion in the</span>
<span class="c1">/// &quot;source location address space&quot;.</span>
<span class="kt">unsigned</span> <span class="n">MacroStartSLocOffset</span><span class="p">;</span>

<span class="c1">/// \brief Location of the macro definition.</span>
<span class="n">SourceLocation</span> <span class="n">MacroDefStart</span><span class="p">;</span>
<span class="c1">/// \brief Length of the macro definition.</span>
<span class="kt">unsigned</span> <span class="n">MacroDefLength</span><span class="p">;</span>

<span class="c1">/// Lexical information about the expansion point of the macro: the identifier</span>
<span class="c1">/// that the macro expanded from had these properties.</span>
<span class="kt">bool</span> <span class="nl">AtStartOfLine</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">bool</span> <span class="nl">HasLeadingSpace</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// NextTokGetsSpace - When this is true, the next token appended to the</span>
<span class="c1">// output list during function argument expansion will get a leading space,</span>
<span class="c1">// regardless of whether it had one to begin with or not. This is used for</span>
<span class="c1">// placemarker support. If still true after function argument expansion, the</span>
<span class="c1">// leading space will be applied to the first token following the macro</span>
<span class="c1">// expansion.</span>
<span class="kt">bool</span> <span class="nl">NextTokGetsSpace</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">/// OwnsTokens - This is true if this TokenLexer allocated the Tokens</span>
<span class="c1">/// array, and thus needs to free it when destroyed.  For simple object-like</span>
<span class="c1">/// macros (for example) we just point into the token buffer of the macro</span>
<span class="c1">/// definition, we don&#39;t make a copy of it.</span>
<span class="kt">bool</span> <span class="nl">OwnsTokens</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">/// DisableMacroExpansion - This is true when tokens lexed from the TokenLexer</span>
<span class="c1">/// should not be subject to further macro expansion.</span>
<span class="kt">bool</span> <span class="nl">DisableMacroExpansion</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>


<p>这里的注释也算非常详尽，暂不解释。</p>
<h2 id="73e4e5">Function Expansion</h2>
<p>在<em>TokenLexer</em>中最重要的操作就是展开操作，该操作被封装在<em>ExpandFunctionArguments</em>函数中，该函数的签名很简单，无参数无返回值！但是该函数有250多行，比较复杂，分步剖析。</p>
<p>首先是基本存储变量：</p>
<div class="codehilite"><pre><span></span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Token</span><span class="p">,</span> <span class="mi">128</span><span class="o">&gt;</span> <span class="n">ResultToks</span><span class="p">;</span>

<span class="c1">// Loop through &#39;Tokens&#39;, expanding them into ResultToks.  Keep</span>
<span class="c1">// track of whether we change anything.  If not, no need to keep them.  If so,</span>
<span class="c1">// we install the newly expanded sequence as the new &#39;Tokens&#39; list.</span>
<span class="kt">bool</span> <span class="n">MadeChange</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</pre></div>


<p>扫描定义体的时候，首先要判断的是<em>##</em>或者<em>#</em>这个连接符。如果有连接符，则判断后面的是否是形参参数。如果不是形参,则直接报错。如果是形参，则我们需要处理很多细节，如一下代码：</p>
<div class="codehilite"><pre><span></span><span class="k">const</span> <span class="n">Token</span> <span class="o">&amp;</span><span class="n">CurTok</span> <span class="o">=</span> <span class="n">Tokens</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">Tokens</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">hashhash</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">CurTok</span><span class="p">.</span><span class="n">hasLeadingSpace</span><span class="p">())</span>
    <span class="n">NextTokGetsSpace</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span><span class="p">.</span><span class="n">isOneOf</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">hash</span><span class="p">,</span> <span class="n">tok</span><span class="o">::</span><span class="n">hashat</span><span class="p">))</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ArgNo</span> <span class="o">=</span> <span class="n">Macro</span><span class="o">-&gt;</span><span class="n">getArgumentNum</span><span class="p">(</span><span class="n">Tokens</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">getIdentifierInfo</span><span class="p">());</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">ArgNo</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Token following # is not an argument?&quot;</span><span class="p">);</span>

    <span class="n">SourceLocation</span> <span class="n">ExpansionLocStart</span> <span class="o">=</span>
        <span class="n">getExpansionLocForMacroDefLoc</span><span class="p">(</span><span class="n">CurTok</span><span class="p">.</span><span class="n">getLocation</span><span class="p">());</span>
    <span class="n">SourceLocation</span> <span class="n">ExpansionLocEnd</span> <span class="o">=</span>
        <span class="n">getExpansionLocForMacroDefLoc</span><span class="p">(</span><span class="n">Tokens</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">getLocation</span><span class="p">());</span>

    <span class="n">Token</span> <span class="n">Res</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span><span class="p">.</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">hash</span><span class="p">))</span>  <span class="c1">// Stringify</span>
        <span class="n">Res</span> <span class="o">=</span> <span class="n">ActualArgs</span><span class="o">-&gt;</span><span class="n">getStringifiedArgument</span><span class="p">(</span><span class="n">ArgNo</span><span class="p">,</span> <span class="n">PP</span><span class="p">,</span>
            <span class="n">ExpansionLocStart</span><span class="p">,</span>
            <span class="n">ExpansionLocEnd</span><span class="p">);</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="c1">// &#39;charify&#39;: don&#39;t bother caching these.</span>
        <span class="n">Res</span> <span class="o">=</span> <span class="n">MacroArgs</span><span class="o">::</span><span class="n">StringifyArgument</span><span class="p">(</span><span class="n">ActualArgs</span><span class="o">-&gt;</span><span class="n">getUnexpArgument</span><span class="p">(</span><span class="n">ArgNo</span><span class="p">),</span>
            <span class="n">PP</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span>
            <span class="n">ExpansionLocStart</span><span class="p">,</span>
            <span class="n">ExpansionLocEnd</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Res</span><span class="p">.</span><span class="n">setFlag</span><span class="p">(</span><span class="n">Token</span><span class="o">::</span><span class="n">StringifiedInMacro</span><span class="p">);</span>

    <span class="c1">// The stringified/charified string leading space flag gets set to match</span>
    <span class="c1">// the #/#@ operator.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">NextTokGetsSpace</span><span class="p">)</span>
        <span class="n">Res</span><span class="p">.</span><span class="n">setFlag</span><span class="p">(</span><span class="n">Token</span><span class="o">::</span><span class="n">LeadingSpace</span><span class="p">);</span>

    <span class="n">ResultToks</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Res</span><span class="p">);</span>
    <span class="n">MadeChange</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>  <span class="c1">// Skip arg name.</span>
    <span class="n">NextTokGetsSpace</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>要想理解这些代码，我们必须搞清楚两种特殊符<em>#</em>和<em>#</em>之间的区别。一个是<em>Stringify</em>，一个是<em>Charify</em>。这里我们处理的时候会自动吃掉下一个<em>Token</em>，所以这里会<em>++i</em>。</p>
<p>然后需要特殊对待的是<em>##</em>连接符，判断当前<em>Token</em>的前后<em>Token</em>是否是连接符。</p>
<div class="codehilite"><pre><span></span><span class="c1">// Find out if there is a paste (##) operator before or after the token.</span>
<span class="kt">bool</span> <span class="n">NonEmptyPasteBefore</span> <span class="o">=</span>
    <span class="o">!</span><span class="n">ResultToks</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">ResultToks</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">hashhash</span><span class="p">);</span>
<span class="kt">bool</span> <span class="n">PasteBefore</span> <span class="o">=</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">Tokens</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">hashhash</span><span class="p">);</span>
<span class="kt">bool</span> <span class="n">PasteAfter</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">e</span> <span class="o">&amp;&amp;</span> <span class="n">Tokens</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">hashhash</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">NonEmptyPasteBefore</span> <span class="o">||</span> <span class="n">PasteBefore</span><span class="p">);</span>
</pre></div>


<p>然后判断当前<em>Token</em>是否是<em>Arg</em>,如果不是参数的话，直接复制到输出中去：</p>
<div class="codehilite"><pre><span></span><span class="c1">// Otherwise, if this is not an argument token, just add the token to the</span>
<span class="c1">// output buffer.</span>
<span class="n">IdentifierInfo</span> <span class="o">*</span><span class="n">II</span> <span class="o">=</span> <span class="n">CurTok</span><span class="p">.</span><span class="n">getIdentifierInfo</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">ArgNo</span> <span class="o">=</span> <span class="n">II</span> <span class="o">?</span> <span class="n">Macro</span><span class="o">-&gt;</span><span class="n">getArgumentNum</span><span class="p">(</span><span class="n">II</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ArgNo</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// This isn&#39;t an argument, just add it.</span>
    <span class="n">ResultToks</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">CurTok</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">NextTokGetsSpace</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ResultToks</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">setFlag</span><span class="p">(</span><span class="n">Token</span><span class="o">::</span><span class="n">LeadingSpace</span><span class="p">);</span>
        <span class="n">NextTokGetsSpace</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PasteBefore</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">NonEmptyPasteBefore</span><span class="p">)</span>
        <span class="n">ResultToks</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">clearFlag</span><span class="p">(</span><span class="n">Token</span><span class="o">::</span><span class="n">LeadingSpace</span><span class="p">);</span>

    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>否则就只剩下一种情况了，当前的是参数，我们要对字符串做替换。这里又有两种情况，一种是普通替换，一种是<em>##</em>。</p>
<h3 id="b4cf87">普通替换</h3>
<p>对于普通替换，我们需要提前把参数展开好，然后替换：</p>
<div class="codehilite"><pre><span></span><span class="c1">// If it is not the LHS/RHS of a ## operator, we must pre-expand the</span>
<span class="c1">// argument and substitute the expanded tokens into the result.  This is</span>
<span class="c1">// C99 6.10.3.1p1.</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PasteBefore</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PasteAfter</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">Token</span> <span class="o">*</span><span class="n">ResultArgToks</span><span class="p">;</span>

    <span class="c1">// Only preexpand the argument if it could possibly need it.  This</span>
    <span class="c1">// avoids some work in common cases.</span>
    <span class="k">const</span> <span class="n">Token</span> <span class="o">*</span><span class="n">ArgTok</span> <span class="o">=</span> <span class="n">ActualArgs</span><span class="o">-&gt;</span><span class="n">getUnexpArgument</span><span class="p">(</span><span class="n">ArgNo</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ActualArgs</span><span class="o">-&gt;</span><span class="n">ArgNeedsPreexpansion</span><span class="p">(</span><span class="n">ArgTok</span><span class="p">,</span> <span class="n">PP</span><span class="p">))</span>
        <span class="n">ResultArgToks</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ActualArgs</span><span class="o">-&gt;</span><span class="n">getPreExpArgument</span><span class="p">(</span><span class="n">ArgNo</span><span class="p">,</span> <span class="n">Macro</span><span class="p">,</span> <span class="n">PP</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">else</span>
        <span class="n">ResultArgToks</span> <span class="o">=</span> <span class="n">ArgTok</span><span class="p">;</span>  <span class="c1">// Use non-preexpanded tokens.</span>

<span class="c1">// If the arg token expanded into anything, append it.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ResultArgToks</span><span class="o">-&gt;</span><span class="n">isNot</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">eof</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="n">FirstResult</span> <span class="o">=</span> <span class="n">ResultToks</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="kt">unsigned</span> <span class="n">NumToks</span> <span class="o">=</span> <span class="n">MacroArgs</span><span class="o">::</span><span class="n">getArgLength</span><span class="p">(</span><span class="n">ResultArgToks</span><span class="p">);</span>
        <span class="n">ResultToks</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">ResultArgToks</span><span class="p">,</span> <span class="n">ResultArgToks</span> <span class="o">+</span> <span class="n">NumToks</span><span class="p">);</span>

        <span class="c1">// In Microsoft-compatibility mode, we follow MSVC&#39;s preprocessing</span>
        <span class="c1">// behavior by not considering single commas from nested macro</span>
        <span class="c1">// expansions as argument separators. Set a flag on the token so we can</span>
        <span class="c1">// test for this later when the macro expansion is processed.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">PP</span><span class="p">.</span><span class="n">getLangOpts</span><span class="p">().</span><span class="n">MSVCCompat</span> <span class="o">&amp;&amp;</span> <span class="n">NumToks</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
            <span class="n">ResultToks</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">comma</span><span class="p">))</span>
            <span class="n">ResultToks</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">setFlag</span><span class="p">(</span><span class="n">Token</span><span class="o">::</span><span class="n">IgnoredComma</span><span class="p">);</span>

        <span class="c1">// If the &#39;##&#39; came from expanding an argument, turn it into &#39;unknown&#39;</span>
        <span class="c1">// to avoid pasting.</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="n">FirstResult</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">ResultToks</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Token</span> <span class="o">&amp;</span><span class="n">Tok</span> <span class="o">=</span> <span class="n">ResultToks</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">hashhash</span><span class="p">))</span>
                <span class="n">Tok</span><span class="p">.</span><span class="n">setKind</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">unknown</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">ExpandLocStart</span><span class="p">.</span><span class="n">isValid</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">updateLocForMacroArgTokens</span><span class="p">(</span><span class="n">CurTok</span><span class="p">.</span><span class="n">getLocation</span><span class="p">(),</span>
                <span class="n">ResultToks</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">FirstResult</span><span class="p">,</span>
                <span class="n">ResultToks</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="c1">// If any tokens were substituted from the argument, the whitespace</span>
        <span class="c1">// before the first token should match the whitespace of the arg</span>
        <span class="c1">// identifier.</span>
        <span class="n">ResultToks</span><span class="p">[</span><span class="n">FirstResult</span><span class="p">].</span><span class="n">setFlagValue</span><span class="p">(</span><span class="n">Token</span><span class="o">::</span><span class="n">LeadingSpace</span><span class="p">,</span>
            <span class="n">NextTokGetsSpace</span><span class="p">);</span>
        <span class="n">NextTokGetsSpace</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>参数计算好之后，这里的代码除了<em>Token</em>替换之外，主要处理了三个问题：微软带来的逗号分隔标准，参数展开带来的<em>##</em>和新的位置计算。前两个只是做一些标识工作，最后的需要调用函数来重新计算<em>SourceLocation</em>,该函数的定义如下：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief Creates SLocEntries and updates the locations of macro argument</span>
<span class="c1">/// tokens to their new expanded locations.</span>
<span class="c1">///</span>
<span class="c1">/// \param ArgIdDefLoc the location of the macro argument id inside the macro</span>
<span class="c1">/// definition.</span>
<span class="c1">/// \param Tokens the macro argument tokens to update.</span>
<span class="kt">void</span> <span class="n">TokenLexer</span><span class="o">::</span><span class="n">updateLocForMacroArgTokens</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">ArgIdSpellLoc</span><span class="p">,</span>
    <span class="n">Token</span> <span class="o">*</span><span class="n">begin_tokens</span><span class="p">,</span>
    <span class="n">Token</span> <span class="o">*</span><span class="n">end_tokens</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SourceManager</span> <span class="o">&amp;</span><span class="n">SM</span> <span class="o">=</span> <span class="n">PP</span><span class="p">.</span><span class="n">getSourceManager</span><span class="p">();</span>

    <span class="n">SourceLocation</span> <span class="n">InstLoc</span> <span class="o">=</span>
        <span class="n">getExpansionLocForMacroDefLoc</span><span class="p">(</span><span class="n">ArgIdSpellLoc</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">begin_tokens</span> <span class="o">&lt;</span> <span class="n">end_tokens</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// If there&#39;s only one token just create a SLocEntry for it.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">end_tokens</span> <span class="o">-</span> <span class="n">begin_tokens</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Token</span> <span class="o">&amp;</span><span class="n">Tok</span> <span class="o">=</span> <span class="o">*</span><span class="n">begin_tokens</span><span class="p">;</span>
            <span class="n">Tok</span><span class="p">.</span><span class="n">setLocation</span><span class="p">(</span><span class="n">SM</span><span class="p">.</span><span class="n">createMacroArgExpansionLoc</span><span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">getLocation</span><span class="p">(),</span>
                <span class="n">InstLoc</span><span class="p">,</span>
                <span class="n">Tok</span><span class="p">.</span><span class="n">getLength</span><span class="p">()));</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">updateConsecutiveMacroArgTokens</span><span class="p">(</span><span class="n">SM</span><span class="p">,</span> <span class="n">InstLoc</span><span class="p">,</span> <span class="n">begin_tokens</span><span class="p">,</span> <span class="n">end_tokens</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p><em>while</em>循环内，会调用<em>UpdateConsecutiveMacroArgTokens</em>这个名字非常长的函数，来处理连续<em>Token</em>的位置调整，这里的<em>begin_tokens</em>和<em>end_tokens</em>是以引用的形式传递进去的，所以循环才可能终止。这个<em>UpdateConsecutiveMacroArgTokens</em>的签名如下：</p>
<div class="codehilite"><pre><span></span><span class="c1">// \brief Finds the tokens that are consecutive (from the same FileID)</span>
<span class="c1">/// creates a single SLocEntry, and assigns SourceLocations to each token that</span>
<span class="c1">/// point to that SLocEntry. e.g for</span>
<span class="c1">///   assert(foo == bar);</span>
<span class="c1">/// There will be a single SLocEntry for the &quot;foo == bar&quot; chunk and locations</span>
<span class="c1">/// for the &#39;foo&#39;, &#39;==&#39;, &#39;bar&#39; tokens will point inside that chunk.</span>
<span class="c1">///</span>
<span class="c1">/// \arg begin_tokens will be updated to a position past all the found</span>
<span class="c1">/// consecutive tokens.</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">updateConsecutiveMacroArgTokens</span><span class="p">(</span><span class="n">SourceManager</span> <span class="o">&amp;</span><span class="n">SM</span><span class="p">,</span>
    <span class="n">SourceLocation</span> <span class="n">InstLoc</span><span class="p">,</span>
    <span class="n">Token</span> <span class="o">*&amp;</span><span class="n">begin_tokens</span><span class="p">,</span>
    <span class="n">Token</span> <span class="o">*</span> <span class="n">end_tokens</span><span class="p">)</span>
</pre></div>


<p>其实内部操作很简单，就是一直扫描处于同一文件之中且相邻距离不超过50个字符的<em>Token</em>，合并为一个<em>SlocEntry</em>以压缩存储，但是各个<em>Token</em>的<em>SourceLocation</em>还是各自维持的。寻找连续<em>Token</em>的代码如下：</p>
<div class="codehilite"><pre><span></span><span class="n">assert</span><span class="p">(</span><span class="n">begin_tokens</span> <span class="o">&lt;</span> <span class="n">end_tokens</span><span class="p">);</span>

<span class="n">SourceLocation</span> <span class="n">FirstLoc</span> <span class="o">=</span> <span class="n">begin_tokens</span><span class="o">-&gt;</span><span class="n">getLocation</span><span class="p">();</span>
<span class="n">SourceLocation</span> <span class="n">CurLoc</span> <span class="o">=</span> <span class="n">FirstLoc</span><span class="p">;</span>

<span class="c1">// Compare the source location offset of tokens and group together tokens that</span>
<span class="c1">// are close, even if their locations point to different FileIDs. e.g.</span>
<span class="c1">//</span>
<span class="c1">//  |bar    |  foo | cake   |  (3 tokens from 3 consecutive FileIDs)</span>
<span class="c1">//  ^                    ^</span>
<span class="c1">//  |bar       foo   cake|     (one SLocEntry chunk for all tokens)</span>
<span class="c1">//</span>
<span class="c1">// we can perform this &quot;merge&quot; since the token&#39;s spelling location depends</span>
<span class="c1">// on the relative offset.</span>

<span class="n">Token</span> <span class="o">*</span><span class="n">NextTok</span> <span class="o">=</span> <span class="n">begin_tokens</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(;</span> <span class="n">NextTok</span> <span class="o">&lt;</span> <span class="n">end_tokens</span><span class="p">;</span> <span class="o">++</span><span class="n">NextTok</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SourceLocation</span> <span class="n">NextLoc</span> <span class="o">=</span> <span class="n">NextTok</span><span class="o">-&gt;</span><span class="n">getLocation</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">CurLoc</span><span class="p">.</span><span class="n">isFileID</span><span class="p">()</span> <span class="o">!=</span> <span class="n">NextLoc</span><span class="p">.</span><span class="n">isFileID</span><span class="p">())</span>
        <span class="k">break</span><span class="p">;</span> <span class="c1">// Token from different kind of FileID.</span>

    <span class="kt">int</span> <span class="n">RelOffs</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SM</span><span class="p">.</span><span class="n">isInSameSLocAddrSpace</span><span class="p">(</span><span class="n">CurLoc</span><span class="p">,</span> <span class="n">NextLoc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RelOffs</span><span class="p">))</span>
        <span class="k">break</span><span class="p">;</span> <span class="c1">// Token from different local/loaded location.</span>
 <span class="c1">// Check that token is not before the previous token or more than 50</span>
 <span class="c1">// &quot;characters&quot; away.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">RelOffs</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">RelOffs</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">)</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="n">CurLoc</span> <span class="o">=</span> <span class="n">NextLoc</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>之后的处理相对来说就比较简单，填充对应的<em>SlocEntry</em>，维持各个<em>Token</em>的<em>SourceLocation</em>。</p>
<div class="codehilite"><pre><span></span><span class="c1">// For the consecutive tokens, find the length of the SLocEntry to contain</span>
<span class="c1">// all of them.</span>
<span class="n">Token</span> <span class="o">&amp;</span><span class="n">LastConsecutiveTok</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">NextTok</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">LastRelOffs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">SM</span><span class="p">.</span><span class="n">isInSameSLocAddrSpace</span><span class="p">(</span><span class="n">FirstLoc</span><span class="p">,</span> <span class="n">LastConsecutiveTok</span><span class="p">.</span><span class="n">getLocation</span><span class="p">(),</span>
    <span class="o">&amp;</span><span class="n">LastRelOffs</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="n">FullLength</span> <span class="o">=</span> <span class="n">LastRelOffs</span> <span class="o">+</span> <span class="n">LastConsecutiveTok</span><span class="p">.</span><span class="n">getLength</span><span class="p">();</span>

<span class="c1">// Create a macro expansion SLocEntry that will &quot;contain&quot; all of the tokens.</span>
<span class="n">SourceLocation</span> <span class="n">Expansion</span> <span class="o">=</span>
    <span class="n">SM</span><span class="p">.</span><span class="n">createMacroArgExpansionLoc</span><span class="p">(</span><span class="n">FirstLoc</span><span class="p">,</span> <span class="n">InstLoc</span><span class="p">,</span> <span class="n">FullLength</span><span class="p">);</span>

<span class="c1">// Change the location of the tokens from the spelling location to the new</span>
<span class="c1">// expanded location.</span>
<span class="k">for</span> <span class="p">(;</span> <span class="n">begin_tokens</span> <span class="o">&lt;</span> <span class="n">NextTok</span><span class="p">;</span> <span class="o">++</span><span class="n">begin_tokens</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Token</span> <span class="o">&amp;</span><span class="n">Tok</span> <span class="o">=</span> <span class="o">*</span><span class="n">begin_tokens</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">RelOffs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">SM</span><span class="p">.</span><span class="n">isInSameSLocAddrSpace</span><span class="p">(</span><span class="n">FirstLoc</span><span class="p">,</span> <span class="n">Tok</span><span class="p">.</span><span class="n">getLocation</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">RelOffs</span><span class="p">);</span>
    <span class="n">Tok</span><span class="p">.</span><span class="n">setLocation</span><span class="p">(</span><span class="n">Expansion</span><span class="p">.</span><span class="n">getLocWithOffset</span><span class="p">(</span><span class="n">RelOffs</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>


<h3 id="89f7d5">##拼接</h3>
<p>简单来说，在C语言的宏中是容许嵌套的，其嵌套后，一般的展开规律像函数的参数一样，先展开参数，在分析函数，所以展开顺序是由内而外。但是当宏中有<em>#</em>则不再展开参数了，如果宏中有<em>##</em>，则先展开函数，再展开里面的参数。所以在处理<em>##</em>时，不能使用展开之后的实参，只能用未展开之前的实参。所以我们需要如下处理，首先获得实参未展开形式：</p>
<div class="codehilite"><pre><span></span><span class="c1">// Okay, we have a token that is either the LHS or RHS of a paste (##)</span>
<span class="c1">// argument.  It gets substituted as its non-pre-expanded tokens.</span>
<span class="k">const</span> <span class="n">Token</span> <span class="o">*</span><span class="n">ArgToks</span> <span class="o">=</span> <span class="n">ActualArgs</span><span class="o">-&gt;</span><span class="n">getUnexpArgument</span><span class="p">(</span><span class="n">ArgNo</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="n">NumToks</span> <span class="o">=</span> <span class="n">MacroArgs</span><span class="o">::</span><span class="n">getArgLength</span><span class="p">(</span><span class="n">ArgToks</span><span class="p">);</span>
</pre></div>


<p>如果实参不为空，则需要进行拼接处理，这里又会遇到<em>GNU comma</em>这个烦人的东西，其形式为<em>, ## __VA_ARGS__</em>，此时我们需要把这个扩展的使用记录下来，同时将<em>##</em>弹出，然后再进行处理。</p>
<p>处理时首先把这个参数放入结果<em>Token</em>数组中，如果压入的这些<em>Token</em>也包含<em>##</em>，标记为<em>tok::unknown</em>。此外还要处理是否保留第一个空格的问题，所以这部分总的代码如下：</p>
<div class="codehilite"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">NumToks</span><span class="p">)</span>
<span class="p">{</span>  <span class="c1">// Not an empty argument?</span>
<span class="c1">// If this is the GNU &quot;, ## __VA_ARGS__&quot; extension, and we just learned</span>
<span class="c1">// that __VA_ARGS__ expands to multiple tokens, avoid a pasting error when</span>
<span class="c1">// the expander trys to paste &#39;,&#39; with the first token of the __VA_ARGS__</span>
<span class="c1">// expansion.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">NonEmptyPasteBefore</span> <span class="o">&amp;&amp;</span> <span class="n">ResultToks</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span>
        <span class="n">ResultToks</span><span class="p">[</span><span class="n">ResultToks</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">].</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">comma</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">ArgNo</span> <span class="o">==</span> <span class="n">Macro</span><span class="o">-&gt;</span><span class="n">getNumArgs</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
        <span class="n">Macro</span><span class="o">-&gt;</span><span class="n">isVariadic</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="c1">// Remove the paste operator, report use of the extension.</span>
        <span class="n">PP</span><span class="p">.</span><span class="n">Diag</span><span class="p">(</span><span class="n">ResultToks</span><span class="p">.</span><span class="n">pop_back_val</span><span class="p">().</span><span class="n">getLocation</span><span class="p">(),</span> <span class="n">diag</span><span class="o">::</span><span class="n">ext_paste_comma</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">ResultToks</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">ArgToks</span><span class="p">,</span> <span class="n">ArgToks</span> <span class="o">+</span> <span class="n">NumToks</span><span class="p">);</span>

    <span class="c1">// If the &#39;##&#39; came from expanding an argument, turn it into &#39;unknown&#39;</span>
    <span class="c1">// to avoid pasting.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ResultToks</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="n">NumToks</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">ResultToks</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Token</span> <span class="o">&amp;</span><span class="n">Tok</span> <span class="o">=</span> <span class="n">ResultToks</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">hashhash</span><span class="p">))</span>
            <span class="n">Tok</span><span class="p">.</span><span class="n">setKind</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">unknown</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ExpandLocStart</span><span class="p">.</span><span class="n">isValid</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">updateLocForMacroArgTokens</span><span class="p">(</span><span class="n">CurTok</span><span class="p">.</span><span class="n">getLocation</span><span class="p">(),</span>
            <span class="n">ResultToks</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="n">NumToks</span><span class="p">,</span> <span class="n">ResultToks</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="c1">// If this token (the macro argument) was supposed to get leading</span>
    <span class="c1">// whitespace, transfer this information onto the first token of the</span>
    <span class="c1">// expansion.</span>
    <span class="c1">//</span>
    <span class="c1">// Do not do this if the paste operator occurs before the macro argument,</span>
    <span class="c1">// as in &quot;A ## MACROARG&quot;.  In valid code, the first token will get</span>
    <span class="c1">// smooshed onto the preceding one anyway (forming AMACROARG).  In</span>
    <span class="c1">// assembler-with-cpp mode, invalid pastes are allowed through: in this</span>
    <span class="c1">// case, we do not want the extra whitespace to be added.  For example,</span>
    <span class="c1">// we want &quot;. ## foo&quot; -&gt; &quot;.foo&quot; not &quot;. foo&quot;.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">NextTokGetsSpace</span><span class="p">)</span>
        <span class="n">ResultToks</span><span class="p">[</span><span class="n">ResultToks</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="n">NumToks</span><span class="p">].</span><span class="n">setFlag</span><span class="p">(</span><span class="n">Token</span><span class="o">::</span><span class="n">LeadingSpace</span><span class="p">);</span>

    <span class="n">NextTokGetsSpace</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>此处还有一个特殊情况，如果<em>##</em>连接符的任何一个参数是空的话，直接忽略当前连接符。</p>
<div class="codehilite"><pre><span></span><span class="c1">// If an empty argument is on the LHS or RHS of a paste, the standard (C99</span>
<span class="c1">// 6.10.3.3p2,3) calls for a bunch of placemarker stuff to occur.  We</span>
<span class="c1">// implement this by eating ## operators when a LHS or RHS expands to</span>
<span class="c1">// empty.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">PasteAfter</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Discard the argument token and skip (don&#39;t copy to the expansion</span>
    <span class="c1">// buffer) the paste operator after it.</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h3 id="2c3d57">宏cache</h3>
<p>如果这个宏会被多次展开的话，我们可以复用之前分析的结果，放进<em>cacheMacro</em>中，同时当前<em>ResultTokens</em>的所有权也被转移到了<em>PrePocessor</em>之中。</p>
<div class="codehilite"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">MadeChange</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">OwnsTokens</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;This would leak if we already own the token list&quot;</span><span class="p">);</span>
    <span class="c1">// This is deleted in the dtor.</span>
    <span class="n">NumTokens</span> <span class="o">=</span> <span class="n">ResultToks</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="c1">// The tokens will be added to Preprocessor&#39;s cache and will be removed</span>
    <span class="c1">// when this TokenLexer finishes lexing them.</span>
    <span class="n">Tokens</span> <span class="o">=</span> <span class="n">PP</span><span class="p">.</span><span class="n">cacheMacroExpandedTokens</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">ResultToks</span><span class="p">);</span>

    <span class="c1">// The preprocessor cache of macro expanded tokens owns these tokens,not us.</span>
    <span class="n">OwnsTokens</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>而<em>TokenLexer</em>的各个构造函数都会调用<em>init</em>这个函数，由此可见他的重要程度。该函数的签名如下：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// Init - Initialize this TokenLexer to expand from the specified macro</span>
<span class="c1">/// with the specified argument information.  Note that this ctor takes</span>
<span class="c1">/// ownership of the ActualArgs pointer.  ILEnd specifies the location of the</span>
<span class="c1">/// &#39;)&#39; for a function-like macro or the identifier for an object-like macro.</span>
<span class="kt">void</span> <span class="nf">Init</span><span class="p">(</span><span class="n">Token</span> <span class="o">&amp;</span><span class="n">Tok</span><span class="p">,</span> <span class="n">SourceLocation</span> <span class="n">ILEnd</span><span class="p">,</span> <span class="n">MacroInfo</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span>
    <span class="n">MacroArgs</span> <span class="o">*</span><span class="n">ActualArgs</span><span class="p">);</span>
</pre></div>


<p>这几个参数包括：展开开始位点，展开结束位点，宏定义信息，宏实参信息。</p>
<p>由于<em>TokenLexer</em>是一个可复用的对象，所以我们在调用<em>init</em>时，首先需要释放之前占有的资源，需要调用一个<em>destroy</em>函数：</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">TokenLexer</span><span class="o">::</span><span class="n">destroy</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// If this was a function-like macro that actually uses its arguments, delete</span>
    <span class="c1">// the expanded tokens.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">OwnsTokens</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">Tokens</span><span class="p">;</span>
        <span class="n">Tokens</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="n">OwnsTokens</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// TokenLexer owns its formal arguments.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ActualArgs</span><span class="p">)</span> <span class="n">ActualArgs</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="n">PP</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>这个函数作用就是释放占有的<em>Token</em>和<em>ActualArgs</em>，这些都是属于上一个宏的。</p>
<p>在释放这些资源之后，以输入参数重置当前<em>TokenLexer</em>，所以<em>init</em>的开头代码定义如下：</p>
<div class="codehilite"><pre><span></span><span class="n">destroy</span><span class="p">();</span>

<span class="n">Macro</span> <span class="o">=</span> <span class="n">MI</span><span class="p">;</span>
<span class="n">ActualArgs</span> <span class="o">=</span> <span class="n">Actuals</span><span class="p">;</span>
<span class="n">CurToken</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">ExpandLocStart</span> <span class="o">=</span> <span class="n">Tok</span><span class="p">.</span><span class="n">getLocation</span><span class="p">();</span>
<span class="n">ExpandLocEnd</span> <span class="o">=</span> <span class="n">ELEnd</span><span class="p">;</span>
<span class="n">AtStartOfLine</span> <span class="o">=</span> <span class="n">Tok</span><span class="p">.</span><span class="n">isAtStartOfLine</span><span class="p">();</span>
<span class="n">HasLeadingSpace</span> <span class="o">=</span> <span class="n">Tok</span><span class="p">.</span><span class="n">hasLeadingSpace</span><span class="p">();</span>
<span class="n">NextTokGetsSpace</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="n">Tokens</span> <span class="o">=</span> <span class="o">&amp;*</span><span class="n">Macro</span><span class="o">-&gt;</span><span class="n">tokens_begin</span><span class="p">();</span>
<span class="n">OwnsTokens</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="n">DisableMacroExpansion</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="n">NumTokens</span> <span class="o">=</span> <span class="n">Macro</span><span class="o">-&gt;</span><span class="n">tokens_end</span><span class="p">()</span> <span class="o">-</span> <span class="n">Macro</span><span class="o">-&gt;</span><span class="n">tokens_begin</span><span class="p">();</span>
<span class="n">MacroExpansionStart</span> <span class="o">=</span> <span class="n">SourceLocation</span><span class="p">();</span>

<span class="n">SourceManager</span> <span class="o">&amp;</span><span class="n">SM</span> <span class="o">=</span> <span class="n">PP</span><span class="p">.</span><span class="n">getSourceManager</span><span class="p">();</span>
<span class="n">MacroStartSLocOffset</span> <span class="o">=</span> <span class="n">SM</span><span class="p">.</span><span class="n">getNextLocalOffset</span><span class="p">();</span>
</pre></div>


<p>各种初始化！然后是预留空间:</p>
<div class="codehilite"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">NumTokens</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">Tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">getLocation</span><span class="p">().</span><span class="n">isValid</span><span class="p">());</span>
    <span class="n">assert</span><span class="p">((</span><span class="n">Tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">getLocation</span><span class="p">().</span><span class="n">isFileID</span><span class="p">()</span> <span class="o">||</span> <span class="n">Tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">comment</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
        <span class="s">&quot;Macro defined in macro?&quot;</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">ExpandLocStart</span><span class="p">.</span><span class="n">isValid</span><span class="p">());</span>

    <span class="c1">// Reserve a source location entry chunk for the length of the macro</span>
    <span class="c1">// definition. Tokens that get lexed directly from the definition will</span>
    <span class="c1">// have their locations pointing inside this chunk. This is to avoid</span>
    <span class="c1">// creating separate source location entries for each token.</span>
    <span class="n">MacroDefStart</span> <span class="o">=</span> <span class="n">SM</span><span class="p">.</span><span class="n">getExpansionLoc</span><span class="p">(</span><span class="n">Tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">getLocation</span><span class="p">());</span>
    <span class="n">MacroDefLength</span> <span class="o">=</span> <span class="n">Macro</span><span class="o">-&gt;</span><span class="n">getDefinitionLength</span><span class="p">(</span><span class="n">SM</span><span class="p">);</span>
    <span class="n">MacroExpansionStart</span> <span class="o">=</span> <span class="n">SM</span><span class="p">.</span><span class="n">createExpansionLoc</span><span class="p">(</span><span class="n">MacroDefStart</span><span class="p">,</span>
        <span class="n">ExpandLocStart</span><span class="p">,</span>
        <span class="n">ExpandLocEnd</span><span class="p">,</span>
        <span class="n">MacroDefLength</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>如果是带参宏函数，则展开该宏函数：</p>
<div class="codehilite"><pre><span></span><span class="c1">// If this is a function-like macro, expand the arguments and change</span>
<span class="c1">// Tokens to point to the expanded tokens.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Macro</span><span class="o">-&gt;</span><span class="n">isFunctionLike</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">Macro</span><span class="o">-&gt;</span><span class="n">getNumArgs</span><span class="p">())</span>
    <span class="n">ExpandFunctionArguments</span><span class="p">();</span>
</pre></div>


<h2 id="976472">Lex</h2>
<p>这里的<em>Lex</em>函数的每次调用会返回一个<em>Token</em>，并把这个<em>Token</em>从结果中剔除，类似于
<em>queue.pop_front()</em> 操作。其函数签名见下：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// Lex - Lex and return a token from this macro stream.</span>
<span class="c1">///</span>
<span class="kt">bool</span> <span class="n">TokenLexer</span><span class="o">::</span><span class="n">Lex</span><span class="p">(</span><span class="n">Token</span> <span class="o">&amp;</span><span class="n">Tok</span><span class="p">)</span>
</pre></div>


<p>函数执行时，首先判断是否到了<em>Buffer</em>的末尾。如果到了，则允许当前宏在其他过程中展开，最后的处理会委托到<em>Preprocessor</em>中进行：</p>
<div class="codehilite"><pre><span></span><span class="c1">// Lexing off the end of the macro, pop this macro off the expansion stack.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">isAtEnd</span><span class="p">())</span>
<span class="p">{</span>
    <span class="c1">// If this is a macro (not a token stream), mark the macro enabled now</span>
    <span class="c1">// that it is no longer being expanded.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Macro</span><span class="p">)</span> <span class="n">Macro</span><span class="o">-&gt;</span><span class="n">EnableMacro</span><span class="p">();</span>

    <span class="n">Tok</span><span class="p">.</span><span class="n">startToken</span><span class="p">();</span>
    <span class="n">Tok</span><span class="p">.</span><span class="n">setFlagValue</span><span class="p">(</span><span class="n">Token</span><span class="o">::</span><span class="n">StartOfLine</span><span class="p">,</span> <span class="n">AtStartOfLine</span><span class="p">);</span>
    <span class="n">Tok</span><span class="p">.</span><span class="n">setFlagValue</span><span class="p">(</span><span class="n">Token</span><span class="o">::</span><span class="n">LeadingSpace</span><span class="p">,</span> <span class="n">HasLeadingSpace</span> <span class="o">||</span> <span class="n">NextTokGetsSpace</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">CurToken</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">Tok</span><span class="p">.</span><span class="n">setFlag</span><span class="p">(</span><span class="n">Token</span><span class="o">::</span><span class="n">LeadingEmptyMacro</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">PP</span><span class="p">.</span><span class="n">HandleEndOfTokenLexer</span><span class="p">(</span><span class="n">Tok</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>不是末尾的话，获得当前<em>Token</em>，同时判断下一个<em>Token</em>是否是<em>##</em>符。</p>
<div class="codehilite"><pre><span></span><span class="n">SourceManager</span> <span class="o">&amp;</span><span class="n">SM</span> <span class="o">=</span> <span class="n">PP</span><span class="p">.</span><span class="n">getSourceManager</span><span class="p">();</span>

<span class="c1">// If this is the first token of the expanded result, we inherit spacing</span>
<span class="c1">// properties later.</span>
<span class="kt">bool</span> <span class="n">isFirstToken</span> <span class="o">=</span> <span class="n">CurToken</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// Get the next token to return.</span>
<span class="n">Tok</span> <span class="o">=</span> <span class="n">Tokens</span><span class="p">[</span><span class="n">CurToken</span><span class="o">++</span><span class="p">];</span>

<span class="kt">bool</span> <span class="n">TokenIsFromPaste</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</pre></div>


<p>如果是<em>##</em>符，则需要<em>PasteToken</em>操作：</p>
<div class="codehilite"><pre><span></span><span class="c1">// If this token is followed by a token paste (##) operator, paste the tokens!</span>
<span class="c1">// Note that ## is a normal token when not expanding a macro.</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isAtEnd</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">Macro</span> <span class="o">&amp;&amp;</span>
    <span class="p">(</span><span class="n">Tokens</span><span class="p">[</span><span class="n">CurToken</span><span class="p">].</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">hashhash</span><span class="p">)</span> <span class="o">||</span>
        <span class="c1">// Special processing of L#x macros in -fms-compatibility mode.</span>
        <span class="c1">// Microsoft compiler is able to form a wide string literal from</span>
        <span class="c1">// &#39;L#macro_arg&#39; construct in a function-like macro.</span>
        <span class="p">(</span><span class="n">PP</span><span class="p">.</span><span class="n">getLangOpts</span><span class="p">().</span><span class="n">MSVCCompat</span> <span class="o">&amp;&amp;</span>
            <span class="n">isWideStringLiteralFromMacro</span><span class="p">(</span><span class="n">Tok</span><span class="p">,</span> <span class="n">Tokens</span><span class="p">[</span><span class="n">CurToken</span><span class="p">]))))</span>
<span class="p">{</span>
    <span class="c1">// When handling the microsoft /##/ extension, the final token is</span>
    <span class="c1">// returned by PasteTokens, not the pasted token.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PasteTokens</span><span class="p">(</span><span class="n">Tok</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

    <span class="n">TokenIsFromPaste</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里的<em>PasteTokens</em>操作非常的长，这里就不详细说明了，主要是我自己还看不懂！大意就是将<em>##</em>两边的操作符连接起来组成一个<em>Identifier</em>，需要注意的是有需要递归处理的情况，如多个连接符。这里就贴一下该函数的签名以及注释吧：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// PasteTokens - Tok is the LHS of a ## operator, and CurToken is the ##</span>
<span class="c1">/// operator.  Read the ## and RHS, and paste the LHS/RHS together.  If there</span>
<span class="c1">/// are more ## after it, chomp them iteratively.  Return the result as Tok.</span>
<span class="c1">/// If this returns true, the caller should immediately return the token.</span>
<span class="kt">bool</span> <span class="n">TokenLexer</span><span class="o">::</span><span class="n">PasteTokens</span><span class="p">(</span><span class="n">Token</span> <span class="o">&amp;</span><span class="n">Tok</span><span class="p">)</span>
</pre></div>


<p>如果下一个是普通<em>Token</em>，则我们只需要修正一下位置信息即可：</p>
<div class="codehilite"><pre><span></span><span class="c1">// The token&#39;s current location indicate where the token was lexed from.  We</span>
<span class="c1">// need this information to compute the spelling of the token, but any</span>
<span class="c1">// diagnostics for the expanded token should appear as if they came from</span>
<span class="c1">// ExpansionLoc.  Pull this information together into a new SourceLocation</span>
<span class="c1">// that captures all of this.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ExpandLocStart</span><span class="p">.</span><span class="n">isValid</span><span class="p">()</span> <span class="o">&amp;&amp;</span>   <span class="c1">// Don&#39;t do this for token streams.</span>
    <span class="c1">// Check that the token&#39;s location was not already set properly.</span>
    <span class="n">SM</span><span class="p">.</span><span class="n">isBeforeInSLocAddrSpace</span><span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">getLocation</span><span class="p">(),</span> <span class="n">MacroStartSLocOffset</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">SourceLocation</span> <span class="n">instLoc</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">comment</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">instLoc</span> <span class="o">=</span> <span class="n">SM</span><span class="p">.</span><span class="n">createExpansionLoc</span><span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">getLocation</span><span class="p">(),</span>
            <span class="n">ExpandLocStart</span><span class="p">,</span>
            <span class="n">ExpandLocEnd</span><span class="p">,</span>
            <span class="n">Tok</span><span class="p">.</span><span class="n">getLength</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">instLoc</span> <span class="o">=</span> <span class="n">getExpansionLocForMacroDefLoc</span><span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">getLocation</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="n">Tok</span><span class="p">.</span><span class="n">setLocation</span><span class="p">(</span><span class="n">instLoc</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>剩下的就是一些错误处理相关的东西，如果我们当前的<em>Token</em>是一个<em>Identifier</em>，则需要判断该<em>Identifier</em>是否有效，无效的话扔进错误处理：</p>
<div class="codehilite"><pre><span></span><span class="c1">// Handle recursive expansion!</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Tok</span><span class="p">.</span><span class="n">isAnnotation</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">Tok</span><span class="p">.</span><span class="n">getIdentifierInfo</span><span class="p">()</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Change the kind of this identifier to the appropriate token kind, e.g.</span>
    <span class="c1">// turning &quot;for&quot; into a keyword.</span>
    <span class="n">IdentifierInfo</span> <span class="o">*</span><span class="n">II</span> <span class="o">=</span> <span class="n">Tok</span><span class="p">.</span><span class="n">getIdentifierInfo</span><span class="p">();</span>
    <span class="n">Tok</span><span class="p">.</span><span class="n">setKind</span><span class="p">(</span><span class="n">II</span><span class="o">-&gt;</span><span class="n">getTokenID</span><span class="p">());</span>

    <span class="c1">// If this identifier was poisoned and from a paste, emit an error.  This</span>
    <span class="c1">// won&#39;t be handled by Preprocessor::HandleIdentifier because this is coming</span>
    <span class="c1">// from a macro expansion.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">II</span><span class="o">-&gt;</span><span class="n">isPoisoned</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">TokenIsFromPaste</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">PP</span><span class="p">.</span><span class="n">HandlePoisonedIdentifier</span><span class="p">(</span><span class="n">Tok</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">DisableMacroExpansion</span> <span class="o">&amp;&amp;</span> <span class="n">II</span><span class="o">-&gt;</span><span class="n">isHandleIdentifierCase</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">PP</span><span class="p">.</span><span class="n">HandleIdentifier</span><span class="p">(</span><span class="n">Tok</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h1 id="b9e535">预处理器</h1>
<h2 id="6ee895">预处理回调</h2>
<p>预处理回调相关接口都放在PPCallbacks里面，这里提供了很多在预处理期间可以暴露的接口。其中比较重要的接口如下</p>
<ol>
<li>InclusionDirective 当一个头文件引入指令或者一个模块引入指令被处理时回调</li>
<li>PragmaDirective 当一个pragma指令被处理时的回调</li>
<li>MacroExpands 当Preprocessor::HandleMacroExpandedIdentifier发现了一个宏展开时的回调</li>
<li>MacroDefined，MacroUndefined，Defined 顾名思义</li>
<li>If，Elif， Ifdef，Ifndef， Else，Endif 顾名思义</li>
</ol>
<p>为了处理多个回调的情况，这里还定义了一个PPChainedCallbacks, 就是一个callback的pair，调用的时候会首先调用First，然后调用Second。</p>
<div class="codehilite"><pre><span></span>    <span class="c1">/// \brief Simple wrapper class for chaining callbacks.</span>
<span class="k">class</span> <span class="nc">PPChainedCallbacks</span> <span class="o">:</span> <span class="k">public</span> <span class="n">PPCallbacks</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">anchor</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">PPCallbacks</span><span class="o">&gt;</span> <span class="n">First</span><span class="p">,</span> <span class="n">Second</span><span class="p">;</span>

    <span class="k">public</span><span class="o">:</span>
    <span class="n">PPChainedCallbacks</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">PPCallbacks</span><span class="o">&gt;</span> <span class="n">_First</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">PPCallbacks</span><span class="o">&gt;</span> <span class="n">_Second</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">First</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">_First</span><span class="p">)),</span> <span class="n">Second</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">_Second</span><span class="p">))</span>
    <span class="p">{}</span>
<span class="p">}</span>
</pre></div>


<p>从这些接口就可以基本了解到预处理期间的主要工作了。</p>
<h2 id="f607fd">Pragma</h2>
<p>pragma的处理基本都在pragma.h里。在clang里，将pragma的引用形式分为了三种变体：</p>
<div class="codehilite"><pre><span></span><span class="k">enum</span> <span class="n">PragmaIntroducerKind</span>
<span class="p">{</span>
    <span class="cm">/**</span>
<span class="cm">    * \brief The pragma was introduced via \#pragma.</span>
<span class="cm">    */</span>
    <span class="n">PIK_HashPragma</span><span class="p">,</span>

    <span class="cm">/**</span>
<span class="cm">    * \brief The pragma was introduced via the C99 _Pragma(string-literal).</span>
<span class="cm">    */</span>
    <span class="n">PIK__Pragma</span><span class="p">,</span>

    <span class="cm">/**</span>
<span class="cm">    * \brief The pragma was introduced via the Microsoft</span>
<span class="cm">    * __pragma(token-string).</span>
<span class="cm">    */</span>
    <span class="n">PIK___pragma</span>
<span class="p">};</span>
</pre></div>


<p>/par 每次引入一个pragma的时候，都会生成一个对应的pragmahandler来处理：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">PragmaHandler</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Name</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
    <span class="k">explicit</span> <span class="n">PragmaHandler</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">name</span><span class="p">)</span> <span class="o">:</span> <span class="n">Name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="p">{}</span>
    <span class="n">PragmaHandler</span><span class="p">()</span>
    <span class="p">{}</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">PragmaHandler</span><span class="p">();</span>

    <span class="n">StringRef</span> <span class="nf">getName</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Name</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">HandlePragma</span><span class="p">(</span><span class="n">Preprocessor</span> <span class="o">&amp;</span><span class="n">PP</span><span class="p">,</span> <span class="n">PragmaIntroducerKind</span> <span class="n">Introducer</span><span class="p">,</span>
    <span class="n">Token</span> <span class="o">&amp;</span><span class="n">FirstToken</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">/// getIfNamespace - If this is a namespace, return it.  This is equivalent to</span>
    <span class="c1">/// using a dynamic_cast, but doesn&#39;t require RTTI.</span>
    <span class="k">virtual</span> <span class="n">PragmaNamespace</span> <span class="o">*</span><span class="nf">getIfNamespace</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>每个handler都会有这个pragma的名字和对应的PragmaNamespace。PragmaNamespace其实也继承pragmahandler，只不过内部又存储了一个stringMap\<PragmaHandler*>，可以理解为一个目录树的结构。</p>
<div class="codehilite"><pre><span></span><span class="c1">/// PragmaNamespace - This PragmaHandler subdivides the namespace of pragmas,</span>
<span class="c1">/// allowing hierarchical pragmas to be defined.  Common examples of namespaces</span>
<span class="c1">/// are &quot;\#pragma GCC&quot;, &quot;\#pragma STDC&quot;, and &quot;\#pragma omp&quot;, but any namespaces</span>
<span class="c1">/// may be (potentially recursively) defined.</span>
<span class="k">class</span> <span class="nc">PragmaNamespace</span> <span class="o">:</span> <span class="k">public</span> <span class="n">PragmaHandler</span>
<span class="p">{</span>
    <span class="c1">/// Handlers - This is a map of the handlers in this namespace with their name</span>
    <span class="c1">/// as key.</span>
    <span class="c1">///</span>
    <span class="n">llvm</span><span class="o">::</span><span class="n">StringMap</span><span class="o">&lt;</span><span class="n">PragmaHandler</span><span class="o">*&gt;</span> <span class="n">Handlers</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>pragma的具体处理函数是handlePragma，其实就是在当前PragmaNamespace里查找对应的handler来委托处理：</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">PragmaNamespace</span><span class="o">::</span><span class="n">HandlePragma</span><span class="p">(</span><span class="n">Preprocessor</span> <span class="o">&amp;</span><span class="n">PP</span><span class="p">,</span>
<span class="n">PragmaIntroducerKind</span> <span class="n">Introducer</span><span class="p">,</span>
<span class="n">Token</span> <span class="o">&amp;</span><span class="n">Tok</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Read the &#39;namespace&#39; that the directive is in, e.g. STDC.  Do not macro</span>
    <span class="c1">// expand it, the user can have a STDC #define, that should not affect this.</span>
    <span class="n">PP</span><span class="p">.</span><span class="n">LexUnexpandedToken</span><span class="p">(</span><span class="n">Tok</span><span class="p">);</span>

    <span class="c1">// Get the handler for this token.  If there is no handler, ignore the pragma.</span>
    <span class="n">PragmaHandler</span> <span class="o">*</span><span class="n">Handler</span>
    <span class="o">=</span> <span class="n">FindHandler</span><span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">getIdentifierInfo</span><span class="p">()</span> <span class="o">?</span> <span class="n">Tok</span><span class="p">.</span><span class="n">getIdentifierInfo</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">()</span>
    <span class="o">:</span> <span class="n">StringRef</span><span class="p">(),</span>
    <span class="cm">/*IgnoreNull=*/</span><span class="nb">false</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Handler</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">PP</span><span class="p">.</span><span class="n">Diag</span><span class="p">(</span><span class="n">Tok</span><span class="p">,</span> <span class="n">diag</span><span class="o">::</span><span class="n">warn_pragma_ignored</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Otherwise, pass it down.</span>
    <span class="n">Handler</span><span class="o">-&gt;</span><span class="n">HandlePragma</span><span class="p">(</span><span class="n">PP</span><span class="p">,</span> <span class="n">Introducer</span><span class="p">,</span> <span class="n">Tok</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>一般来说,pragma的处理流程是这样的：发现pragma之后，一路lex到endofline，然后把第一个token当作pragma的名字，用对应的pragmahandler。干扰这个一般流程的因素是宏，需要考虑当前pragma是否在宏展开阶段。宏展开可能导致当前pragma被忽略。下面就是一个pragma与宏相互影响的例子</p>
<div class="codehilite"><pre><span></span><span class="cp">#define EMPTY(x)</span>
<span class="cp">#define INACTIVE(x) EMPTY(x)</span>
<span class="n">INACTIVE</span><span class="p">(</span><span class="n">_Pragma</span><span class="p">(</span><span class="s">&quot;clang diagnostic ignored </span><span class="se">\&quot;</span><span class="s">-Wconversion</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">))</span>
</pre></div>


<p>所以pragma的最终处理流程被修正为了：如果当前的pragma在宏展开里面，则先不处理，记录这个位置为backtrack位点，然后一路lex下去。直到宏处理验证格式正确时才回退到这个backtrack位点，然后在真正的处理pragma。</p>
<p>这里有一个特殊的pragma，#pragma once
，用来标记当前头文件已经处理过了，没必要再重新include一次。</p>
<div class="codehilite"><pre><span></span><span class="c1">/// HandlePragmaOnce - Handle \#pragma once.  OnceTok is the &#39;once&#39;.</span>
<span class="c1">///</span>
<span class="kt">void</span> <span class="n">Preprocessor</span><span class="o">::</span><span class="n">HandlePragmaOnce</span><span class="p">(</span><span class="n">Token</span> <span class="o">&amp;</span><span class="n">OnceTok</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isInPrimaryFile</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">Diag</span><span class="p">(</span><span class="n">OnceTok</span><span class="p">,</span> <span class="n">diag</span><span class="o">::</span><span class="n">pp_pragma_once_in_main_file</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Get the current file lexer we&#39;re looking at.  Ignore _Pragma &#39;files&#39; etc.</span>
    <span class="c1">// Mark the file as a once-only file now.</span>
    <span class="n">HeaderInfo</span><span class="p">.</span><span class="n">MarkFileIncludeOnce</span><span class="p">(</span><span class="n">getCurrentFileLexer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getFileEntry</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>


<p>这里还有一个非常有意思的pragma push_macro和pop_macro。</p>
<ol>
<li>#pragma push_macro(“MACRONAME”) 是把当前与宏MACRONAME 相关联的字符串值保存到栈中;</li>
<li>#pragma pop_acro(“MACRONAME”)是把栈中之前保存的与宏 MACRONAME相关联的字符串值重新关联到宏 MACRNAME 上</li>
</ol>
<p>一般来说代码里面是这样使用的:某段代码前后部分要使用某宏第一种定义,中间部分要使用另一种定义。</p>
<div class="codehilite"><pre><span></span><span class="cp">#define MACRO_FOO an_str_value </span><span class="c1">// 宏 MACRO_FOO 的第一种定义</span>
<span class="cm">/*</span>
<span class="cm">使用 MACRO_FOO 关联 an_str_value 的代码</span>
<span class="cm">*/</span>
<span class="cp">#pragma push_macro(&quot;MACRO_FOO&quot;) </span><span class="c1">// 将 MACRO_FOO 关联的 an_str_value 先保存起来</span>
<span class="cp">#undef MACRO_FOO </span><span class="c1">// 这句不能忘记, 否则会出现宏重复定义的警告信息. </span>

<span class="cp">#define MACRO_FOO another_str_value </span><span class="c1">// 宏 MACRO_FOO 的第二种定义</span>
<span class="cm">/*</span>
<span class="cm">使用 MACRO_FOO 关联 another_str_value 的代码</span>
<span class="cm">*/</span>

<span class="c1">// #undef MACRO_FOO // pop_macro 之前这句不需要, 因为并没有定义宏, 只是重新关联了字符串值而已.</span>
<span class="cp">#pragma pop_macro(&quot;MACRO_FOO&quot;) </span><span class="c1">// 将宏 MACRO_FOO 的值恢复为之前保存的 an_str_value</span>
<span class="cm">/*</span>
<span class="cm">继续使用 MACRO_FOO 关联 an_str_value 的代码</span>
<span class="cm">*/</span> 
</pre></div>


<p>一般来说，这个用法主要用来hook标准自带的宏，例如new。</p>
<p>clang里面预制了一些pragmahandler，并对这些handler都进行了注册：</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Preprocessor</span><span class="o">::</span><span class="n">RegisterBuiltinPragmas</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">AddPragmaHandler</span><span class="p">(</span><span class="k">new</span> <span class="n">PragmaOnceHandler</span><span class="p">());</span>
    <span class="n">AddPragmaHandler</span><span class="p">(</span><span class="k">new</span> <span class="n">PragmaMarkHandler</span><span class="p">());</span>
    <span class="n">AddPragmaHandler</span><span class="p">(</span><span class="k">new</span> <span class="n">PragmaPushMacroHandler</span><span class="p">());</span>
    <span class="n">AddPragmaHandler</span><span class="p">(</span><span class="k">new</span> <span class="n">PragmaPopMacroHandler</span><span class="p">());</span>
    <span class="n">AddPragmaHandler</span><span class="p">(</span><span class="k">new</span> <span class="n">PragmaMessageHandler</span><span class="p">(</span><span class="n">PPCallbacks</span><span class="o">::</span><span class="n">PMK_Message</span><span class="p">));</span>

    <span class="c1">// #pragma GCC ...</span>
    <span class="n">AddPragmaHandler</span><span class="p">(</span><span class="s">&quot;GCC&quot;</span><span class="p">,</span> <span class="k">new</span> <span class="n">PragmaPoisonHandler</span><span class="p">());</span>
    <span class="n">AddPragmaHandler</span><span class="p">(</span><span class="s">&quot;GCC&quot;</span><span class="p">,</span> <span class="k">new</span> <span class="n">PragmaSystemHeaderHandler</span><span class="p">());</span>
    <span class="n">AddPragmaHandler</span><span class="p">(</span><span class="s">&quot;GCC&quot;</span><span class="p">,</span> <span class="k">new</span> <span class="n">PragmaDependencyHandler</span><span class="p">());</span>
    <span class="n">AddPragmaHandler</span><span class="p">(</span><span class="s">&quot;GCC&quot;</span><span class="p">,</span> <span class="k">new</span> <span class="n">PragmaDiagnosticHandler</span><span class="p">(</span><span class="s">&quot;GCC&quot;</span><span class="p">));</span>
    <span class="n">AddPragmaHandler</span><span class="p">(</span><span class="s">&quot;GCC&quot;</span><span class="p">,</span> <span class="k">new</span> <span class="n">PragmaMessageHandler</span><span class="p">(</span><span class="n">PPCallbacks</span><span class="o">::</span><span class="n">PMK_Warning</span><span class="p">,</span>
    <span class="s">&quot;GCC&quot;</span><span class="p">));</span>
    <span class="n">AddPragmaHandler</span><span class="p">(</span><span class="s">&quot;GCC&quot;</span><span class="p">,</span> <span class="k">new</span> <span class="n">PragmaMessageHandler</span><span class="p">(</span><span class="n">PPCallbacks</span><span class="o">::</span><span class="n">PMK_Error</span><span class="p">,</span>
    <span class="s">&quot;GCC&quot;</span><span class="p">));</span>
    <span class="c1">// #pragma clang ...</span>
    <span class="n">AddPragmaHandler</span><span class="p">(</span><span class="s">&quot;clang&quot;</span><span class="p">,</span> <span class="k">new</span> <span class="n">PragmaPoisonHandler</span><span class="p">());</span>
    <span class="n">AddPragmaHandler</span><span class="p">(</span><span class="s">&quot;clang&quot;</span><span class="p">,</span> <span class="k">new</span> <span class="n">PragmaSystemHeaderHandler</span><span class="p">());</span>
    <span class="n">AddPragmaHandler</span><span class="p">(</span><span class="s">&quot;clang&quot;</span><span class="p">,</span> <span class="k">new</span> <span class="n">PragmaDebugHandler</span><span class="p">());</span>
    <span class="n">AddPragmaHandler</span><span class="p">(</span><span class="s">&quot;clang&quot;</span><span class="p">,</span> <span class="k">new</span> <span class="n">PragmaDependencyHandler</span><span class="p">());</span>
    <span class="n">AddPragmaHandler</span><span class="p">(</span><span class="s">&quot;clang&quot;</span><span class="p">,</span> <span class="k">new</span> <span class="n">PragmaDiagnosticHandler</span><span class="p">(</span><span class="s">&quot;clang&quot;</span><span class="p">));</span>
    <span class="n">AddPragmaHandler</span><span class="p">(</span><span class="s">&quot;clang&quot;</span><span class="p">,</span> <span class="k">new</span> <span class="n">PragmaARCCFCodeAuditedHandler</span><span class="p">());</span>

    <span class="n">AddPragmaHandler</span><span class="p">(</span><span class="s">&quot;STDC&quot;</span><span class="p">,</span> <span class="k">new</span> <span class="n">PragmaSTDC_FENV_ACCESSHandler</span><span class="p">());</span>
    <span class="n">AddPragmaHandler</span><span class="p">(</span><span class="s">&quot;STDC&quot;</span><span class="p">,</span> <span class="k">new</span> <span class="n">PragmaSTDC_CX_LIMITED_RANGEHandler</span><span class="p">());</span>
    <span class="n">AddPragmaHandler</span><span class="p">(</span><span class="s">&quot;STDC&quot;</span><span class="p">,</span> <span class="k">new</span> <span class="n">PragmaSTDC_UnknownHandler</span><span class="p">());</span>

    <span class="c1">// MS extensions.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">LangOpts</span><span class="p">.</span><span class="n">MicrosoftExt</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">AddPragmaHandler</span><span class="p">(</span><span class="k">new</span> <span class="n">PragmaWarningHandler</span><span class="p">());</span>
        <span class="n">AddPragmaHandler</span><span class="p">(</span><span class="k">new</span> <span class="n">PragmaIncludeAliasHandler</span><span class="p">());</span>
        <span class="n">AddPragmaHandler</span><span class="p">(</span><span class="k">new</span> <span class="n">PragmaRegionHandler</span><span class="p">(</span><span class="s">&quot;region&quot;</span><span class="p">));</span>
        <span class="n">AddPragmaHandler</span><span class="p">(</span><span class="k">new</span> <span class="n">PragmaRegionHandler</span><span class="p">(</span><span class="s">&quot;endregion&quot;</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h2 id="b19e1a">条件编译</h2>
<p>条件编译的处理放在了PPConditionalDirectiveRecord.h文件内。这里定义了PPConditionalDirectiveRecord类型，继承自PPCallbacks，
定义了几个跟条件编译相关的虚函数。这里还定义了一个存储条件编译指令位置的类CondDirectiveLoc，以及相应的位置比较器Comp。在PPConditionalDirectiveRecord里定义了一个vertor来处理所有的条件编译位点，其实就是一个有序的栈。</p>
<div class="codehilite"><pre><span></span><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CondDirectiveLoc</span><span class="o">&gt;</span> <span class="n">CondDirectiveLocsTy</span><span class="p">;</span>
<span class="c1">/// \brief The locations of conditional directives in source order.</span>
<span class="n">CondDirectiveLocsTy</span> <span class="n">CondDirectiveLocs</span><span class="p">;</span>
</pre></div>


<p>这个有序栈的作用就是判断一个代码range处于哪一个条件之中，为此提供了两个接口：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief Returns true if the given range intersects with a conditional</span>
<span class="c1">/// directive. if a \#if/\#endif block is fully contained within the range,</span>
<span class="c1">/// this function will return false.</span>
<span class="kt">bool</span> <span class="nf">rangeIntersectsConditionalDirective</span><span class="p">(</span><span class="n">SourceRange</span> <span class="n">Range</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">/// \brief Returns true if the given locations are in different regions,</span>
<span class="c1">/// separated by conditional directive blocks.</span>
<span class="kt">bool</span> <span class="nf">areInDifferentConditionalDirectiveRegion</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">LHS</span><span class="p">,</span>
<span class="n">SourceLocation</span> <span class="n">RHS</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">findConditionalDirectiveRegionLoc</span><span class="p">(</span><span class="n">LHS</span><span class="p">)</span> <span class="o">!=</span>
    <span class="n">findConditionalDirectiveRegionLoc</span><span class="p">(</span><span class="n">RHS</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">SourceLocation</span> <span class="nf">findConditionalDirectiveRegionLoc</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>


<p>这三个接口里最基础的是find，就是一个lower<span class="math">\(\backslash\)</span>bound的查找和判断。</p>
<div class="codehilite"><pre><span></span><span class="n">SourceLocation</span> <span class="n">PPConditionalDirectiveRecord</span><span class="o">::</span><span class="n">findConditionalDirectiveRegionLoc</span><span class="p">(</span>
<span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Loc</span><span class="p">.</span><span class="n">isInvalid</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">SourceLocation</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">CondDirectiveLocs</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">SourceLocation</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">SourceMgr</span><span class="p">.</span><span class="n">isBeforeInTranslationUnit</span><span class="p">(</span><span class="n">CondDirectiveLocs</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">getLoc</span><span class="p">(),</span>
    <span class="n">Loc</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">CondDirectiveStack</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>

    <span class="n">CondDirectiveLocsTy</span><span class="o">::</span><span class="n">const_iterator</span>
    <span class="n">low</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">CondDirectiveLocs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">CondDirectiveLocs</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
    <span class="n">Loc</span><span class="p">,</span> <span class="n">CondDirectiveLoc</span><span class="o">::</span><span class="n">Comp</span><span class="p">(</span><span class="n">SourceMgr</span><span class="p">));</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">low</span> <span class="o">!=</span> <span class="n">CondDirectiveLocs</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">low</span><span class="o">-&gt;</span><span class="n">getRegionLoc</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<h2 id="24a0c0">预处理求值</h2>
<p>预处理求值发生在#if语句之中，这里的操作数只有无符号整数，相关运算只有常规的四则运算，且没有自定义函数。这部分的代码都在PPExpressions.cpp里定义。</p>
<p>此处首先定义了一个PPValue结构，用来代表一个表达式的值和这个表达式所占的SourceLocation区间，可以理解为树形求值表达式上的一个节点。</p>
<p>这里求值表达式中也可能出现这种形式:#defined(x)或者!#defined(x)。clang用一个DefinedTracker来记录某个子表达式是否是这两种形式。</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">DefinedTracker</span>
<span class="p">{</span>
    <span class="c1">/// Each time a Value is evaluated, it returns information about whether the</span>
    <span class="c1">/// parsed value is of the form defined(X), !defined(X) or is something else.</span>
    <span class="k">enum</span> <span class="n">TrackerState</span>
    <span class="p">{</span>
        <span class="n">DefinedMacro</span><span class="p">,</span>        <span class="c1">// defined(X)</span>
        <span class="n">NotDefinedMacro</span><span class="p">,</span>     <span class="c1">// !defined(X)</span>
        <span class="n">Unknown</span>              <span class="c1">// Something else.</span>
    <span class="p">}</span> <span class="n">State</span><span class="p">;</span>
    <span class="c1">/// TheMacro - When the state is DefinedMacro or NotDefinedMacro, this</span>
    <span class="c1">/// indicates the macro that was checked.</span>
    <span class="n">IdentifierInfo</span> <span class="o">*</span><span class="n">TheMacro</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>对应的有一个专门的函数来处理这种形式的值：EvaluateDefined。基本就是一些合法性检测，如果是宏则标记这个宏为使用过的。</p>
<p>对于主要的表达式来说，还是算数求值比较多，这个define求值很少见。算数求值首先需要明确每一个单项的值，这个求单独项的值的过程在EvaluateValue中定义。可能会调用到EvaluateDefined，因为defined也算一个项。剩下的就三种种情况：bool值和整值，char值，bool也算一个预定义宏。但是不知道为什么这个EvaluateValue函数还处理了括号，加减法，取反运算符和取非运算符。为了处理左括号这种情况还调用到了EvaluateDirectiveSubExpr这个函数，这个函数是用来计算树节点表达式的，里面又会调用EvaluateValue这个函数。</p>
<p>EvaluateDirectiveSubExpr函数处理时已经获得了左操作数的值和左操作数之前的那个操作符的优先级。他首先peek下一个操作符，</p>
<ol>
<li>如果该操作符的优先级比之前记录的左操作符优先级低则直接返回。</li>
<li>如果该操作符是具有短路性质的逻辑操作符，检查左边的值是不是已经可以确定当前子表达式的值，并把右边的表达式标记为IsDead。</li>
<li>如果该操作符是比之前的优先级高，则再EvaluateValue 一下RHS，同时获得RHS右边的操作符优先级，来决定是否可以结束当前子表达式节点，如果还需要处理则继续递归调用EvaluateDirectiveSubExpr。这里还需要特殊处理条件表达式,当遇到？号的时候，直接赋予他逗号的优先级。如果不是问号，则直接将这个表达式的优先级+1，这样来处理右结合的运算符。</li>
</ol>
<p>上述两个函数的入口函数在EvaluateDirectiveExpression里，会首先peek这个token，然后调用EvaluateValue函数求完整表达式的值。</p>
<h2 id="5d23a0">预处理记录</h2>
<p>在预处理阶段发生的任何事情都会被记录为一个PreprocessedEntity。通过这些Entity来记录所有的预处理细节。预处理事件分为了如下几类：</p>
<div class="codehilite"><pre><span></span><span class="k">enum</span> <span class="n">EntityKind</span>
<span class="p">{</span>
    <span class="c1">/// \brief Indicates a problem trying to load the preprocessed entity.</span>
    <span class="n">InvalidKind</span><span class="p">,</span>

    <span class="c1">/// \brief A macro expansion.</span>
    <span class="n">MacroExpansionKind</span><span class="p">,</span>

    <span class="c1">/// \defgroup Preprocessing directives</span>
    <span class="c1">/// @{</span>

        <span class="c1">/// \brief A macro definition.</span>
        <span class="n">MacroDefinitionKind</span><span class="p">,</span>

        <span class="c1">/// \brief An inclusion directive, such as \c \#include, \c</span>
        <span class="c1">/// \#import, or \c \#include_next.</span>
        <span class="n">InclusionDirectiveKind</span><span class="p">,</span>

        <span class="c1">/// @}</span>

    <span class="n">FirstPreprocessingDirective</span> <span class="o">=</span> <span class="n">MacroDefinitionKind</span><span class="p">,</span>
    <span class="n">LastPreprocessingDirective</span> <span class="o">=</span> <span class="n">InclusionDirectiveKind</span>
<span class="p">};</span>
</pre></div>


<p>所有的Entity都继承自一个基类PreprocessEntity，记录了这个record的类型和发生的位置。</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">PreprocessedEntity</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
    <span class="c1">/// \brief The kind of preprocessed entity an object describes.</span>
    <span class="k">private</span><span class="o">:</span>
    <span class="c1">/// \brief The kind of preprocessed entity that this object describes.</span>
    <span class="n">EntityKind</span> <span class="n">Kind</span><span class="p">;</span>

    <span class="c1">/// \brief The source range that covers this preprocessed entity.</span>
    <span class="n">SourceRange</span> <span class="n">Range</span><span class="p">;</span>

    <span class="k">protected</span><span class="o">:</span>
    <span class="n">PreprocessedEntity</span><span class="p">(</span><span class="n">EntityKind</span> <span class="n">Kind</span><span class="p">,</span> <span class="n">SourceRange</span> <span class="n">Range</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">Kind</span><span class="p">(</span><span class="n">Kind</span><span class="p">),</span> <span class="n">Range</span><span class="p">(</span><span class="n">Range</span><span class="p">)</span>
    <span class="p">{}</span>

    <span class="k">friend</span> <span class="k">class</span> <span class="nc">PreprocessingRecord</span><span class="p">;</span>

    <span class="k">public</span><span class="o">:</span>
    <span class="c1">/// \brief Retrieve the kind of preprocessed entity stored in this object.</span>
    <span class="n">EntityKind</span> <span class="n">getKind</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Kind</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">/// \brief Retrieve the source range that covers this entire preprocessed </span>
    <span class="c1">/// entity.</span>
    <span class="n">SourceRange</span> <span class="n">getSourceRange</span><span class="p">()</span> <span class="k">const</span> <span class="n">LLVM_READONLY</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Range</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">/// \brief Returns true if there was a problem loading the preprocessed</span>
    <span class="c1">/// entity.</span>
    <span class="kt">bool</span> <span class="n">isInvalid</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Kind</span> <span class="o">==</span> <span class="n">InvalidKind</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>这个基类还重定义了new和delete，使得内存分配都是8字节对齐的。</p>
<p>在此基类下，还定义了四个子类，这些子类的类型都在enum里定义好了。比较特殊的就是MacroExpansion，里面区分了标准内置宏和源文件自定义宏：</p>
<div class="codehilite"><pre><span></span><span class="n">llvm</span><span class="o">::</span><span class="n">PointerUnion</span><span class="o">&lt;</span><span class="n">IdentifierInfo</span> <span class="o">*</span><span class="p">,</span> <span class="n">MacroDefinition</span> <span class="o">*&gt;</span> <span class="n">NameOrDef</span><span class="p">;</span>
</pre></div>


<p>所有的预处理Entity都被一个PreprocessingRecord所管理，里面负责分配内存和Entity的ID。ID区分正负，正的ID代表当前预处理器所引入的Enitty，而负的ID代表外部源引入的Enitty。这里使用了两个Vector来记录遇到的Entity和实际处理的Entity：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief The set of preprocessed entities in this record, in order they</span>
<span class="c1">/// were seen.</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PreprocessedEntity</span> <span class="o">*&gt;</span> <span class="n">PreprocessedEntities</span><span class="p">;</span>

<span class="c1">/// \brief The set of preprocessed entities in this record that have been</span>
<span class="c1">/// loaded from external sources.</span>
<span class="c1">///</span>
<span class="c1">/// The entries in this vector are loaded lazily from the external source,</span>
<span class="c1">/// and are referenced by the iterator using negative indices.</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PreprocessedEntity</span> <span class="o">*&gt;</span> <span class="n">LoadedPreprocessedEntities</span><span class="p">;</span>

<span class="c1">/// \brief The set of ranges that were skipped by the preprocessor,</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SourceRange</span><span class="o">&gt;</span> <span class="n">SkippedRanges</span><span class="p">;</span>
</pre></div>


<p>同时还用map记录了每一个MacroInfo对应的MacroDefinition，也就是宏定义。</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief Mapping from MacroInfo structures to their definitions.</span>
<span class="n">llvm</span><span class="o">::</span><span class="n">DenseMap</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">MacroInfo</span> <span class="o">*</span><span class="p">,</span> <span class="n">MacroDefinition</span> <span class="o">*&gt;</span> <span class="n">MacroDefinitions</span><span class="p">;</span>
</pre></div>


<p>这里提供了所有Entity的构造和注册方法：</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="nf">MacroExpands</span><span class="p">(</span><span class="k">const</span> <span class="n">Token</span> <span class="o">&amp;</span><span class="n">Id</span><span class="p">,</span> <span class="k">const</span> <span class="n">MacroDirective</span> <span class="o">*</span><span class="n">MD</span><span class="p">,</span>
<span class="n">SourceRange</span> <span class="n">Range</span><span class="p">,</span> <span class="k">const</span> <span class="n">MacroArgs</span> <span class="o">*</span><span class="n">Args</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">MacroDefined</span><span class="p">(</span><span class="k">const</span> <span class="n">Token</span> <span class="o">&amp;</span><span class="n">Id</span><span class="p">,</span> <span class="k">const</span> <span class="n">MacroDirective</span> <span class="o">*</span><span class="n">MD</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">MacroUndefined</span><span class="p">(</span><span class="k">const</span> <span class="n">Token</span> <span class="o">&amp;</span><span class="n">Id</span><span class="p">,</span> <span class="k">const</span> <span class="n">MacroDirective</span> <span class="o">*</span><span class="n">MD</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">InclusionDirective</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">HashLoc</span><span class="p">,</span> <span class="k">const</span> <span class="n">Token</span> <span class="o">&amp;</span><span class="n">IncludeTok</span><span class="p">,</span>
<span class="n">StringRef</span> <span class="n">FileName</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">IsAngled</span><span class="p">,</span>
<span class="n">CharSourceRange</span> <span class="n">FilenameRange</span><span class="p">,</span>
<span class="k">const</span> <span class="n">FileEntry</span> <span class="o">*</span><span class="n">File</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">SearchPath</span><span class="p">,</span>
<span class="n">StringRef</span> <span class="n">RelativePath</span><span class="p">,</span>
<span class="k">const</span> <span class="n">Module</span> <span class="o">*</span><span class="n">Imported</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">Ifdef</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">,</span> <span class="k">const</span> <span class="n">Token</span> <span class="o">&amp;</span><span class="n">MacroNameTok</span><span class="p">,</span>
<span class="k">const</span> <span class="n">MacroDirective</span> <span class="o">*</span><span class="n">MD</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">Ifndef</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">,</span> <span class="k">const</span> <span class="n">Token</span> <span class="o">&amp;</span><span class="n">MacroNameTok</span><span class="p">,</span>
<span class="k">const</span> <span class="n">MacroDirective</span> <span class="o">*</span><span class="n">MD</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
<span class="c1">/// \brief Hook called whenever the &#39;defined&#39; operator is seen.</span>
<span class="kt">void</span> <span class="nf">Defined</span><span class="p">(</span><span class="k">const</span> <span class="n">Token</span> <span class="o">&amp;</span><span class="n">MacroNameTok</span><span class="p">,</span> <span class="k">const</span> <span class="n">MacroDirective</span> <span class="o">*</span><span class="n">MD</span><span class="p">,</span>
<span class="n">SourceRange</span> <span class="n">Range</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">SourceRangeSkipped</span><span class="p">(</span><span class="n">SourceRange</span> <span class="n">Range</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">addMacroExpansion</span><span class="p">(</span><span class="k">const</span> <span class="n">Token</span> <span class="o">&amp;</span><span class="n">Id</span><span class="p">,</span> <span class="k">const</span> <span class="n">MacroInfo</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span>
<span class="n">SourceRange</span> <span class="n">Range</span><span class="p">);</span>
</pre></div>


<p>这些函数最终都会调用到被重载的new函数，然后通过addPreprocessedEntity对entity进行注册，其实就是在vector里pushback。</p>
<h2 id="5e6b8d">PreprocessorLexer.h</h2>
<p>目前还不怎么了解这个类是干什么的？感觉只是用来处理头文件引入和条件编译选项的。其数据成员如下：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">PreprocessorLexer</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">anchor</span><span class="p">();</span>
    <span class="k">protected</span><span class="o">:</span>
    <span class="n">Preprocessor</span> <span class="o">*</span><span class="n">PP</span><span class="p">;</span>              <span class="c1">// Preprocessor object controlling lexing.</span>

    <span class="c1">/// The SourceManager FileID corresponding to the file being lexed.</span>
    <span class="k">const</span> <span class="n">FileID</span> <span class="n">FID</span><span class="p">;</span>

    <span class="c1">/// \brief Number of SLocEntries before lexing the file.</span>
    <span class="kt">unsigned</span> <span class="n">InitialNumSLocEntries</span><span class="p">;</span>

    <span class="c1">//===--------------------------------------------------------------------===//</span>
    <span class="c1">// Context-specific lexing flags set by the preprocessor.</span>
    <span class="c1">//===--------------------------------------------------------------------===//</span>

    <span class="c1">/// \brief True when parsing \#XXX; turns &#39;\\n&#39; into a tok::eod token.</span>
    <span class="kt">bool</span> <span class="n">ParsingPreprocessorDirective</span><span class="p">;</span>

    <span class="c1">/// \brief True after \#include; turns \&lt;xx&gt; into a tok::angle_string_literal</span>
    <span class="c1">/// token.</span>
    <span class="kt">bool</span> <span class="n">ParsingFilename</span><span class="p">;</span>

    <span class="c1">/// \brief True if in raw mode.</span>
    <span class="c1">///</span>
    <span class="c1">/// Raw mode disables interpretation of tokens and is a far faster mode to</span>
    <span class="c1">/// lex in than non-raw-mode.  This flag:</span>
    <span class="c1">///  1. If EOF of the current lexer is found, the include stack isn&#39;t popped.</span>
    <span class="c1">///  2. Identifier information is not looked up for identifier tokens.  As an</span>
    <span class="c1">///     effect of this, implicit macro expansion is naturally disabled.</span>
    <span class="c1">///  3. &quot;#&quot; tokens at the start of a line are treated as normal tokens, not</span>
    <span class="c1">///     implicitly transformed by the lexer.</span>
    <span class="c1">///  4. All diagnostic messages are disabled.</span>
    <span class="c1">///  5. No callbacks are made into the preprocessor.</span>
    <span class="c1">///</span>
    <span class="c1">/// Note that in raw mode that the PP pointer may be null.</span>
    <span class="kt">bool</span> <span class="n">LexingRawMode</span><span class="p">;</span>

    <span class="c1">/// \brief A state machine that detects the \#ifndef-wrapping a file</span>
    <span class="c1">/// idiom for the multiple-include optimization.</span>
    <span class="n">MultipleIncludeOpt</span> <span class="n">MIOpt</span><span class="p">;</span>

    <span class="c1">/// \brief Information about the set of \#if/\#ifdef/\#ifndef blocks</span>
    <span class="c1">/// we are currently in.</span>
    <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">PPConditionalInfo</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">ConditionalStack</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>前两个<em>bool</em>组成一个状态机，配合<em>MIOpt</em>专门用来<em>parse</em>头文件引入。而<em>ConditionalStack</em>专门用来处理条件编译。这里的条件编译需要利用<em>Token.h</em>中定义的<em>PPConditionalInfo</em>，这是一个<em>POD</em>：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief Information about the conditional stack (\#if directives)</span>
<span class="c1">/// currently active.</span>
<span class="k">struct</span> <span class="n">PPConditionalInfo</span>
<span class="p">{</span>
    <span class="c1">/// \brief Location where the conditional started.</span>
    <span class="n">SourceLocation</span> <span class="n">IfLoc</span><span class="p">;</span>

    <span class="c1">/// \brief True if this was contained in a skipping directive, e.g.,</span>
    <span class="c1">/// in a &quot;\#if 0&quot; block.</span>
    <span class="kt">bool</span> <span class="n">WasSkipping</span><span class="p">;</span>

    <span class="c1">/// \brief True if we have emitted tokens already, and now we&#39;re in</span>
    <span class="c1">/// an \#else block or something.  Only useful in Skipping blocks.</span>
    <span class="kt">bool</span> <span class="n">FoundNonSkip</span><span class="p">;</span>

    <span class="c1">/// \brief True if we&#39;ve seen a \#else in this block.  If so,</span>
    <span class="c1">/// \#elif/\#else directives are not allowed.</span>
    <span class="kt">bool</span> <span class="n">FoundElse</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>这个结构就是专门记录<em>#if #else</em>之类的条件编译的。所以在处理条件编译时，我们通过这样的来压栈：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// pushConditionalLevel - When we enter a \#if directive, this keeps track of</span>
<span class="c1">/// what we are currently in for diagnostic emission (e.g. \#if with missing</span>
<span class="c1">/// \#endif).</span>
<span class="kt">void</span> <span class="nf">pushConditionalLevel</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">DirectiveStart</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">WasSkipping</span><span class="p">,</span>
<span class="kt">bool</span> <span class="n">FoundNonSkip</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">FoundElse</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PPConditionalInfo</span> <span class="n">CI</span><span class="p">;</span>
    <span class="n">CI</span><span class="p">.</span><span class="n">IfLoc</span> <span class="o">=</span> <span class="n">DirectiveStart</span><span class="p">;</span>
    <span class="n">CI</span><span class="p">.</span><span class="n">WasSkipping</span> <span class="o">=</span> <span class="n">WasSkipping</span><span class="p">;</span>
    <span class="n">CI</span><span class="p">.</span><span class="n">FoundNonSkip</span> <span class="o">=</span> <span class="n">FoundNonSkip</span><span class="p">;</span>
    <span class="n">CI</span><span class="p">.</span><span class="n">FoundElse</span> <span class="o">=</span> <span class="n">FoundElse</span><span class="p">;</span>
    <span class="n">ConditionalStack</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">CI</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>对应的出栈操作如下：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// popConditionalLevel - Remove an entry off the top of the conditional</span>
<span class="c1">/// stack, returning information about it.  If the conditional stack is empty,</span>
<span class="c1">/// this returns true and does not fill in the arguments.</span>
<span class="kt">bool</span> <span class="nf">popConditionalLevel</span><span class="p">(</span><span class="n">PPConditionalInfo</span> <span class="o">&amp;</span><span class="n">CI</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ConditionalStack</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">CI</span> <span class="o">=</span> <span class="n">ConditionalStack</span><span class="p">.</span><span class="n">pop_back_val</span><span class="p">();</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>除了这几个宏相关的操作之外，<em>PreprocessorLexer</em>里面还定义了一些虚接口函数：</p>
<div class="codehilite"><pre><span></span><span class="k">virtual</span> <span class="kt">void</span> <span class="nf">IndirectLex</span><span class="p">(</span><span class="n">Token</span><span class="o">&amp;</span> <span class="n">Result</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">/// \brief Return the source location for the next observable location.</span>
<span class="k">virtual</span> <span class="n">SourceLocation</span> <span class="nf">getSourceLocation</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>


<p>这几个虚接口函数都需要在继承类中实现，特别是这里的<em>IndirectLex</em>，在具体实现的时候都会作为转接函数来调用对应类型的<em>Lex</em>函数，后面我们会涉及到。</p>
<h2 id="fa712b">导言处理</h2>
<p>有了这么多准备工作之后，所有的Directives的处理代码都在PPDirectives.cpp里定义。</p>
<p>当遇到一个#define或者#undefine时，需要调用CheckMacroName这个函数来检查被操作的宏名是否合法，例如undef就不能操作标准自带的一些宏。这个CheckMacroName是配合ReadMacroName一起使用的，如果CheckMacroName认为这个宏不合法，则会吃掉所有后面的Token直到本行导言结束。</p>
<p>当遇到一个#if导言时，调用SkipExcludedConditionalBlock函数来忽略掉所有被关闭的代码块，直到我们遇到了一个对应的#endif。需要注意的是这里内部可能也定义了条件代码块，所以要处理递归。这里有另外的一个函数PTHSkipExcludedConditionalBlock来处理PTH文件里的条件开关。</p>
<p>LookupFile用来处理头文件的查找，这里就涉及到了之前的头文件管理，按照标准规定好的方式去查找该文件名对应的物理文件。</p>
<p>上述的这些函数最终都会被HandleDirective函数调用到，所有以#开头的行都会调用到HandleDirective函数。这个函数调用的时候会做一些检查，然后根据下一个token的值调用到对应的Handlexxx函数：</p>
<ol>
<li>
<p>HandleLineDirective 这个会处理#line number形式的导言，获得了相应值之后调用SourceMgr.AddLineNote
   来进行相应的改变。</p>
</li>
<li>
<p>HandleUserDiagnosticDirective 这个会处理#warn 或者#error形式的导言，其实就是用户自定义的编译时错误输出。</p>
</li>
<li>
<p>HandleIncludeDirective 这个函数是用来处理头文件插入的，也是首先获得头文件名称并获得其FileID，之后向头文件管理器检查是否需要处理该文件（pragma once或者header guard）.一切检查通过的时候，最终会调用到EnterSourceFile函数去处理新加入的头文件。</p>
</li>
<li>
<p>ReadMacroDefinitionArgList 这个用来获得宏的参数列表，并作一些检查。</p>
</li>
<li>
<p>HandleDefineDirective 这个函数用来处理#define形式，首先左一些基本检查，然后如果是函数型宏的话还需要调用ReadMacroDefinitionArgList来获得参数列表。最后再处理宏体：</p>
</li>
<li>
<p>如果是对象型宏，则直接获得后面的所有token，通过AddTokenToBody记录下来</p>
</li>
<li>如果是函数型的宏，也是差不多，但是要求所有的#和##的右参数必须是宏参数。同时##不能出现在开头和结尾。</li>
</ol>
<p>最终当一个宏体处理完成之后，需要检查之前是否已经定义了这个宏。如果定义了则需要检查宏定义是否一致。不一致的话给出警告或者错误。最后通过appendDefMacroDirective来等级这个操作。</p>
<ol>
<li>
<p>HandleUndefDirective 这里做一些基本检查，然后通过appendMacroDirective来记录这个操作</p>
</li>
<li>
<p>HandleIfdefDirective 这里需要考虑的主要是header guard这个东西。如果这个条件通过的话，将这个值当作一个新的条件编译等级，调用pushConditionalLevel来记录。否则直接跳过当前block到#else相关导言区</p>
</li>
<li>
<p>HandleIfDirective 处理#if 指令，这里会调用到EvaluateDirectiveExpression来获得表达式的值。之后的操作等价于上一个HandleIfdefDirective函数</p>
</li>
<li>
<p>HandleEndifDirective 这个处理#endif导言，其实就是调用一下popConditionalLevel来弹栈。</p>
</li>
<li>
<p>HandleElseDirective 跟#endif很像，也是直接popConditionalLevel来弹栈。</p>
</li>
<li>
<p>HandleElifDirective 同上</p>
</li>
</ol>
<p>这些函数都会调用到预处理回调的callback，所以具体的处理函数还依赖每个继承自Callback的具体实现。</p>
<p>正如上面所分析的，头文件处理会调用到Preprocessor::EnterSourceFile这个函数来处理新文件。这个函数定义在PPLexerChange.cpp里面。这个函数会首先做一些检查，最后会执行到这一句：</p>
<div class="codehilite"><pre><span></span><span class="n">EnterSourceFileWithLexer</span><span class="p">(</span><span class="k">new</span> <span class="n">Lexer</span><span class="p">(</span><span class="n">FID</span><span class="p">,</span> <span class="n">InputFile</span><span class="p">,</span> <span class="o">*</span><span class="k">this</span><span class="p">),</span> <span class="n">CurDir</span><span class="p">);</span>
</pre></div>


<p>也就是说会使用一个新的Lexer来处理新文件，但是会拥有同样的预处理器*this。这个函数的主要作用就是重设这个新的lexer为新lexer，同时将之前的lexer保存下来用来恢复，然后通知相关注册了的callback。</p>
<p>对于宏展开，则会使用到Preprocessor::EnterMacro函数来处理宏展开。跟处理include差不多，就是切换当前TokenLexer：</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">Preprocessor</span><span class="o">::</span><span class="n">EnterMacro</span><span class="p">(</span><span class="n">Token</span> <span class="o">&amp;</span><span class="n">Tok</span><span class="p">,</span> <span class="n">SourceLocation</span> <span class="n">ILEnd</span><span class="p">,</span>
<span class="n">MacroInfo</span> <span class="o">*</span><span class="n">Macro</span><span class="p">,</span> <span class="n">MacroArgs</span> <span class="o">*</span><span class="n">Args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TokenLexer</span><span class="o">&gt;</span> <span class="n">TokLexer</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">NumCachedTokenLexers</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">TokLexer</span> <span class="o">=</span> <span class="n">llvm</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">TokenLexer</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Tok</span><span class="p">,</span> <span class="n">ILEnd</span><span class="p">,</span> <span class="n">Macro</span><span class="p">,</span> <span class="n">Args</span><span class="p">,</span> <span class="o">*</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">TokLexer</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">TokenLexerCache</span><span class="p">[</span><span class="o">--</span><span class="n">NumCachedTokenLexers</span><span class="p">]);</span>
        <span class="n">TokLexer</span><span class="o">-&gt;</span><span class="n">Init</span><span class="p">(</span><span class="n">Tok</span><span class="p">,</span> <span class="n">ILEnd</span><span class="p">,</span> <span class="n">Macro</span><span class="p">,</span> <span class="n">Args</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">PushIncludeMacroStack</span><span class="p">();</span>
    <span class="n">CurDirLookup</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">CurTokenLexer</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">TokLexer</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">CurLexerKind</span> <span class="o">!=</span> <span class="n">CLK_LexAfterModuleImport</span><span class="p">)</span>
    <span class="n">CurLexerKind</span> <span class="o">=</span> <span class="n">CLK_TokenLexer</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>跟EnterMacro函数相似的还有另外一个函数EnterTokenStream，就是将一个TokenSteam当作一个临时的头文件放在栈顶，然后进行lex。</p>
<p>EOF代表文件的结束，一般来说当Lexer处理EOF时，要么会抛出一个EOFtoken，要么会把当前的头文件引入栈的栈顶弹出。具体处理函数在PPLexerChange.cpp的HandleEndOffFile.</p>
<ol>
<li>首先需要关系的是当前文件是否被header guard包围了，如果预设的header
   guard不匹配的话需要给出警告。</li>
<li>如果头文件栈不是空的话，则使用RemoveTopOfLexerStack进行弹栈</li>
<li>如果头文件栈是空的，则说明这是一个编译单元的末尾，返回EOF</li>
</ol>
<p>对于宏展开，也是类似。宏可以当作一个特殊的头文件域来处理，最后还是会调用到HandleEndOfFile。</p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
    </div>
    <div id="content-comments">
</div>

</div>
<div class="niu2-right-container col-md-2">
    <div id="niu2-sidebar-meta" class="niu2-sidebar">
        <div class="niu2-sidebar-label"><i class="icon-calendar"></i>Published:</div>
        <div class="niu2-sidebar-value">2015-11-17 19:27</div>
        <div class="niu2-sidebar-label"><i class="icon-open-folder"></i>Category:</div>
        <div class="niu2-sidebar-value"><a href="./category/compiler.html">Compiler</a></div>
        <div class="niu2-sidebar-label"><i class="icon-tag"></i>Tag:</div>
 
            <div class="niu2-sidebar-inter-value niu2-sidebar-tag"><a href="./tag/compiler.html">Compiler</a><sup>2</sup></div>
            <div class="niu2-sidebar-inter-value niu2-sidebar-tag"><a href="./tag/clang.html">Clang</a><sup>2</sup></div>
            <div class="niu2-sidebar-inter-value niu2-sidebar-tag"><a href="./tag/cpp.html">CPP</a><sup>11</sup></div>
    </div>

    <div id="niu2-sidebar-toc" class="niu2-sidebar" data-status="closed">
        <div class="niu2-sidebar-label">
            <i id="niu2-sidebar-toc-ctrl" class="icon-open-tocs"></i>TOC
        </div>
        <ol id="niu2-sidebar-toc-list">
            <li><a href="#content-heading">Clang Lex</a></li>
            <li><a href='#c99c80'>Lexer</a></li><li><a href='#6382f8'>phase 1-2 字符处理与行拼接</a></li><li><a href='#128a22'>phase 3 基础词法</a><ol><li><a href='#0b361c'>Literal Support</a><ol><li><a href='#813397'>数值常量</a></li><li><a href='#d02921'>字符常量和字符串常量</a></li></ol></li><li><a href='#414fa3'>lex 辅助函数</a></li><li><a href='#4222f4'>lex入口函数</a></li><li><a href='#459a6f'>Token</a></li></ol></li><li><a href='#fbe6a1'>预处理辅助结构</a></li><li><a href='#4985e4'>头文件管理</a><ol><li><a href='#028d64'>Multiple Include Optimization</a></li><li><a href='#c5d09e'>HeaderMap</a></li><li><a href='#82fdcc'>头文件定位</a></li></ol></li><li><a href='#d72670'>预编译头文件</a><ol><li><a href='#a7d57d'>PTH 文件格式</a></li><li><a href='#fd1ea3'>PTHLexer</a></li><li><a href='#d5c82d'>PTHManager</a><ol><li><a href='#91ad3f'>对象构造</a></li><li><a href='#fbe7e3'>名字映射</a></li><li><a href='#0bcaa4'>CreateLexer</a></li></ol></li></ol></li><li><a href='#806e13'>符号管理</a><ol><li><a href='#09e252'>符号定义</a></li><li><a href='#ceb0aa'>符号表</a></li></ol></li><li><a href='#af6598'>宏管理</a><ol><li><a href='#887c57'>MacroArgs</a></li><li><a href='#426eb0'>MacroInfo</a></li><li><a href='#a15340'>MacroDirective</a></li><li><a href='#84847d'>MuduleMacro</a></li><li><a href='#b7345d'>MacroDefinition</a></li></ol></li><li><a href='#713060'>宏处理与TokenLexer</a><ol><li><a href='#73e4e5'>Function Expansion</a><ol><li><a href='#b4cf87'>普通替换</a></li><li><a href='#2f6006'>##拼接</a></li><li><a href='#2c3d57'>宏cache</a></li></ol></li><li><a href='#976472'>Lex</a></li></ol></li><li><a href='#b9e535'>预处理器</a><ol><li><a href='#6ee895'>预处理回调</a></li><li><a href='#f607fd'>Pragma</a></li><li><a href='#b19e1a'>条件编译</a></li><li><a href='#24a0c0'>预处理求值</a></li><li><a href='#5d23a0'>预处理记录</a></li><li><a href='#5e6b8d'>PreprocessorLexer.h</a></li><li><a href='#fa712b'>导言处理</a></li></ol></li>
        </ol>
    </div>
</div>    </div>

    <div class="niu2-footer">
        <div id="body-footer" class="col-md-6 col-md-offset-2">
<hr/>
<p>
    Powered by <a href="https://github.com/getpelican/pelican">Pelican</a>, 
    <a href="https://github.com/mawenbao/niu-x2-sidebar">theme</a> built with <a href="http://getbootstrap.com">Bootstrap3</a>
    by <a href="http://blog.atime.me">Ma Wenbao</a>, icons by 
    <a href="http://fortawesome.github.io/Font-Awesome">Font Awesome</a>.
</p>
<p>
    ©
            2014-2016
    <a class="niu2-footer-link" href=".">Huiliang Huang</a>
</p>
<p class="niu2-icons">
</p>        </div>
    </div>
    
    <div id="niu2-pygments" data-theme="github"></div>

    <script type="text/javascript" src="./theme/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="./theme/js/niu2.min.js"></script>
    <script type="text/javascript" src="./theme/js/bootstrap.min.js"></script>
    <script type="text/javascript">onContentLoaded();</script>
  </body>
</html>
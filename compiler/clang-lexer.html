<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clang Lexer - Spirits Away</title>
    <link rel="shortcut icon" type="image/x-icon" href="\favicon.ico">
    <link rel="stylesheet" href="http://spiritsaway.info/theme/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="http://spiritsaway.info/theme/font-icons/style.min.css" type="text/css" />
    <link rel="stylesheet" href="http://spiritsaway.info/theme/css/niu2.min.css" type="text/css" />

    <link rel="canonical" href="http://spiritsaway.info/compiler/clang-lexer.html" />
    
    <script type="text/javascript">window.onload=function(){};</script>
    <!--[if lt IE 9]>
        <script src="http://spiritsaway.info/theme/js/html5shiv.js"></script>
        <script src="http://spiritsaway.info/theme/js/respond.min.js"></script>
    <![endif]-->
  </head>
  <body> 
    <div id="body-header">
<div class="navbar navbar-inverse navbar-fixed-top">
<div class="col-md-12">
    <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="http://spiritsaway.info">
            <i class="icon-home"></i>Spirits Away
        </a>
    </div>
    <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
        <ul class="nav navbar-nav">
            <li><a href="/about.html" title="about">
                <i class="fa-anchor"></i>关于</a>
            </li>
            <li><a href="/archives.html" title="archives">
                <i class="fa-archive"></i>存档</a>
            </li>
            <li><a href="/tag/" title="tags">
                <i class="fa-tag"></i>标签</a>
            </li>
        <!-- category dropdown list -->
        <li class="dropdown">
           <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                <i class="icon-folder-open"></i>分类<b class="caret"></b>
           </a>
           <ul class="dropdown-menu">
               <li><a href="http://spiritsaway.info/ai/index.html">
                   <i class="icon-folder-close"></i>AI
                      (3)</a></li>
               <li><a href="http://spiritsaway.info/algorithm/index.html">
                   <i class="icon-folder-close"></i>Algorithm
                      (3)</a></li>
               <li><a href="http://spiritsaway.info/code/index.html">
                   <i class="icon-folder-close"></i>Code
                      (3)</a></li>
               <li><a href="http://spiritsaway.info/compiler/index.html">
                   <i class="icon-folder-close"></i>Compiler
                      (2)</a></li>
               <li><a href="http://spiritsaway.info/cpp/index.html">
                   <i class="icon-folder-close"></i>CPP
                      (7)</a></li>
               <li><a href="http://spiritsaway.info/math/index.html">
                   <i class="icon-folder-close"></i>Math
                      (4)</a></li>
           </ul>
        </li>
        <!--  self defined dropdown list -->
        </ul>
        
        <!-- right nav bar -->
        <ul class="nav navbar-nav navbar-right">
        <!-- google custom search -->
       </ul>
    </nav>
</div>
</div>    </div>
    
    <div id="body-content">
<div class="col-md-8 col-md-offset-2">
    <h1 id="content-heading">Clang Lexer</h1>
</div>
<div id="niu2-left-container" class="col-md-6 col-md-offset-2 with-right-border">
    <div id="niu2-main-content">
        <h1 id="459a6f">Token</h1>
<p><code>Token</code>也称为词法单元，是将源代码经过<code>lex</code>操作之后所分隔出来的基本信息单位。在<code>clang</code>中，<code>Token</code>的数据成员如下：</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Token</span>
<span class="p">{</span>
    <span class="c1">/// The location of the token. This is actually a SourceLocation.</span>
    <span class="kt">unsigned</span> <span class="n">Loc</span><span class="p">;</span>

    <span class="c1">/// UintData - This holds either the length of the token text, when</span>
    <span class="c1">/// a normal token, or the end of the SourceRange when an annotation</span>
    <span class="c1">/// token.</span>
    <span class="c1">// 话说没必要啊，长度加偏移不就是end了么</span>
    <span class="kt">unsigned</span> <span class="n">UintData</span><span class="p">;</span>

    <span class="c1">/// PtrData - This is a union of four different pointer types, which depends</span>
    <span class="c1">/// on what type of token this is:</span>
    <span class="c1">///  Identifiers, keywords, etc:</span>
    <span class="c1">///    This is an IdentifierInfo*, which contains the uniqued identifier</span>
    <span class="c1">///    spelling.</span>
    <span class="c1">///  Literals:  isLiteral() returns true.</span>
    <span class="c1">///    This is a pointer to the start of the token in a text buffer, which</span>
    <span class="c1">///    may be dirty (have trigraphs / escaped newlines).</span>
    <span class="c1">///  Annotations (resolved type names, C++ scopes, etc): isAnnotation().</span>
    <span class="c1">///    This is a pointer to sema-specific data for the annotation token.</span>
    <span class="c1">///  Eof:</span>
    <span class="c1">//     This is a pointer to a Decl.</span>
    <span class="c1">///  Other:</span>
    <span class="c1">///    This is null.</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">PtrData</span><span class="p">;</span>

    <span class="c1">/// Kind - The actual flavor of token this is.</span>
    <span class="n">tok</span><span class="o">::</span><span class="n">TokenKind</span> <span class="n">Kind</span><span class="p">;</span>

    <span class="c1">/// Flags - Bits we track about this token, members of the TokenFlags enum.</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">Flags</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>需要注意的是这里的<code>Kind</code>相关信息，主要包括如下几类：</p>
<ul>
<li>
<p><code>Identifier</code>或者<code>Keywords</code>；</p>
</li>
<li>
<p><code>Literal</code>，这个是常量值，包括字符常量、字符串常量、数值常量等；</p>
</li>
<li>
<p><code>Annotations</code>，这个包含的东西比较杂，如名字空间，带限定的类型说明，特化模板函数以及<code>decltype</code>等，剩下的就都是<code>pragma</code>。</p>
</li>
<li>
<p><code>eof</code>，代表结尾。</p>
</li>
</ul>
<p>对于<code>TokenKind</code>的完整定义参见<code>TokenKinds.def</code>，这里把宏处理用的天花乱坠！</p>
<p>同时，这里的<code>Flags</code>代表的是一个压缩的枚举标记，他的值由这些枚举值确定：</p>
<div class="codehilite"><pre><span class="c1">// Various flags set per token:</span>
<span class="k">enum</span> <span class="n">TokenFlags</span>
<span class="p">{</span>
    <span class="n">StartOfLine</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>  <span class="c1">// At start of line or only after whitespace</span>
   <span class="c1">// (considering the line after macro expansion).</span>
    <span class="n">LeadingSpace</span> <span class="o">=</span> <span class="mh">0x02</span><span class="p">,</span>  <span class="c1">// Whitespace exists before this token (considering </span>
   <span class="c1">// whitespace after macro expansion).</span>
    <span class="n">DisableExpand</span> <span class="o">=</span> <span class="mh">0x04</span><span class="p">,</span>  <span class="c1">// This identifier may never be macro expanded.</span>
    <span class="n">NeedsCleaning</span> <span class="o">=</span> <span class="mh">0x08</span><span class="p">,</span>  <span class="c1">// Contained an escaped newline or trigraph.</span>
    <span class="n">LeadingEmptyMacro</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">,</span> <span class="c1">// Empty macro exists before this token.</span>
    <span class="n">HasUDSuffix</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>    <span class="c1">// This string or character literal has a ud-suffix.</span>
    <span class="n">HasUCN</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">,</span>         <span class="c1">// This identifier contains a UCN.</span>
    <span class="n">IgnoredComma</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">,</span>   <span class="c1">// This comma is not a macro argument separator (MS).</span>
    <span class="n">StringifiedInMacro</span> <span class="o">=</span> <span class="mh">0x100</span><span class="p">,</span> <span class="c1">// This string or character literal is formed by</span>
                                <span class="c1">// macro stringizing or charizing operator.</span>
<span class="p">};</span>
</pre></div>


<p>这里绝大部分的标志都是用来处理<code>Macro</code>展开的。具体的意义需要参考<code>C99</code>中关于宏展开的章节来看，此外这里的代码还考虑了<code>gcc</code>和<code>ms</code>的各种预处理扩展。</p>
<h1 id="9eb729">符号</h1>
<p>用来处理标识符的类型叫<code>Identifier</code>，但是这么重要的类型定义是放在<code>IdentifierTable.h</code>中的，跟<code>IdentifierTable</code>这个符号表一起存储的。其实这个<code>Identifier</code>的数据成员不算很多，基本就是一些标志位：</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">IdentifierInfo</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="nl">TokenID</span> <span class="p">:</span> <span class="mi">9</span><span class="p">;</span> <span class="c1">// Front-end token ID or tok::identifier.</span>
    <span class="c1">// Objective-C keyword (&#39;protocol&#39; in &#39;@protocol&#39;) or builtin (__builtin_inf).</span>
    <span class="c1">// First NUM_OBJC_KEYWORDS values are for Objective-C, the remaining values</span>
    <span class="c1">// are for builtins.</span>
    <span class="kt">unsigned</span> <span class="nl">ObjCOrBuiltinID</span> <span class="p">:</span> <span class="mi">13</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="nl">HasMacro</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// True if there is a #define for this.</span>
    <span class="kt">bool</span> <span class="nl">HadMacro</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// True if there was a #define for this.</span>
    <span class="kt">bool</span> <span class="nl">IsExtension</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// True if identifier is a lang extension.</span>
    <span class="kt">bool</span> <span class="nl">IsFutureCompatKeyword</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// True if identifier is a keyword in a</span>
                                 <span class="c1">// newer Standard or proposed Standard.</span>
    <span class="kt">bool</span> <span class="nl">IsPoisoned</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// True if identifier is poisoned.</span>
    <span class="kt">bool</span> <span class="nl">IsCPPOperatorKeyword</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// True if ident is a C++ operator keyword.</span>
    <span class="kt">bool</span> <span class="nl">NeedsHandleIdentifier</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// See &quot;RecomputeNeedsHandleIdentifier&quot;.</span>
    <span class="kt">bool</span> <span class="nl">IsFromAST</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// True if identifier was loaded (at least </span>
                                 <span class="c1">// partially) from an AST file.</span>
    <span class="kt">bool</span> <span class="nl">ChangedAfterLoad</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// True if identifier has changed from the</span>
                                 <span class="c1">// definition loaded from an AST file.</span>
    <span class="kt">bool</span> <span class="nl">RevertedTokenID</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// True if revertTokenIDToIdentifier was</span>
                                 <span class="c1">// called.</span>
    <span class="kt">bool</span> <span class="nl">OutOfDate</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// True if there may be additional</span>
                                 <span class="c1">// information about this identifier</span>
                                 <span class="c1">// stored externally.</span>
    <span class="kt">bool</span> <span class="nl">IsModulesImport</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// True if this is the &#39;import&#39; contextual</span>
                                 <span class="c1">// keyword.</span>
    <span class="c1">// 30 bit left in 64-bit word.</span>

    <span class="kt">void</span> <span class="o">*</span><span class="n">FETokenInfo</span><span class="p">;</span>               <span class="c1">// Managed by the language front-end.</span>
    <span class="n">llvm</span><span class="o">::</span><span class="n">StringMapEntry</span><span class="o">&lt;</span><span class="n">IdentifierInfo</span><span class="o">*&gt;</span> <span class="o">*</span><span class="n">Entry</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里的<code>TokenID</code>其实就类似于<code>TokenKind</code>，这里也牵涉到了宏处理，重复利用了<code>TokenKinds.def</code>文件。<code>isPoison</code>的作用是用来指明当前标识符是否有问题，如果有问题则之后的使用都会爆错误或者警告。还有一个需要特别提到的地方就是<code>Entry</code>这个成员，它其实指向的是当前<code>IdentifierInfo</code>在<code>StringMapEntry</code>中的存储位点，也就是一个互指结构。根据当前类中所定义的一些函数即可猜测出更多的<code>IdentifierTable</code>的信息。例如下面这个获得标识符名称的实现：</p>
<div class="codehilite"><pre><span class="c1">/// \brief Return the beginning of the actual null-terminated string for this</span>
<span class="c1">/// identifier.</span>
<span class="c1">///</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">getNameStart</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Entry</span><span class="p">)</span> <span class="k">return</span> <span class="n">Entry</span><span class="o">-&gt;</span><span class="n">getKeyData</span><span class="p">();</span>
    <span class="c1">// FIXME: This is gross. It would be best not to embed specific details</span>
    <span class="c1">// of the PTH file format here.</span>
    <span class="c1">// The &#39;this&#39; pointer really points to a</span>
    <span class="c1">// std::pair&lt;IdentifierInfo, const char*&gt;, where internal pointer</span>
    <span class="c1">// points to the external string data.</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">IdentifierInfo</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span> <span class="n">actualtype</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">((</span><span class="k">const</span> <span class="n">actualtype</span><span class="o">*</span><span class="p">)</span> <span class="k">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里有两个路径，一个是当前标识符放在了<code>IdentifierTable</code>之中时直接返回<code>KeyData</code>，一个是当前标识符来自于<code>PTH</code>时直接返回当前对象后面的第一个字节。第二个执行路径暴露了<code>PTH</code>的实现，注释里面也说这么干不好。</p>
<p>同样的，<code>getLength</code>函数也复用了这个性质：</p>
<div class="codehilite"><pre><span class="c1">/// \brief Efficiently return the length of this identifier info.</span>
<span class="c1">///</span>
<span class="kt">unsigned</span> <span class="nf">getLength</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Entry</span><span class="p">)</span> <span class="k">return</span> <span class="n">Entry</span><span class="o">-&gt;</span><span class="n">getKeyLength</span><span class="p">();</span>
    <span class="c1">// FIXME: This is gross. It would be best not to embed specific details</span>
    <span class="c1">// of the PTH file format here.</span>
    <span class="c1">// The &#39;this&#39; pointer really points to a</span>
    <span class="c1">// std::pair&lt;IdentifierInfo, const char*&gt;, where internal pointer</span>
    <span class="c1">// points to the external string data.</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">IdentifierInfo</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span> <span class="n">actualtype</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">((</span><span class="k">const</span> <span class="n">actualtype</span><span class="o">*</span><span class="p">)</span> <span class="k">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="p">(((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里的长度操作我只能说掉渣天，这个<code>const char*</code>的头两个字节居然编码了长度，虽然是逆序的。同时也暴露了一个问题，标识符长度藏在了<code>this</code>指针的两字节<code>padding</code>中，同时标识符长度上限是256*256，虽然正常情况下这不是一个问题。</p>
<h1 id="ceb0aa">符号表</h1>
<p>符号表的类型是<code>IdentifierTable</code>,其基本数据成员就两个：</p>
<div class="codehilite"><pre><span class="c1">/// \brief Implements an efficient mapping from strings to IdentifierInfo nodes.</span>
<span class="c1">///</span>
<span class="c1">/// This has no other purpose, but this is an extremely performance-critical</span>
<span class="c1">/// piece of the code, as each occurrence of every identifier goes through</span>
<span class="c1">/// here when lexed.</span>
<span class="k">class</span> <span class="nc">IdentifierTable</span>
<span class="p">{</span>
    <span class="c1">// Shark shows that using MallocAllocator is *much* slower than using this</span>
    <span class="c1">// BumpPtrAllocator!</span>
    <span class="k">typedef</span> <span class="n">llvm</span><span class="o">::</span><span class="n">StringMap</span><span class="o">&lt;</span><span class="n">IdentifierInfo</span><span class="o">*</span><span class="p">,</span> <span class="n">llvm</span><span class="o">::</span><span class="n">BumpPtrAllocator</span><span class="o">&gt;</span> <span class="n">HashTableTy</span><span class="p">;</span>
    <span class="n">HashTableTy</span> <span class="n">HashTable</span><span class="p">;</span>

    <span class="n">IdentifierInfoLookup</span><span class="o">*</span> <span class="n">ExternalLookup</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里的\scode{HashTable}就是一个\scode{map<string,IdentifierInfo*>}，所有本地的名称与标识符的映射信息就存在里面。如果是外部标识符，则需要经过\scode{ExternalLookup}这个位置来访问。所以，总的查询函数为：</p>
<div class="codehilite"><pre><span class="c1">/// \brief Return the identifier token info for the specified named</span>
<span class="c1">/// identifier.</span>
<span class="n">IdentifierInfo</span> <span class="o">&amp;</span><span class="n">get</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="o">&amp;</span><span class="n">Entry</span> <span class="o">=</span> <span class="o">*</span><span class="n">HashTable</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">Name</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">)).</span><span class="n">first</span><span class="p">;</span>

    <span class="n">IdentifierInfo</span> <span class="o">*&amp;</span><span class="n">II</span> <span class="o">=</span> <span class="n">Entry</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">II</span><span class="p">)</span> <span class="k">return</span> <span class="o">*</span><span class="n">II</span><span class="p">;</span>

    <span class="c1">// No entry; if we have an external lookup, look there first.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ExternalLookup</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">II</span> <span class="o">=</span> <span class="n">ExternalLookup</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="n">Name</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">II</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">*</span><span class="n">II</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Lookups failed, make a new IdentifierInfo.</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">Mem</span> <span class="o">=</span> <span class="n">getAllocator</span><span class="p">().</span><span class="n">Allocate</span><span class="o">&lt;</span><span class="n">IdentifierInfo</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">II</span> <span class="o">=</span> <span class="k">new</span> <span class="p">(</span><span class="n">Mem</span><span class="p">)</span> <span class="n">IdentifierInfo</span><span class="p">();</span>

    <span class="c1">// Make sure getName() knows how to find the IdentifierInfo</span>
    <span class="c1">// contents.</span>
    <span class="n">II</span><span class="o">-&gt;</span><span class="n">Entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Entry</span><span class="p">;</span>

    <span class="k">return</span> <span class="o">*</span><span class="n">II</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>大概流程就是先查本地，然后查外部，如果都没有就在本地插入一个。注意最后的<code>II-&gt;Entry = \&amp;Entry;</code>，这个是用来维持自引用的。</p>
<p>对于查询方法还有另外一个版本，这个版本专门用来处理本地查询，相关代码与之前函数的基本一样，不再谈。</p>
<p>在符号表里面还有一个非常重要的类，<code>DeclarationNameExtra</code>。这个类存储了类内部函数的类型信息：</p>
<div class="codehilite"><pre><span class="c1">/// DeclarationNameExtra - Common base of the MultiKeywordSelector,</span>
<span class="c1">/// CXXSpecialName, and CXXOperatorIdName classes, all of which are</span>
<span class="c1">/// private classes that describe different kinds of names.</span>
<span class="k">class</span> <span class="nc">DeclarationNameExtra</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">/// ExtraKind - The kind of &quot;extra&quot; information stored in the</span>
    <span class="c1">/// DeclarationName. See @c ExtraKindOrNumArgs for an explanation of</span>
    <span class="c1">/// how these enumerator values are used.</span>
    <span class="k">enum</span> <span class="n">ExtraKind</span>
    <span class="p">{</span>
        <span class="n">CXXConstructor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">CXXDestructor</span><span class="p">,</span>
        <span class="n">CXXConversionFunction</span><span class="p">,</span>
<span class="cp">#define OVERLOADED_OPERATOR(Name,Spelling,Token,Unary,Binary,MemberOnly) \</span>
<span class="cp">CXXOperator##Name,</span>
<span class="cp">#include &quot;clang/Basic/OperatorKinds.def&quot;</span>
        <span class="n">CXXLiteralOperator</span><span class="p">,</span>
        <span class="n">CXXUsingDirective</span><span class="p">,</span>
        <span class="n">NUM_EXTRA_KINDS</span>
    <span class="p">};</span>

    <span class="c1">/// ExtraKindOrNumArgs - Either the kind of C++ special name or</span>
    <span class="c1">/// operator-id (if the value is one of the CXX* enumerators of</span>
    <span class="c1">/// ExtraKind), in which case the DeclarationNameExtra is also a</span>
    <span class="c1">/// CXXSpecialName, (for CXXConstructor, CXXDestructor, or</span>
    <span class="c1">/// CXXConversionFunction) CXXOperatorIdName, or CXXLiteralOperatorName,</span>
    <span class="c1">/// it may be also name common to C++ using-directives (CXXUsingDirective),</span>
    <span class="c1">/// otherwise it is NUM_EXTRA_KINDS+NumArgs, where NumArgs is the number of</span>
    <span class="c1">/// arguments in the Objective-C selector, in which case the</span>
    <span class="c1">/// DeclarationNameExtra is also a MultiKeywordSelector.</span>
    <span class="kt">unsigned</span> <span class="n">ExtraKindOrNumArgs</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>大家看到这里的<code>#define</code>没，简直魔性啊。利用这个宏定义和<code>OperatorKinds.def</code>文件就活生生的造出了100多个新的枚举值。同时<code>OperatorKinds.def</code>能够根据不同的宏定义衍生出不同的枚举值类型，所支持的宏定义都在文件头的<code>header gurad</code>中。</p>
<h1 id="af6598">宏管理</h1>
<p>在宏管理方面，主要有两个类，一个是<code>MacroInfo</code>，一个是<code>MacroArgs</code>。对于宏来说，主要分为两类：对象型和函数型，区别就在于有没有参数。<code>MacroInfo</code>描述的就是这些。而<code>MacroArgs</code>则存储了宏的参数列表。</p>
<h2 id="887c57">MacroArgs</h2>
<p>这个类的组成还是比较简单的：</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">MacroArgs</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">NumUnexpArgTokens</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">VarargsElided</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">PreExpArgTokens</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span> <span class="n">StringifiedArgs</span><span class="p">;</span>
    <span class="n">MacroArgs</span> <span class="o">*</span><span class="n">ArgCache</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<ul>
<li>
<p>NumUnexpArgTokens：宏参数的数量，实际的参数<code>Token</code>在内存中会紧接着当前的<code>MacroArgs</code>对象分配，每个宏实际参数都是以<code>EOF</code>来作为终结符的。</p>
</li>
<li>
<p>VarargsElided: 这个是<code>C99</code>的变参宏的参数形式，不用管。</p>
</li>
<li>
<p>PreExpArgTokens:这个是预展开的实际参数，由于展开之后的参数可能有多个<code>token</code>，所以每个参数是<code>token</code>的<code>vector</code>，并以<code>EOF</code>为结尾，总的实参就是<code>vector&lt;vector&lt;token&gt;&gt;</code>，对于还没计算的参数展开，保留为空。</p>
</li>
<li>
<p>StringifiedArgs:这个是处理<code>#</code>操作符的。</p>
</li>
<li>
<p>ArgCache:这个是空闲的<code>MacroArgs</code>内存区域的头指针。</p>
</li>
</ul>
<p>首先需要说一下<code>UnexpArgTokens</code>这个的存储区域，注释里面说这些<code>token</code>是存储于当前对象末尾的，导致了这些区域的内存访问变得非常诡异...</p>
<div class="codehilite"><pre><span class="k">const</span> <span class="n">Token</span> <span class="o">*</span><span class="n">MacroArgs</span><span class="o">::</span><span class="n">getUnexpArgument</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">Arg</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// The unexpanded argument tokens start immediately after the MacroArgs object</span>
    <span class="c1">// in memory.</span>
    <span class="c1">//这又是一个依赖于实现的东西啊，内存对齐呢！ 谁说当前对象末尾一定无缝隙链接Token啊</span>
    <span class="k">const</span> <span class="n">Token</span> <span class="o">*</span><span class="n">Start</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Token</span> <span class="o">*</span><span class="p">)(</span><span class="k">this</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">Token</span> <span class="o">*</span><span class="n">Result</span> <span class="o">=</span> <span class="n">Start</span><span class="p">;</span>
    <span class="c1">// Scan to find Arg.</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">Arg</span><span class="p">;</span> <span class="o">++</span><span class="n">Result</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">Result</span> <span class="o">&lt;</span> <span class="n">Start</span> <span class="o">+</span> <span class="n">NumUnexpArgTokens</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Invalid arg #&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Result</span><span class="o">-&gt;</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">eof</span><span class="p">))</span>
            <span class="o">--</span><span class="n">Arg</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">Result</span> <span class="o">&lt;</span> <span class="n">Start</span> <span class="o">+</span> <span class="n">NumUnexpArgTokens</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Invalid arg #&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>强制了内存布局和对齐啊：<code>(const Token *)(this + 1)</code>。从这个实现中我们可以看出，每个<code>UnexpArgument</code>是一个以<code>EOF</code>分割的<code>Token</code>数组，内存区域连续分配。</p>
<p>这个<code>MacroArgs</code>类型对象的生命周期是被预处理器<code>Preprocessor</code>托管的，所以他的创建需要下面的静态函数：</p>
<div class="codehilite"><pre><span class="k">static</span> <span class="n">MacroArgs</span> <span class="o">*</span><span class="nf">create</span><span class="p">(</span><span class="k">const</span> <span class="n">MacroInfo</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span>
        <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span> <span class="n">UnexpArgTokens</span><span class="p">,</span>
        <span class="kt">bool</span> <span class="n">VarargsElided</span><span class="p">,</span> <span class="n">Preprocessor</span> <span class="o">&amp;</span><span class="n">PP</span><span class="p">);</span>
</pre></div>


<p>其具体执行流程就是从预处理器的空闲内存列表<code>\&amp;PP.MacroArgCache</code>中找到能够满足条件<code>*Entry)-&gt;NumUnexpArgTokens &gt;= UnexpArgTokens.size()</code>且内存区域最小的<code>Entry</code>，如果找不到就调用<code>malloc</code>，然后就是<code>placement new</code>。对象构造完成之后，将<code>unexpArgTokens</code>复制到<code>result</code>的内存区域后面，其实这样做很不好，暴露了<code>Token</code>的具体存储区！</p>
<p>对象的创建是通过<code>Preprocessor</code>来处理的，那么对象的销毁也是通过<code>Preprocessor</code>来处理。</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="n">MacroArgs</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span><span class="n">Preprocessor</span> <span class="o">&amp;</span><span class="n">PP</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">StringifiedArgs</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

    <span class="c1">// Don&#39;t clear PreExpArgTokens, just clear the entries.  Clearing the entries</span>
    <span class="c1">// would deallocate the element vectors.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">PreExpArgTokens</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">PreExpArgTokens</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">clear</span><span class="p">();</span>

    <span class="c1">// Add this to the preprocessor&#39;s free list.</span>
    <span class="c1">//总的空闲头节点存储在PP.MacroArgCache里面</span>
    <span class="c1">//感觉这样的话只能进行头节点处理啊，多节点分配就崩了</span>
    <span class="n">ArgCache</span> <span class="o">=</span> <span class="n">PP</span><span class="p">.</span><span class="n">MacroArgCache</span><span class="p">;</span>
    <span class="n">PP</span><span class="p">.</span><span class="n">MacroArgCache</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里的<code>destroy</code>只是用来释放展开之后的宏参数<code>token</code>的，同时将当前节点挂载到预处理器的空闲链表头。</p>
<p>真正完整的销毁是这个：</p>
<div class="codehilite"><pre><span class="n">MacroArgs</span> <span class="o">*</span><span class="n">MacroArgs</span><span class="o">::</span><span class="n">deallocate</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">MacroArgs</span> <span class="o">*</span><span class="n">Next</span> <span class="o">=</span> <span class="n">ArgCache</span><span class="p">;</span>

    <span class="c1">// Run the dtor to deallocate the vectors.</span>
    <span class="k">this</span><span class="o">-&gt;~</span><span class="n">MacroArgs</span><span class="p">();</span>
    <span class="c1">// Release the memory for the object.</span>
    <span class="n">free</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">Next</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p><code>free this</code>与<code>delete this</code>有异曲同工之妙啊，用错了可是蹦的相当惨，所以该函数只能在 <code>Preprocessor</code>中调用。</p>
<p>对于展开后参数的访问，是与参数展开过程合并的，即参数展开只有在需要时才展开，是<code>lazy</code>的。</p>
<div class="codehilite"><pre><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span> <span class="o">&amp;</span>
<span class="n">MacroArgs</span><span class="o">::</span><span class="n">getPreExpArgument</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">Arg</span><span class="p">,</span> <span class="k">const</span> <span class="n">MacroInfo</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span>
    <span class="n">Preprocessor</span> <span class="o">&amp;</span><span class="n">PP</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">Arg</span> <span class="o">&lt;</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getNumArgs</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Invalid argument number!&quot;</span><span class="p">);</span>

    <span class="c1">// If we have already computed this, return it.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PreExpArgTokens</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getNumArgs</span><span class="p">())</span>
        <span class="n">PreExpArgTokens</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">MI</span><span class="o">-&gt;</span><span class="n">getNumArgs</span><span class="p">());</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Result</span> <span class="o">=</span> <span class="n">PreExpArgTokens</span><span class="p">[</span><span class="n">Arg</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Result</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>

    <span class="n">SaveAndRestore</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">PreExpandingMacroArgs</span><span class="p">(</span><span class="n">PP</span><span class="p">.</span><span class="n">InMacroArgPreExpansion</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

    <span class="k">const</span> <span class="n">Token</span> <span class="o">*</span><span class="n">AT</span> <span class="o">=</span> <span class="n">getUnexpArgument</span><span class="p">(</span><span class="n">Arg</span><span class="p">);</span>
    <span class="kt">unsigned</span> <span class="n">NumToks</span> <span class="o">=</span> <span class="n">getArgLength</span><span class="p">(</span><span class="n">AT</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// Include the EOF.</span>

    <span class="c1">// Otherwise, we have to pre-expand this argument, populating Result.  To do</span>
    <span class="c1">// this, we set up a fake TokenLexer to lex from the unexpanded argument</span>
    <span class="c1">// list.  With this installed, we lex expanded tokens until we hit the EOF</span>
    <span class="c1">// token at the end of the unexp list.</span>
    <span class="n">PP</span><span class="p">.</span><span class="n">EnterTokenStream</span><span class="p">(</span><span class="n">AT</span><span class="p">,</span> <span class="n">NumToks</span><span class="p">,</span> <span class="nb">false</span> <span class="cm">/*disable expand*/</span><span class="p">,</span>
        <span class="nb">false</span> <span class="cm">/*owns tokens*/</span><span class="p">);</span>


<span class="p">}</span>
</pre></div>


<p>访问时，首先判断是否已经展开了:<code>PreExpArgTokens[Arg]</code>，否则需要进行展开操作。这里用的是一个临时的预处理器，结果通过<code>PP.lex()</code>一个一个吐出来。最后把展开后的<code>token</code>存进来。</p>
<div class="codehilite"><pre><span class="n">PP</span><span class="p">.</span><span class="n">EnterTokenStream</span><span class="p">(</span><span class="n">AT</span><span class="p">,</span> <span class="n">NumToks</span><span class="p">,</span> <span class="nb">false</span> <span class="cm">/*disable expand*/</span><span class="p">,</span>
    <span class="nb">false</span> <span class="cm">/*owns tokens*/</span><span class="p">);</span>
<span class="c1">// Lex all of the macro-expanded tokens into Result.</span>
<span class="k">do</span>
<span class="p">{</span>
    <span class="n">Result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Token</span><span class="p">());</span>
    <span class="n">Token</span> <span class="o">&amp;</span><span class="n">Tok</span> <span class="o">=</span> <span class="n">Result</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
    <span class="n">PP</span><span class="p">.</span><span class="n">Lex</span><span class="p">(</span><span class="n">Tok</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">while</span> <span class="p">(</span><span class="n">Result</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">isNot</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">eof</span><span class="p">));</span>

<span class="c1">// Pop the token stream off the top of the stack.  We know that the internal</span>
<span class="c1">// pointer inside of it is to the &quot;end&quot; of the token stream, but the stack</span>
<span class="c1">// will not otherwise be popped until the next token is lexed.  The problem is</span>
<span class="c1">// that the token may be lexed sometime after the vector of tokens itself is</span>
<span class="c1">// destroyed, which would be badness.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">PP</span><span class="p">.</span><span class="n">InCachingLexMode</span><span class="p">())</span>
    <span class="n">PP</span><span class="p">.</span><span class="n">ExitCachingLexMode</span><span class="p">();</span>
<span class="n">PP</span><span class="p">.</span><span class="n">RemoveTopOfLexerStack</span><span class="p">();</span>
<span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
</pre></div>


<p>这里还有一个重量级的函数<code>stringinify</code>，用来处理<code>#</code>连接的，将连接起来的<code>token</code>组合成一个<code>string</code>。代码逻辑比较扭曲，这里就不谈了。相关逻辑见<code>C99</code>标准的<code>6.10.3.2p2</code>。</p>
<h2 id="426eb0">MacroInfo</h2>
<p>这个类的格局就比<code>MacroArgs</code>大了很多，不过很多都是标识位，不用管太多。主要的数据成员如下：</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">MacroInfo</span>
<span class="p">{</span>
    <span class="c1">//===--------------------------------------------------------------------===//</span>
    <span class="c1">// State set when the macro is defined.</span>

    <span class="c1">/// \brief The location the macro is defined.</span>
    <span class="n">SourceLocation</span> <span class="n">Location</span><span class="p">;</span>
    <span class="c1">/// \brief The location of the last token in the macro.</span>
    <span class="n">SourceLocation</span> <span class="n">EndLocation</span><span class="p">;</span>

    <span class="c1">/// \brief The list of arguments for a function-like macro.</span>
    <span class="c1">///</span>
    <span class="c1">/// ArgumentList points to the first of NumArguments pointers.</span>
    <span class="c1">///</span>
    <span class="c1">/// This can be empty, for, e.g. &quot;#define X()&quot;.  In a C99-style variadic</span>
    <span class="c1">/// macro, this includes the \c __VA_ARGS__ identifier on the list.</span>
    <span class="n">IdentifierInfo</span> <span class="o">**</span><span class="n">ArgumentList</span><span class="p">;</span>

    <span class="c1">/// \see ArgumentList</span>
    <span class="kt">unsigned</span> <span class="n">NumArguments</span><span class="p">;</span>

    <span class="c1">/// \brief This is the list of tokens that the macro is defined to.</span>
    <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Token</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">ReplacementTokens</span><span class="p">;</span>

    <span class="c1">/// \brief Length in characters of the macro definition.</span>
    <span class="k">mutable</span> <span class="kt">unsigned</span> <span class="n">DefinitionLength</span><span class="p">;</span>
    <span class="k">mutable</span> <span class="kt">bool</span> <span class="nl">IsDefinitionLengthCached</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>


<p>对于函数型宏来说，他是有参数列表的，所有参数的指针按序排在以<code>ArgumentList</code>的内存区域中，总共<code>NumArguments</code>个。整个宏的长度是<code>DefinitionLength</code>，这个是延迟计算的，紧接着的<code>IsDefinitionLengthCached</code>就是这个长度是否已经计算的标记值。这个延迟计算的代码也很直白,就是获得头<code>Token</code>和尾<code>token</code>，然后获得展开位置，计算差值：</p>
<div class="codehilite"><pre><span class="kt">unsigned</span> <span class="n">MacroInfo</span><span class="o">::</span><span class="n">getDefinitionLengthSlow</span><span class="p">(</span><span class="n">SourceManager</span> <span class="o">&amp;</span><span class="n">SM</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">IsDefinitionLengthCached</span><span class="p">);</span>
    <span class="n">IsDefinitionLengthCached</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ReplacementTokens</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">DefinitionLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">const</span> <span class="n">Token</span> <span class="o">&amp;</span><span class="n">firstToken</span> <span class="o">=</span> <span class="n">ReplacementTokens</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">Token</span> <span class="o">&amp;</span><span class="n">lastToken</span> <span class="o">=</span> <span class="n">ReplacementTokens</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
    <span class="n">SourceLocation</span> <span class="n">macroStart</span> <span class="o">=</span> <span class="n">firstToken</span><span class="p">.</span><span class="n">getLocation</span><span class="p">();</span>
    <span class="n">SourceLocation</span> <span class="n">macroEnd</span> <span class="o">=</span> <span class="n">lastToken</span><span class="p">.</span><span class="n">getLocation</span><span class="p">();</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">macroStart</span><span class="p">.</span><span class="n">isValid</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">macroEnd</span><span class="p">.</span><span class="n">isValid</span><span class="p">());</span>
    <span class="n">assert</span><span class="p">((</span><span class="n">macroStart</span><span class="p">.</span><span class="n">isFileID</span><span class="p">()</span> <span class="o">||</span> <span class="n">firstToken</span><span class="p">.</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">comment</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
        <span class="s">&quot;Macro defined in macro?&quot;</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">((</span><span class="n">macroEnd</span><span class="p">.</span><span class="n">isFileID</span><span class="p">()</span> <span class="o">||</span> <span class="n">lastToken</span><span class="p">.</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">comment</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
        <span class="s">&quot;Macro defined in macro?&quot;</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">FileID</span><span class="p">,</span> <span class="kt">unsigned</span><span class="o">&gt;</span>
        <span class="n">startInfo</span> <span class="o">=</span> <span class="n">SM</span><span class="p">.</span><span class="n">getDecomposedExpansionLoc</span><span class="p">(</span><span class="n">macroStart</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">FileID</span><span class="p">,</span> <span class="kt">unsigned</span><span class="o">&gt;</span>
        <span class="n">endInfo</span> <span class="o">=</span> <span class="n">SM</span><span class="p">.</span><span class="n">getDecomposedExpansionLoc</span><span class="p">(</span><span class="n">macroEnd</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">startInfo</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="n">endInfo</span><span class="p">.</span><span class="n">first</span> <span class="o">&amp;&amp;</span>
        <span class="s">&quot;Macro definition spanning multiple FileIDs ?&quot;</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">startInfo</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;=</span> <span class="n">endInfo</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
    <span class="n">DefinitionLength</span> <span class="o">=</span> <span class="n">endInfo</span><span class="p">.</span><span class="n">second</span> <span class="o">-</span> <span class="n">startInfo</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
    <span class="n">DefinitionLength</span> <span class="o">+=</span> <span class="n">lastToken</span><span class="p">.</span><span class="n">getLength</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">DefinitionLength</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>剩下的就是一些位标记了，分为两种：一种是宏的自身属性，另外一种是使用属性。下面的是自身属性：</p>
<div class="codehilite"><pre><span class="c1">//是否是函数宏还是对象宏.</span>
<span class="kt">bool</span> <span class="nl">IsFunctionLike</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// 是否是C99的变参宏</span>
<span class="kt">bool</span> <span class="nl">IsC99Varargs</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">//是否是GNU的变参宏</span>
<span class="kt">bool</span> <span class="nl">IsGNUVarargs</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">//是否是语言内置宏，如__FILE__ __LINE__等</span>
<span class="kt">bool</span> <span class="nl">IsBuiltinMacro</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">/// \brief Whether this macro contains the sequence &quot;, ## __VA_ARGS__&quot;</span>
<span class="kt">bool</span> <span class="nl">HasCommaPasting</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>


<p>下面的是使用属性：</p>
<div class="codehilite"><pre><span class="c1">//===--------------------------------------------------------------------===//</span>
<span class="c1">// State that changes as the macro is used.</span>

<span class="c1">/// \brief True if we have started an expansion of this macro already.</span>
<span class="c1">///</span>
<span class="c1">/// This disables recursive expansion, which would be quite bad for things</span>
<span class="c1">/// like #define A A.</span>
<span class="kt">bool</span> <span class="nl">IsDisabled</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">/// \brief True if this macro is either defined in the main file and has</span>
<span class="c1">/// been used, or if it is not defined in the main file.</span>
<span class="c1">///</span>
<span class="c1">/// This is used to emit -Wunused-macros diagnostics.</span>
<span class="kt">bool</span> <span class="nl">IsUsed</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">/// \brief True if this macro can be redefined without emitting a warning.</span>
<span class="kt">bool</span> <span class="nl">IsAllowRedefinitionsWithoutWarning</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">/// \brief Must warn if the macro is unused at the end of translation unit.</span>
<span class="kt">bool</span> <span class="nl">IsWarnIfUnused</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">/// \brief Whether this macro info was loaded from an AST file.</span>
<span class="kt">unsigned</span> <span class="nl">FromASTFile</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">/// \brief Whether this macro was used as header guard.</span>
<span class="kt">bool</span> <span class="nl">UsedForHeaderGuard</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>


<p>类中还有很多函数来操作这些可更改的位，但是内容很简单，这里就不详谈了。</p>
<p>对于<code>MacroInfo</code>来说，比较重要的操作是判断两个宏是否相等。相等又分为两种，一种是语义上的相等，此时函数参数名可以变化；另外一种是词法上的相等，就是一个一个<code>Token</code>的比较。因此在比较的时候，如果函数体里面遇到函数参数，就查看函数参数的索引是否相等。</p>
<div class="codehilite"><pre><span class="kt">bool</span> <span class="n">MacroInfo</span><span class="o">::</span><span class="n">isIdenticalTo</span><span class="p">(</span><span class="k">const</span> <span class="n">MacroInfo</span> <span class="o">&amp;</span><span class="n">Other</span><span class="p">,</span> <span class="n">Preprocessor</span> <span class="o">&amp;</span><span class="n">PP</span><span class="p">,</span>
<span class="kt">bool</span> <span class="n">Syntactically</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
<span class="kt">bool</span> <span class="n">Lexically</span> <span class="o">=</span> <span class="o">!</span><span class="n">Syntactically</span><span class="p">;</span>

<span class="c1">// Check # tokens in replacement, number of args, and various flags all match.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ReplacementTokens</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Other</span><span class="p">.</span><span class="n">ReplacementTokens</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span>
    <span class="n">getNumArgs</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Other</span><span class="p">.</span><span class="n">getNumArgs</span><span class="p">()</span> <span class="o">||</span>
    <span class="n">isFunctionLike</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Other</span><span class="p">.</span><span class="n">isFunctionLike</span><span class="p">()</span> <span class="o">||</span>
    <span class="n">isC99Varargs</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Other</span><span class="p">.</span><span class="n">isC99Varargs</span><span class="p">()</span> <span class="o">||</span>
    <span class="n">isGNUVarargs</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Other</span><span class="p">.</span><span class="n">isGNUVarargs</span><span class="p">())</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">Lexically</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Check arguments.</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">arg_iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">arg_begin</span><span class="p">(),</span> <span class="n">OI</span> <span class="o">=</span> <span class="n">Other</span><span class="p">.</span><span class="n">arg_begin</span><span class="p">(),</span> <span class="n">E</span> <span class="o">=</span> <span class="n">arg_end</span><span class="p">();</span>
    <span class="n">I</span> <span class="o">!=</span> <span class="n">E</span><span class="p">;</span> <span class="o">++</span><span class="n">I</span><span class="p">,</span> <span class="o">++</span><span class="n">OI</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">I</span> <span class="o">!=</span> <span class="o">*</span><span class="n">OI</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Check all the tokens.</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">ReplacementTokens</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">Token</span> <span class="o">&amp;</span><span class="n">A</span> <span class="o">=</span> <span class="n">ReplacementTokens</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">const</span> <span class="n">Token</span> <span class="o">&amp;</span><span class="n">B</span> <span class="o">=</span> <span class="n">Other</span><span class="p">.</span><span class="n">ReplacementTokens</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">getKind</span><span class="p">()</span> <span class="o">!=</span> <span class="n">B</span><span class="p">.</span><span class="n">getKind</span><span class="p">())</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="c1">// If this isn&#39;t the first first token, check that the whitespace and</span>
    <span class="c1">// start-of-line characteristics match.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
        <span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">isAtStartOfLine</span><span class="p">()</span> <span class="o">!=</span> <span class="n">B</span><span class="p">.</span><span class="n">isAtStartOfLine</span><span class="p">()</span> <span class="o">||</span>
            <span class="n">A</span><span class="p">.</span><span class="n">hasLeadingSpace</span><span class="p">()</span> <span class="o">!=</span> <span class="n">B</span><span class="p">.</span><span class="n">hasLeadingSpace</span><span class="p">()))</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="c1">// If this is an identifier, it is easy.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">getIdentifierInfo</span><span class="p">()</span> <span class="o">||</span> <span class="n">B</span><span class="p">.</span><span class="n">getIdentifierInfo</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">getIdentifierInfo</span><span class="p">()</span> <span class="o">==</span> <span class="n">B</span><span class="p">.</span><span class="n">getIdentifierInfo</span><span class="p">())</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Lexically</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="c1">// With syntactic equivalence the parameter names can be different as long</span>
        <span class="c1">// as they are used in the same place.</span>
        <span class="kt">int</span> <span class="n">AArgNum</span> <span class="o">=</span> <span class="n">getArgumentNum</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">getIdentifierInfo</span><span class="p">());</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">AArgNum</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">AArgNum</span> <span class="o">!=</span> <span class="n">Other</span><span class="p">.</span><span class="n">getArgumentNum</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">getIdentifierInfo</span><span class="p">()))</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Otherwise, check the spelling.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PP</span><span class="p">.</span><span class="n">getSpelling</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">!=</span> <span class="n">PP</span><span class="p">.</span><span class="n">getSpelling</span><span class="p">(</span><span class="n">B</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h2 id="a15340">MacroDirective</h2>
<p>这个<code>MacroDirective</code>类似于名字空间的存在，用来界定宏的可见性。在宏的可见性方面，定义了以下的枚举类型：</p>
<div class="codehilite"><pre><span class="k">enum</span> <span class="n">Kind</span>
<span class="p">{</span>
    <span class="n">MD_Define</span><span class="p">,</span> <span class="n">MD_Undefine</span><span class="p">,</span> <span class="n">MD_Visibility</span>
<span class="p">};</span>
</pre></div>


<p>而整个<code>MacroDirective</code>的数据成员也比较少，包括如下：</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">MacroDirective</span>
<span class="p">{</span>
    <span class="c1">/// \brief Previous macro directive for the same identifier, or NULL.</span>
    <span class="n">MacroDirective</span> <span class="o">*</span><span class="n">Previous</span><span class="p">;</span>

    <span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">;</span>

    <span class="c1">/// \brief MacroDirective kind.</span>
    <span class="kt">unsigned</span> <span class="nl">MDKind</span> <span class="p">:</span> <span class="mi">2</span><span class="p">;</span>

    <span class="c1">/// \brief True if the macro directive was loaded from a PCH file.</span>
    <span class="kt">bool</span> <span class="nl">IsFromPCH</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// Used by VisibilityMacroDirective ----------------------------------------//</span>

    <span class="c1">/// \brief Whether the macro has public visibility (when described in a</span>
    <span class="c1">/// module).</span>
    <span class="kt">bool</span> <span class="nl">IsPublic</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>其实相关的内容也就三个：类型，位置，串联指针。没有什么特殊的，就不解释了。</p>
<p>同时根据<code>MDKind</code>的具体类型，特化了三种形式，即子类：<code>DefMacroDirective, UndefMacroDirective, VisibilityMacroDirective</code>。</p>
<p>这个是<code>define</code>的<code>MacroDirective</code>形式，所以他的定义是直接继承过来的：</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">DefMacroDirective</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MacroDirective</span>
<span class="p">{</span>
    <span class="n">MacroInfo</span> <span class="o">*</span><span class="n">Info</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>里面还夹带了一个<code>MacroInfo</code>。</p>
<p>类似的有UndefMacroDirective:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">UndefMacroDirective</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MacroDirective</span>
</pre></div>


<p>这里就没有<code>MacroInfo</code>那个数据成员了，不科学。对于VisibilityMacroDirective来说也是如此：</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">VisibilityMacroDirective</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MacroDirective</span>
</pre></div>


<p>下面的这个寻找宏定义的函数就利用了这几种类型之间的动态类型转换。</p>
<div class="codehilite"><pre><span class="n">MacroDirective</span><span class="o">::</span><span class="n">DefInfo</span> <span class="n">MacroDirective</span><span class="o">::</span><span class="n">getDefinition</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">MacroDirective</span> <span class="o">*</span><span class="n">MD</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="n">SourceLocation</span> <span class="n">UndefLoc</span><span class="p">;</span>
    <span class="n">Optional</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">isPublic</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">MD</span><span class="p">;</span> <span class="n">MD</span> <span class="o">=</span> <span class="n">MD</span><span class="o">-&gt;</span><span class="n">getPrevious</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">DefMacroDirective</span> <span class="o">*</span><span class="n">DefMD</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">DefMacroDirective</span><span class="o">&gt;</span><span class="p">(</span><span class="n">MD</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">DefInfo</span><span class="p">(</span><span class="n">DefMD</span><span class="p">,</span> <span class="n">UndefLoc</span><span class="p">,</span>
                <span class="o">!</span><span class="n">isPublic</span><span class="p">.</span><span class="n">hasValue</span><span class="p">()</span> <span class="o">||</span> <span class="n">isPublic</span><span class="p">.</span><span class="n">getValue</span><span class="p">());</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">UndefMacroDirective</span> <span class="o">*</span><span class="n">UndefMD</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">UndefMacroDirective</span><span class="o">&gt;</span><span class="p">(</span><span class="n">MD</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">UndefLoc</span> <span class="o">=</span> <span class="n">UndefMD</span><span class="o">-&gt;</span><span class="n">getLocation</span><span class="p">();</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">VisibilityMacroDirective</span> <span class="o">*</span><span class="n">VisMD</span> <span class="o">=</span> <span class="n">cast</span><span class="o">&lt;</span><span class="n">VisibilityMacroDirective</span><span class="o">&gt;</span><span class="p">(</span><span class="n">MD</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isPublic</span><span class="p">.</span><span class="n">hasValue</span><span class="p">())</span>
            <span class="n">isPublic</span> <span class="o">=</span> <span class="n">VisMD</span><span class="o">-&gt;</span><span class="n">isPublic</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">DefInfo</span><span class="p">(</span><span class="k">nullptr</span><span class="p">,</span> <span class="n">UndefLoc</span><span class="p">,</span>
        <span class="o">!</span><span class="n">isPublic</span><span class="p">.</span><span class="n">hasValue</span><span class="p">()</span> <span class="o">||</span> <span class="n">isPublic</span><span class="p">.</span><span class="n">getValue</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>


<h2 id="84847d">MuduleMacro</h2>
<p>这个<code>ModuleMacro</code>代表的是在外部模块导入进来的宏导言。多个模块中可能会对同一个宏做多次定义，这里我们还要记录定义覆盖路径：</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">ModuleMacro</span> <span class="o">:</span> <span class="k">public</span> <span class="n">llvm</span><span class="o">::</span><span class="n">FoldingSetNode</span>
<span class="p">{</span>
    <span class="c1">/// The name defined by the macro.</span>
    <span class="n">IdentifierInfo</span> <span class="o">*</span><span class="n">II</span><span class="p">;</span>
    <span class="c1">/// The body of the #define, or nullptr if this is a #undef.</span>
    <span class="n">MacroInfo</span> <span class="o">*</span><span class="n">Macro</span><span class="p">;</span>
    <span class="c1">/// The module that exports this macro.</span>
    <span class="n">Module</span> <span class="o">*</span><span class="n">OwningModule</span><span class="p">;</span>
    <span class="c1">/// The number of module macros that override this one.</span>
    <span class="kt">unsigned</span> <span class="n">NumOverriddenBy</span><span class="p">;</span>
    <span class="c1">/// The number of modules whose macros are directly overridden by this one.</span>
    <span class="kt">unsigned</span> <span class="n">NumOverrides</span><span class="p">;</span>
    <span class="c1">// ModuleMacro *OverriddenMacros[NumOverrides];</span>
<span class="p">}</span>
</pre></div>


<p>从这个的类型继承自<code>FoldingSetNode</code>可以看出，所有的<code>ModuleMacro</code>都是组织为一个<code>FoldingSet</code>之中的。</p>
<h2 id="b7345d">MacroDefinition</h2>
<p>这个类型用来记录当前宏的定义，此外还保留了各个定义历史信息。</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">MacroDefinition</span>
<span class="p">{</span>
    <span class="n">llvm</span><span class="o">::</span><span class="n">PointerIntPair</span><span class="o">&lt;</span><span class="n">DefMacroDirective</span> <span class="o">*</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">LatestLocalAndAmbiguous</span><span class="p">;</span>
    <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">ModuleMacro</span> <span class="o">*&gt;</span> <span class="n">ModuleMacros</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里的<code>LatestLocalAndAmbiguous</code>的最后一位是用来记录当前定义是否有歧义（宏的歧义？）。最新的定义存储在<code>ModuleMacro</code>的<code>back</code>。</p>
<h1 id="4985e4">头文件管理</h1>
<h2 id="028d64">Multiple Include Optimization</h2>
<p>这个文件处理的是头文件的多次插入的情况，这里的主要管理信息包括如下几个：</p>
<div class="codehilite"><pre><span class="c1">/// \brief Implements the simple state machine that the Lexer class uses to</span>
<span class="c1">/// detect files subject to the &#39;multiple-include&#39; optimization.</span>
<span class="c1">///</span>
<span class="c1">/// The public methods in this class are triggered by various</span>
<span class="c1">/// events that occur when a file is lexed, and after the entire file is lexed,</span>
<span class="c1">/// information about which macro (if any) controls the header is returned.</span>
<span class="k">class</span> <span class="nc">MultipleIncludeOpt</span>
<span class="p">{</span>
    <span class="c1">/// ReadAnyTokens - This is set to false when a file is first opened and true</span>
    <span class="c1">/// any time a token is returned to the client or a (non-multiple-include)</span>
    <span class="c1">/// directive is parsed.  When the final #endif is parsed this is reset back</span>
    <span class="c1">/// to false, that way any tokens before the first #ifdef or after the last</span>
    <span class="c1">/// #endif can be easily detected.</span>
    <span class="kt">bool</span> <span class="n">ReadAnyTokens</span><span class="p">;</span>

    <span class="c1">/// ImmediatelyAfterTopLevelIfndef - This is true when the only tokens</span>
    <span class="c1">/// processed in the file so far is an #ifndef and an identifier.  Used in</span>
    <span class="c1">/// the detection of header guards in a file.</span>
    <span class="kt">bool</span> <span class="n">ImmediatelyAfterTopLevelIfndef</span><span class="p">;</span>

    <span class="c1">/// ReadAnyTokens - This is set to false when a file is first opened and true</span>
    <span class="c1">/// any time a token is returned to the client or a (non-multiple-include)</span>
    <span class="c1">/// directive is parsed.  When the final #endif is parsed this is reset back</span>
    <span class="c1">/// to false, that way any tokens before the first #ifdef or after the last</span>
    <span class="c1">/// #endif can be easily detected.</span>
    <span class="kt">bool</span> <span class="n">DidMacroExpansion</span><span class="p">;</span>

    <span class="c1">/// TheMacro - The controlling macro for a file, if valid.</span>
    <span class="c1">///</span>
    <span class="k">const</span> <span class="n">IdentifierInfo</span> <span class="o">*</span><span class="n">TheMacro</span><span class="p">;</span>

    <span class="c1">/// DefinedMacro - The macro defined right after TheMacro, if any.</span>
    <span class="k">const</span> <span class="n">IdentifierInfo</span> <span class="o">*</span><span class="n">DefinedMacro</span><span class="p">;</span>

    <span class="n">SourceLocation</span> <span class="n">MacroLoc</span><span class="p">;</span>
    <span class="n">SourceLocation</span> <span class="n">DefinedLoc</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<ul>
<li>
<p><code>ReadAnyTokens</code>用来检测在<code>Header Guard</code>之外的词法单元。一个文件在打开时设置这个值为<code>false</code>，在遇到<code>#ifndef Header Guard</code>之后设置为<code>true</code>，在遇到<code>#endif</code>之后再设置为<code>false</code>。</p>
</li>
<li>
<p><code>ImmediatelyAfterTopLevelIfndef</code>用来表明我们刚处理了<code>#ifndef Header Guard</code>。</p>
</li>
<li>
<p><code>DidMacroExpansion</code>这个字段表示的是我们处理<code>Header Guard</code>对应的<code>#ifndef</code>期间是否进行了宏展开。如果进行了宏展开那就说明，那就说明当前<code>Header Guard</code>无法使用。</p>
</li>
<li>
<p><code>TheMacro</code>代表的是<code>Header Guard</code>的那个宏，这命名跟<code>The One</code>一样啊。</p>
</li>
<li>
<p><code>DefinedMacro</code> 这个是在<code>#ifndef</code>后面的那个<code>#define</code>，如果没有就为空。</p>
</li>
</ul>
<p>在初始化的时候，我们必须保守的设置这些值：</p>
<div class="codehilite"><pre><span class="n">MultipleIncludeOpt</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ReadAnyTokens</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">ImmediatelyAfterTopLevelIfndef</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">DidMacroExpansion</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">TheMacro</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">DefinedMacro</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>如果我们发现当前文件无法使用<code>Header Guard</code>，则标记一下：</p>
<div class="codehilite"><pre><span class="c1">/// Invalidate - Permanently mark this file as not being suitable for the</span>
<span class="c1">/// include-file optimization.</span>
<span class="kt">void</span> <span class="nf">Invalidate</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// If we have read tokens but have no controlling macro, the state-machine</span>
    <span class="c1">// below can never &quot;accept&quot;.</span>
    <span class="n">ReadAnyTokens</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">ImmediatelyAfterTopLevelIfndef</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">DefinedMacro</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">TheMacro</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>然后整个<code>Invalidate</code>过程是由下面两个状态机函数控制的。一个是<code>EnterTopLevelIfndef</code>:</p>
<div class="codehilite"><pre><span class="c1">/// \brief Called when entering a top-level #ifndef directive (or the</span>
<span class="c1">/// &quot;#if !defined&quot; equivalent) without any preceding tokens.</span>
<span class="c1">///</span>
<span class="c1">/// Note, we don&#39;t care about the input value of &#39;ReadAnyTokens&#39;.  The caller</span>
<span class="c1">/// ensures that this is only called if there are no tokens read before the</span>
<span class="c1">/// #ifndef.  The caller is required to do this, because reading the #if</span>
<span class="c1">/// line obviously reads in in tokens.</span>
<span class="kt">void</span> <span class="nf">EnterTopLevelIfndef</span><span class="p">(</span><span class="k">const</span> <span class="n">IdentifierInfo</span> <span class="o">*</span><span class="n">M</span><span class="p">,</span> <span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// If the macro is already set, this is after the top-level #endif.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">TheMacro</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Invalidate</span><span class="p">();</span>

    <span class="c1">// If we have already expanded a macro by the end of the #ifndef line, then</span>
    <span class="c1">// there is a macro expansion *in* the #ifndef line.  This means that the</span>
    <span class="c1">// condition could evaluate differently when subsequently #included.  Reject</span>
    <span class="c1">// this.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">DidMacroExpansion</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Invalidate</span><span class="p">();</span>

    <span class="c1">// Remember that we&#39;re in the #if and that we have the macro.</span>
    <span class="n">ReadAnyTokens</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">ImmediatelyAfterTopLevelIfndef</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">TheMacro</span> <span class="o">=</span> <span class="n">M</span><span class="p">;</span>
    <span class="n">MacroLoc</span> <span class="o">=</span> <span class="n">Loc</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>另外一个是<code>ExitTopLevelConditional</code>:</p>
<div class="codehilite"><pre><span class="c1">/// \brief Called when the lexer exits the top-level conditional.</span>
<span class="kt">void</span> <span class="nf">ExitTopLevelConditional</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// If we have a macro, that means the top of the file was ok.  Set our state</span>
    <span class="c1">// back to &quot;not having read any tokens&quot; so we can detect anything after the</span>
    <span class="c1">// #endif.</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TheMacro</span><span class="p">)</span> <span class="k">return</span> <span class="n">Invalidate</span><span class="p">();</span>

    <span class="c1">// At this point, we haven&#39;t &quot;read any tokens&quot; but we do have a controlling</span>
    <span class="c1">// macro.</span>
    <span class="n">ReadAnyTokens</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">ImmediatelyAfterTopLevelIfndef</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h2 id="c5d09e">HeaderMap</h2>
<p>这里的类是用来对头文件进行抽象的，代表了<code>Apple header map</code>的概念，以抹平底层的文件系统。其数据成员如下：</p>
<div class="codehilite"><pre><span class="c1">/// This class represents an Apple concept known as a &#39;header map&#39;.  To the</span>
<span class="c1">/// #include file resolution process, it basically acts like a directory of</span>
<span class="c1">/// symlinks to files.  Its advantages are that it is dense and more efficient</span>
<span class="c1">/// to create and process than a directory of symlinks.</span>
<span class="k">class</span> <span class="nc">HeaderMap</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">llvm</span><span class="o">::</span><span class="n">MemoryBuffer</span><span class="o">&gt;</span> <span class="n">FileBuffer</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">NeedsBSwap</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>一个代表文件内存区，一个表明是否需要处理字节序问题（大端或小端）。</p>
<p>在使用时，需要定义其他的结构来辅助<code>HeaderMap</code>的使用:</p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">HMapBucket</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">Key</span><span class="p">;</span>          <span class="c1">// Offset (into strings) of key.</span>

    <span class="kt">uint32_t</span> <span class="n">Prefix</span><span class="p">;</span>     <span class="c1">// Offset (into strings) of value prefix.</span>
    <span class="kt">uint32_t</span> <span class="n">Suffix</span><span class="p">;</span>     <span class="c1">// Offset (into strings) of value suffix.</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">HMapHeader</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">Magic</span><span class="p">;</span>           <span class="c1">// Magic word, also indicates byte order.</span>
    <span class="kt">uint16_t</span> <span class="n">Version</span><span class="p">;</span>         <span class="c1">// Version number -- currently 1.</span>
    <span class="kt">uint16_t</span> <span class="n">Reserved</span><span class="p">;</span>        <span class="c1">// Reserved for future use - zero for now.</span>
    <span class="kt">uint32_t</span> <span class="n">StringsOffset</span><span class="p">;</span>   <span class="c1">// Offset to start of string pool.</span>
    <span class="kt">uint32_t</span> <span class="n">NumEntries</span><span class="p">;</span>      <span class="c1">// Number of entries in the string table.</span>
    <span class="kt">uint32_t</span> <span class="n">NumBuckets</span><span class="p">;</span>      <span class="c1">// Number of buckets (always a power of 2).</span>
    <span class="kt">uint32_t</span> <span class="n">MaxValueLength</span><span class="p">;</span>  <span class="c1">// Length of longest result path (excluding nul).</span>
    <span class="c1">// An array of &#39;NumBuckets&#39; HMapBucket objects follows this header.</span>
    <span class="c1">// Strings follow the buckets, at StringsOffset.</span>
<span class="p">};</span>
</pre></div>


<p>这里的<code>HMapHeader</code>代表的是<code>HeadMap</code>序列化之后的文件头，如果从<code>FileEntry</code>反序列化出<code>HeaderMap</code>的话，首先判断这个文件开始的那些字节是否是一个合法的<code>HMapHeader</code>。这里有一个<code>Magic</code>和<code>Version</code>，他们的值定义在一个枚举之中：</p>
<div class="codehilite"><pre><span class="k">enum</span>
<span class="p">{</span>
    <span class="n">HMAP_HeaderMagicNumber</span> <span class="o">=</span> <span class="p">(</span><span class="sc">&#39;h&#39;</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="sc">&#39;m&#39;</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="sc">&#39;a&#39;</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="sc">&#39;p&#39;</span><span class="p">,</span>
    <span class="n">HMAP_HeaderVersion</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

    <span class="n">HMAP_EmptyBucketKey</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">};</span>
</pre></div>


<p>所以<code>HeaderMap</code>的静态构造函数可以以下方式实现，首先判断文件大小是否能够保存一个<code>HMapHeader</code>，然后就是版本号和<code>MagicNumber</code>的比较：</p>
<div class="codehilite"><pre><span class="c1">/// HeaderMap::Create - This attempts to load the specified file as a header</span>
<span class="c1">/// map.  If it doesn&#39;t look like a HeaderMap, it gives up and returns null.</span>
<span class="c1">/// If it looks like a HeaderMap but is obviously corrupted, it puts a reason</span>
<span class="c1">/// into the string error argument and returns null.</span>
<span class="k">const</span> <span class="n">HeaderMap</span> <span class="o">*</span><span class="n">HeaderMap</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="k">const</span> <span class="n">FileEntry</span> <span class="o">*</span><span class="n">FE</span><span class="p">,</span> <span class="n">FileManager</span> <span class="o">&amp;</span><span class="n">FM</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// If the file is too small to be a header map, ignore it.</span>
    <span class="kt">unsigned</span> <span class="n">FileSize</span> <span class="o">=</span> <span class="n">FE</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FileSize</span> <span class="o">&lt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">HMapHeader</span><span class="p">))</span> <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="k">auto</span> <span class="n">FileBuffer</span> <span class="o">=</span> <span class="n">FM</span><span class="p">.</span><span class="n">getBufferForFile</span><span class="p">(</span><span class="n">FE</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FileBuffer</span><span class="p">)</span> <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>  <span class="c1">// Unreadable file?</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">FileStart</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">FileBuffer</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getBufferStart</span><span class="p">();</span>

    <span class="c1">// We know the file is at least as big as the header, check it now.</span>
    <span class="k">const</span> <span class="n">HMapHeader</span> <span class="o">*</span><span class="n">Header</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">HMapHeader</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">FileStart</span><span class="p">);</span>

    <span class="c1">// Sniff it to see if it&#39;s a headermap by checking the magic number and</span>
    <span class="c1">// version.</span>
    <span class="kt">bool</span> <span class="n">NeedsByteSwap</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Header</span><span class="o">-&gt;</span><span class="n">Magic</span> <span class="o">==</span> <span class="n">HMAP_HeaderMagicNumber</span> <span class="o">&amp;&amp;</span>
        <span class="n">Header</span><span class="o">-&gt;</span><span class="n">Version</span> <span class="o">==</span> <span class="n">HMAP_HeaderVersion</span><span class="p">)</span>
        <span class="n">NeedsByteSwap</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Header</span><span class="o">-&gt;</span><span class="n">Magic</span> <span class="o">==</span> <span class="n">llvm</span><span class="o">::</span><span class="n">ByteSwap_32</span><span class="p">(</span><span class="n">HMAP_HeaderMagicNumber</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="n">Header</span><span class="o">-&gt;</span><span class="n">Version</span> <span class="o">==</span> <span class="n">llvm</span><span class="o">::</span><span class="n">ByteSwap_16</span><span class="p">(</span><span class="n">HMAP_HeaderVersion</span><span class="p">))</span>
        <span class="n">NeedsByteSwap</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>  <span class="c1">// Mixed endianness headermap.</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>  <span class="c1">// Not a header map.</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Header</span><span class="o">-&gt;</span><span class="n">Reserved</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="c1">// Okay, everything looks good, create the header map.</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">HeaderMap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">FileBuffer</span><span class="p">),</span> <span class="n">NeedsByteSwap</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>在这个<code>HeaderMap</code>中存储的是一个<code>HashMap</code>，这个哈希表中基本单位为<code>HMapBucket</code>，其结构定义如下。</p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">HMapBucket</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">Key</span><span class="p">;</span>          <span class="c1">// Offset (into strings) of key.</span>

    <span class="kt">uint32_t</span> <span class="n">Prefix</span><span class="p">;</span>     <span class="c1">// Offset (into strings) of value prefix.</span>
    <span class="kt">uint32_t</span> <span class="n">Suffix</span><span class="p">;</span>     <span class="c1">// Offset (into strings) of value suffix.</span>
<span class="p">};</span>
</pre></div>


<p>此时基本单元的获取函数如下，很简单，就是首先获取哈希表的偏移，然后加上索引偏移，判断是否越界：</p>
<div class="codehilite"><pre><span class="c1">/// getBucket - Return the specified hash table bucket from the header map,</span>
<span class="c1">/// bswap&#39;ing its fields as appropriate.  If the bucket number is not valid,</span>
<span class="c1">/// this return a bucket with an empty key (0).</span>
<span class="n">HMapBucket</span> <span class="n">HeaderMap</span><span class="o">::</span><span class="n">getBucket</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">BucketNo</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">HMapBucket</span> <span class="n">Result</span><span class="p">;</span>
    <span class="n">Result</span><span class="p">.</span><span class="n">Key</span> <span class="o">=</span> <span class="n">HMAP_EmptyBucketKey</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">HMapBucket</span> <span class="o">*</span><span class="n">BucketArray</span> <span class="o">=</span>
        <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">HMapBucket</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">FileBuffer</span><span class="o">-&gt;</span><span class="n">getBufferStart</span><span class="p">()</span> <span class="o">+</span>
            <span class="k">sizeof</span><span class="p">(</span><span class="n">HMapHeader</span><span class="p">));</span>

    <span class="k">const</span> <span class="n">HMapBucket</span> <span class="o">*</span><span class="n">BucketPtr</span> <span class="o">=</span> <span class="n">BucketArray</span> <span class="o">+</span> <span class="n">BucketNo</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="n">BucketPtr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">FileBuffer</span><span class="o">-&gt;</span><span class="n">getBufferEnd</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">Result</span><span class="p">.</span><span class="n">Prefix</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">Result</span><span class="p">.</span><span class="n">Suffix</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>  <span class="c1">// Invalid buffer, corrupt hmap.</span>
    <span class="p">}</span>

    <span class="c1">// Otherwise, the bucket is valid.  Load the values, bswapping as needed.</span>
    <span class="n">Result</span><span class="p">.</span><span class="n">Key</span> <span class="o">=</span> <span class="n">getEndianAdjustedWord</span><span class="p">(</span><span class="n">BucketPtr</span><span class="o">-&gt;</span><span class="n">Key</span><span class="p">);</span>
    <span class="n">Result</span><span class="p">.</span><span class="n">Prefix</span> <span class="o">=</span> <span class="n">getEndianAdjustedWord</span><span class="p">(</span><span class="n">BucketPtr</span><span class="o">-&gt;</span><span class="n">Prefix</span><span class="p">);</span>
    <span class="n">Result</span><span class="p">.</span><span class="n">Suffix</span> <span class="o">=</span> <span class="n">getEndianAdjustedWord</span><span class="p">(</span><span class="n">BucketPtr</span><span class="o">-&gt;</span><span class="n">Suffix</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>整个<code>HeaderMap</code>相当于把头文件目录中的子文件名都存储于内存之中，这样每次查询头文件位置的时候就没有比较去访问文件系统了。在<code>HeaderMap</code>中查找一个文件名是否存在可以这样实现，就是一个简单的<code>hash</code>查询。：</p>
<div class="codehilite"><pre><span class="n">StringRef</span> <span class="n">HeaderMap</span><span class="o">::</span><span class="n">lookupFilename</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Filename</span><span class="p">,</span>
    <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">DestPath</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">HMapHeader</span> <span class="o">&amp;</span><span class="n">Hdr</span> <span class="o">=</span> <span class="n">getHeader</span><span class="p">();</span>
    <span class="kt">unsigned</span> <span class="n">NumBuckets</span> <span class="o">=</span> <span class="n">getEndianAdjustedWord</span><span class="p">(</span><span class="n">Hdr</span><span class="p">.</span><span class="n">NumBuckets</span><span class="p">);</span>

    <span class="c1">// If the number of buckets is not a power of two, the headermap is corrupt.</span>
    <span class="c1">// Don&#39;t probe infinitely.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">NumBuckets</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">NumBuckets</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">StringRef</span><span class="p">();</span>

    <span class="c1">// Linearly probe the hash table.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">Bucket</span> <span class="o">=</span> <span class="n">HashHMapKey</span><span class="p">(</span><span class="n">Filename</span><span class="p">);;</span> <span class="o">++</span><span class="n">Bucket</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">HMapBucket</span> <span class="n">B</span> <span class="o">=</span> <span class="n">getBucket</span><span class="p">(</span><span class="n">Bucket</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">NumBuckets</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">Key</span> <span class="o">==</span> <span class="n">HMAP_EmptyBucketKey</span><span class="p">)</span> <span class="k">return</span> <span class="n">StringRef</span><span class="p">();</span> <span class="c1">// Hash miss.</span>

        <span class="c1">// See if the key matches.  If not, probe on.</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Filename</span><span class="p">.</span><span class="n">equals_lower</span><span class="p">(</span><span class="n">getString</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">Key</span><span class="p">)))</span>
            <span class="k">continue</span><span class="p">;</span>

        <span class="c1">// If so, we have a match in the hash table.  Construct the destination</span>
        <span class="c1">// path.</span>
        <span class="n">StringRef</span> <span class="n">Prefix</span> <span class="o">=</span> <span class="n">getString</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">Prefix</span><span class="p">);</span>
        <span class="n">StringRef</span> <span class="n">Suffix</span> <span class="o">=</span> <span class="n">getString</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">Suffix</span><span class="p">);</span>
        <span class="n">DestPath</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="n">DestPath</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Prefix</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">Prefix</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        <span class="n">DestPath</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Suffix</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">Suffix</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        <span class="k">return</span> <span class="nf">StringRef</span><span class="p">(</span><span class="n">DestPath</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">DestPath</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h1 id="82fdcc">头文件定位</h1>
<p>头文件定位相关操作在<code>HeaderSearch.h</code>中被描述，里面有一个比较大的类<code>HeaderSearch</code>。一部分一部分的分析吧。</p>
<p>首先是头文件信息相关的结构<code>HeaderFileInfo</code>，里面基本都是一些标志位：</p>
<div class="codehilite"><pre><span class="k">struct</span> <span class="n">HeaderFileInfo</span>
<span class="p">{</span>
    <span class="c1">/// \brief True if this is a #import&#39;d or #pragma once file.</span>
    <span class="kt">unsigned</span> <span class="nl">isImport</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">/// \brief True if this is a #pragma once file.</span>
    <span class="kt">unsigned</span> <span class="nl">isPragmaOnce</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">/// DirInfo - Keep track of whether this is a system header, and if so,</span>
    <span class="c1">/// whether it is C++ clean or not.  This can be set by the include paths or</span>
    <span class="c1">/// by #pragma gcc system_header.  This is an instance of</span>
    <span class="c1">/// SrcMgr::CharacteristicKind.</span>
    <span class="kt">unsigned</span> <span class="nl">DirInfo</span> <span class="p">:</span> <span class="mi">2</span><span class="p">;</span>

    <span class="c1">/// \brief Whether this header file info was supplied by an external source,</span>
    <span class="c1">/// and has not changed since.</span>
    <span class="kt">unsigned</span> <span class="nl">External</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">/// \brief Whether this header is part of a module.</span>
    <span class="kt">unsigned</span> <span class="nl">isModuleHeader</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">/// \brief Whether this header is part of the module that we are building.</span>
    <span class="kt">unsigned</span> <span class="nl">isCompilingModuleHeader</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">/// \brief Whether this structure is considered to already have been</span>
    <span class="c1">/// &quot;resolved&quot;, meaning that it was loaded from the external source.</span>
    <span class="kt">unsigned</span> <span class="nl">Resolved</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">/// \brief Whether this is a header inside a framework that is currently</span>
    <span class="c1">/// being built. </span>
    <span class="c1">///</span>
    <span class="c1">/// When a framework is being built, the headers have not yet been placed</span>
    <span class="c1">/// into the appropriate framework subdirectories, and therefore are</span>
    <span class="c1">/// provided via a header map. This bit indicates when this is one of</span>
    <span class="c1">/// those framework headers.</span>
    <span class="kt">unsigned</span> <span class="nl">IndexHeaderMapHeader</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">/// \brief Whether this file has been looked up as a header.</span>
    <span class="kt">unsigned</span> <span class="nl">IsValid</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">/// \brief The number of times the file has been included already.</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">NumIncludes</span><span class="p">;</span>

    <span class="c1">/// \brief The ID number of the controlling macro.</span>
    <span class="c1">///</span>
    <span class="c1">/// This ID number will be non-zero when there is a controlling</span>
    <span class="c1">/// macro whose IdentifierInfo may not yet have been loaded from</span>
    <span class="c1">/// external storage.</span>
    <span class="kt">unsigned</span> <span class="n">ControllingMacroID</span><span class="p">;</span>

    <span class="c1">/// If this file has a #ifndef XXX (or equivalent) guard that</span>
    <span class="c1">/// protects the entire contents of the file, this is the identifier</span>
    <span class="c1">/// for the macro that controls whether or not it has any effect.</span>
    <span class="c1">///</span>
    <span class="c1">/// Note: Most clients should use getControllingMacro() to access</span>
    <span class="c1">/// the controlling macro of this header, since</span>
    <span class="c1">/// getControllingMacro() is able to load a controlling macro from</span>
    <span class="c1">/// external storage.</span>
    <span class="k">const</span> <span class="n">IdentifierInfo</span> <span class="o">*</span><span class="n">ControllingMacro</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>比较特殊的就是<code>ControllingMacro</code>，也就是常说的<code>Header Guard</code>。</p>
<p>该文件剩下的内容就是<code>HeaderSearch</code>相关的内容了，里面有很多我们并不需要的字段，因此只看重点：</p>
<div class="codehilite"><pre><span class="c1">/// #include search path information.  Requests for #include &quot;x&quot; search the</span>
<span class="c1">/// directory of the #including file first, then each directory in SearchDirs</span>
<span class="c1">/// consecutively. Requests for &lt;x&gt; search the current dir first, then each</span>
<span class="c1">/// directory in SearchDirs, starting at AngledDirIdx, consecutively.  If</span>
<span class="c1">/// NoCurDirSearch is true, then the check for the file in the current</span>
<span class="c1">/// directory is suppressed.</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">DirectoryLookup</span><span class="o">&gt;</span> <span class="n">SearchDirs</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="n">AngledDirIdx</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="n">SystemDirIdx</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">NoCurDirSearch</span><span class="p">;</span>
</pre></div>


<p>注释里面把搜索逻辑已经描述清楚了，所有的头文件路径存储于<code>SearchDirs</code>，<code>AngledDir</code>相当于系统头文件路径的开始索引。</p>
<p>其他比较重要的东西就是所有的头文件信息和头文件与<code>FileEntry</code>的映射：</p>
<div class="codehilite"><pre><span class="c1">/// \brief All of the preprocessor-specific data about files that are</span>
<span class="c1">/// included, indexed by the FileEntry&#39;s UID.</span>
<span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">HeaderFileInfo</span><span class="o">&gt;</span> <span class="n">FileInfo</span><span class="p">;</span>
<span class="c1">/// HeaderMaps - This is a mapping from FileEntry -&gt; HeaderMap, uniquing</span>
<span class="c1">/// headermaps.  This vector owns the headermap.</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">FileEntry</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">HeaderMap</span><span class="o">*&gt;</span> <span class="o">&gt;</span> <span class="n">HeaderMaps</span><span class="p">;</span>
</pre></div>


<p>剩下的都是<code>Module</code>和<code>Framework</code>以及<code>Statistic</code>相关的内容，不是核心问题，故略去。</p>
<p>真正的核心问题是查询函数：</p>
<div class="codehilite"><pre>        <span class="k">const</span> <span class="n">FileEntry</span> <span class="o">*</span><span class="nf">LookupFile</span><span class="p">(</span>
            <span class="n">StringRef</span> <span class="n">Filename</span><span class="p">,</span> <span class="n">SourceLocation</span> <span class="n">IncludeLoc</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isAngled</span><span class="p">,</span>
            <span class="k">const</span> <span class="n">DirectoryLookup</span> <span class="o">*</span><span class="n">FromDir</span><span class="p">,</span> <span class="k">const</span> <span class="n">DirectoryLookup</span> <span class="o">*&amp;</span><span class="n">CurDir</span><span class="p">,</span>
            <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">FileEntry</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">DirectoryEntry</span> <span class="o">*&gt;&gt;</span> <span class="n">Includers</span><span class="p">,</span>
            <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">SearchPath</span><span class="p">,</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">RelativePath</span><span class="p">,</span>
            <span class="n">Module</span> <span class="o">*</span><span class="n">RequestingModule</span><span class="p">,</span> <span class="n">ModuleMap</span><span class="o">::</span><span class="n">KnownHeader</span> <span class="o">*</span><span class="n">SuggestedModule</span><span class="p">,</span>
            <span class="kt">bool</span> <span class="n">SkipCache</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</pre></div>


<p>这个函数相关的说明也是非常的长，大概有300多行实现代码。首先是判断文件路径是不是绝对路径，如果是绝对路径则直接判断该路径是否存在：</p>
<div class="codehilite"><pre><span class="k">if</span> <span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">sys</span><span class="o">::</span><span class="n">path</span><span class="o">::</span><span class="n">is_absolute</span><span class="p">(</span><span class="n">Filename</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">CurDir</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="c1">// If this was an #include_next &quot;/absolute/file&quot;, fail.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FromDir</span><span class="p">)</span> <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">SearchPath</span><span class="p">)</span>
        <span class="n">SearchPath</span><span class="o">-&gt;</span><span class="n">clear</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">RelativePath</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">RelativePath</span><span class="o">-&gt;</span><span class="n">clear</span><span class="p">();</span>
        <span class="n">RelativePath</span><span class="o">-&gt;</span><span class="n">append</span><span class="p">(</span><span class="n">Filename</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">Filename</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="c1">// Otherwise, just return the file.</span>
    <span class="k">return</span> <span class="n">getFileAndSuggestModule</span><span class="p">(</span><span class="n">Filename</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span>
        <span class="cm">/*IsSystemHeaderDir*/</span><span class="nb">false</span><span class="p">,</span>
        <span class="n">RequestingModule</span><span class="p">,</span> <span class="n">SuggestedModule</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>如果是相对路径，则需要区分是否是尖括号头文件还是双引号头文件。如果是双引号头文件，则需要在所有头文件的路径中递归子文件夹来查找，而尖括号头文件则不需要在子文件夹中递归查找。</p>
<p>如果是尖括号头文件搜索，则还需要考虑微软的<code>include_next</code>扩展，具体的执行流程我们就不去深究了。</p>
<p>对于<code>Framework</code>和<code>Module</code>的支持当前我就先不考虑，目前不感兴趣。</p>
<h1 id="b9e535">预处理器</h1>
<h2 id="5e6b8d">PreprocessorLexer.h</h2>
<p>目前还不怎么了解这个类是干什么的？感觉只是用来处理头文件引入和条件编译选项的。其数据成员如下：</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">PreprocessorLexer</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">anchor</span><span class="p">();</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">Preprocessor</span> <span class="o">*</span><span class="n">PP</span><span class="p">;</span>              <span class="c1">// Preprocessor object controlling lexing.</span>

    <span class="c1">/// The SourceManager FileID corresponding to the file being lexed.</span>
    <span class="k">const</span> <span class="n">FileID</span> <span class="n">FID</span><span class="p">;</span>

    <span class="c1">/// \brief Number of SLocEntries before lexing the file.</span>
    <span class="kt">unsigned</span> <span class="n">InitialNumSLocEntries</span><span class="p">;</span>

    <span class="c1">//===--------------------------------------------------------------------===//</span>
    <span class="c1">// Context-specific lexing flags set by the preprocessor.</span>
    <span class="c1">//===--------------------------------------------------------------------===//</span>

    <span class="c1">/// \brief True when parsing #XXX; turns &#39;\\n&#39; into a tok::eod token.</span>
    <span class="kt">bool</span> <span class="n">ParsingPreprocessorDirective</span><span class="p">;</span>

    <span class="c1">/// \brief True after #include; turns \&lt;xx&gt; into a tok::angle_string_literal</span>
    <span class="c1">/// token.</span>
    <span class="kt">bool</span> <span class="n">ParsingFilename</span><span class="p">;</span>

    <span class="c1">/// \brief True if in raw mode.</span>
    <span class="c1">///</span>
    <span class="c1">/// Raw mode disables interpretation of tokens and is a far faster mode to</span>
    <span class="c1">/// lex in than non-raw-mode.  This flag:</span>
    <span class="c1">///  1. If EOF of the current lexer is found, the include stack isn&#39;t popped.</span>
    <span class="c1">///  2. Identifier information is not looked up for identifier tokens.  As an</span>
    <span class="c1">///     effect of this, implicit macro expansion is naturally disabled.</span>
    <span class="c1">///  3. &quot;#&quot; tokens at the start of a line are treated as normal tokens, not</span>
    <span class="c1">///     implicitly transformed by the lexer.</span>
    <span class="c1">///  4. All diagnostic messages are disabled.</span>
    <span class="c1">///  5. No callbacks are made into the preprocessor.</span>
    <span class="c1">///</span>
    <span class="c1">/// Note that in raw mode that the PP pointer may be null.</span>
    <span class="kt">bool</span> <span class="n">LexingRawMode</span><span class="p">;</span>

    <span class="c1">/// \brief A state machine that detects the #ifndef-wrapping a file</span>
    <span class="c1">/// idiom for the multiple-include optimization.</span>
    <span class="n">MultipleIncludeOpt</span> <span class="n">MIOpt</span><span class="p">;</span>

    <span class="c1">/// \brief Information about the set of #if/#ifdef/#ifndef blocks</span>
    <span class="c1">/// we are currently in.</span>
    <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">PPConditionalInfo</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">ConditionalStack</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>前两个<code>bool</code>组成一个状态机，配合<code>MIOpt</code>专门用来<code>parse</code>头文件引入。而<code>ConditionalStack</code>专门用来处理条件编译。这里的条件编译需要利用<code>Token.h</code>中定义的<code>PPConditionalInfo</code>，这是一个<code>POD</code>：</p>
<div class="codehilite"><pre><span class="c1">/// \brief Information about the conditional stack (#if directives)</span>
<span class="c1">/// currently active.</span>
<span class="k">struct</span> <span class="n">PPConditionalInfo</span>
<span class="p">{</span>
    <span class="c1">/// \brief Location where the conditional started.</span>
    <span class="n">SourceLocation</span> <span class="n">IfLoc</span><span class="p">;</span>

    <span class="c1">/// \brief True if this was contained in a skipping directive, e.g.,</span>
    <span class="c1">/// in a &quot;#if 0&quot; block.</span>
    <span class="kt">bool</span> <span class="n">WasSkipping</span><span class="p">;</span>

    <span class="c1">/// \brief True if we have emitted tokens already, and now we&#39;re in</span>
    <span class="c1">/// an #else block or something.  Only useful in Skipping blocks.</span>
    <span class="kt">bool</span> <span class="n">FoundNonSkip</span><span class="p">;</span>

    <span class="c1">/// \brief True if we&#39;ve seen a #else in this block.  If so,</span>
    <span class="c1">/// #elif/#else directives are not allowed.</span>
    <span class="kt">bool</span> <span class="n">FoundElse</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>这个结构就是专门记录<code>#if #else</code>之类的条件编译的。所以在处理条件编译时，我们通过这样的来压栈：</p>
<div class="codehilite"><pre><span class="c1">/// pushConditionalLevel - When we enter a #if directive, this keeps track of</span>
<span class="c1">/// what we are currently in for diagnostic emission (e.g. #if with missing</span>
<span class="c1">/// #endif).</span>
<span class="kt">void</span> <span class="nf">pushConditionalLevel</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">DirectiveStart</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">WasSkipping</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">FoundNonSkip</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">FoundElse</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PPConditionalInfo</span> <span class="n">CI</span><span class="p">;</span>
    <span class="n">CI</span><span class="p">.</span><span class="n">IfLoc</span> <span class="o">=</span> <span class="n">DirectiveStart</span><span class="p">;</span>
    <span class="n">CI</span><span class="p">.</span><span class="n">WasSkipping</span> <span class="o">=</span> <span class="n">WasSkipping</span><span class="p">;</span>
    <span class="n">CI</span><span class="p">.</span><span class="n">FoundNonSkip</span> <span class="o">=</span> <span class="n">FoundNonSkip</span><span class="p">;</span>
    <span class="n">CI</span><span class="p">.</span><span class="n">FoundElse</span> <span class="o">=</span> <span class="n">FoundElse</span><span class="p">;</span>
    <span class="n">ConditionalStack</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">CI</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>对应的出栈操作如下：</p>
<div class="codehilite"><pre><span class="c1">/// popConditionalLevel - Remove an entry off the top of the conditional</span>
<span class="c1">/// stack, returning information about it.  If the conditional stack is empty,</span>
<span class="c1">/// this returns true and does not fill in the arguments.</span>
<span class="kt">bool</span> <span class="nf">popConditionalLevel</span><span class="p">(</span><span class="n">PPConditionalInfo</span> <span class="o">&amp;</span><span class="n">CI</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ConditionalStack</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">CI</span> <span class="o">=</span> <span class="n">ConditionalStack</span><span class="p">.</span><span class="n">pop_back_val</span><span class="p">();</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>除了这几个宏相关的操作之外，<code>PreprocessorLexer</code>里面还定义了一些虚接口函数：</p>
<div class="codehilite"><pre><span class="k">virtual</span> <span class="kt">void</span> <span class="n">IndirectLex</span><span class="p">(</span><span class="n">Token</span><span class="o">&amp;</span> <span class="n">Result</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">/// \brief Return the source location for the next observable location.</span>
<span class="k">virtual</span> <span class="n">SourceLocation</span> <span class="n">getSourceLocation</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>


<p>这几个虚接口函数都需要在继承类中实现，特别是这里的<code>IndirectLex</code>，在具体实现的时候都会作为转接函数来调用对应类型的<code>Lex</code>函数，后面我们会涉及到。</p>
<h2 id="fd1ea3">PTHLexer</h2>
<p>这个文件是用来处理<code>Pre Tokenized input</code>的，虽然我现在还不知道这是什么意思！最重要的是，这个类继承自<code>PreprocessorLexer</code>:</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">PTHLexer</span> <span class="o">:</span> <span class="k">public</span> <span class="n">PreprocessorLexer</span>
<span class="p">{</span>
    <span class="n">SourceLocation</span> <span class="n">FileStartLoc</span><span class="p">;</span>

    <span class="c1">/// TokBuf - Buffer from PTH file containing raw token data.</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">TokBuf</span><span class="p">;</span>

    <span class="c1">/// CurPtr - Pointer into current offset of the token buffer where</span>
    <span class="c1">///  the next token will be read.</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">CurPtr</span><span class="p">;</span>

    <span class="c1">/// LastHashTokPtr - Pointer into TokBuf of the last processed &#39;#&#39;</span>
    <span class="c1">///  token that appears at the start of a line.</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">LastHashTokPtr</span><span class="p">;</span>

    <span class="c1">/// PPCond - Pointer to a side table in the PTH file that provides a</span>
    <span class="c1">///  a consise summary of the preproccessor conditional block structure.</span>
    <span class="c1">///  This is used to perform quick skipping of conditional blocks.</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">PPCond</span><span class="p">;</span>

    <span class="c1">/// CurPPCondPtr - Pointer inside PPCond that refers to the next entry</span>
    <span class="c1">///  to process when doing quick skipping of preprocessor blocks.</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">CurPPCondPtr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这个类是用来处理<code>Pretokenized Header</code>的，这个文件格式是<code>llvm</code>自己设计的。所以我这也不想说太多只对<code>PTH</code>有效的功能，毕竟不是标准里面的东西。</p>
<p>当前头文件的实现文件约有900行，挑重点的几个函数说一下。以难易程度来说，最简单的是<code>LexEndOfFile</code>：</p>
<div class="codehilite"><pre><span class="kt">bool</span> <span class="n">PTHLexer</span><span class="o">::</span><span class="n">LexEndOfFile</span><span class="p">(</span><span class="n">Token</span> <span class="o">&amp;</span><span class="n">Result</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// If we hit the end of the file while parsing a preprocessor directive,</span>
    <span class="c1">// end the preprocessor directive first.  The next token returned will</span>
    <span class="c1">// then be the end of file.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ParsingPreprocessorDirective</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ParsingPreprocessorDirective</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Done parsing the &quot;line&quot;.</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>  <span class="c1">// Have a token.</span>
    <span class="p">}</span>

    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">LexingRawMode</span><span class="p">);</span>

    <span class="c1">// If we are in a #if directive, emit an error.</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ConditionalStack</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">PP</span><span class="o">-&gt;</span><span class="n">getCodeCompletionFileLoc</span><span class="p">()</span> <span class="o">!=</span> <span class="n">FileStartLoc</span><span class="p">)</span>
            <span class="n">PP</span><span class="o">-&gt;</span><span class="n">Diag</span><span class="p">(</span><span class="n">ConditionalStack</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">IfLoc</span><span class="p">,</span>
                <span class="n">diag</span><span class="o">::</span><span class="n">err_pp_unterminated_conditional</span><span class="p">);</span>
        <span class="n">ConditionalStack</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// Finally, let the preprocessor handle this.</span>
    <span class="k">return</span> <span class="n">PP</span><span class="o">-&gt;</span><span class="n">HandleEndOfFile</span><span class="p">(</span><span class="n">Result</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>这个函数处理的是：如果我们走到了一个文件的末尾怎么处理的问题。返回值用来表示我们是否应该继续调用<code>Lex</code>函数来获得下一个<code>Token</code>。如果在处理预处理导言（<code>#line</code>）时到了文件末尾，直接返回真。如果当前的条件编译栈中还有<code>#if</code>，向错误诊断中报告相应信息，并持续弹出。然后我们让预处理器来处理<code>EOF</code>问题，其签名如下：</p>
<div class="codehilite"><pre><span class="c1">/// \brief Callback invoked when the lexer hits the end of the current file.</span>
<span class="c1">///</span>
<span class="c1">/// This either returns the EOF token and returns true, or</span>
<span class="c1">/// pops a level off the include stack and returns false, at which point the</span>
<span class="c1">/// client should call lex again.</span>
<span class="kt">bool</span> <span class="nf">HandleEndOfFile</span><span class="p">(</span><span class="n">Token</span> <span class="o">&amp;</span><span class="n">Result</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isEndOfMacro</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</pre></div>


<p>这个函数的大意就是进行头文件栈的弹栈，处理过程中我们还可以插入自定义的<code>call_back</code>。</p>
<p>处理了这种例外行为之后我们来处理普通的<code>PTH.Lex</code>操作，该操作分为多步，第一步是从<code>PTH</code>中获得一个<code>Token</code>的相关信息：</p>
<div class="codehilite"><pre><span class="c1">//===--------------------------------------==//</span>
<span class="c1">// Read the raw token data.</span>
<span class="c1">//===--------------------------------------==//</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="p">;</span>

<span class="c1">// Shadow CurPtr into an automatic variable.</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">CurPtrShadow</span> <span class="o">=</span> <span class="n">CurPtr</span><span class="p">;</span>

<span class="c1">// Read in the data for the token.</span>
<span class="kt">unsigned</span> <span class="n">Word0</span> <span class="o">=</span> <span class="n">endian</span><span class="o">::</span><span class="n">readNext</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">little</span><span class="p">,</span> <span class="n">aligned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">CurPtrShadow</span><span class="p">);</span>
<span class="kt">uint32_t</span> <span class="n">IdentifierID</span> <span class="o">=</span>
    <span class="n">endian</span><span class="o">::</span><span class="n">readNext</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">little</span><span class="p">,</span> <span class="n">aligned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">CurPtrShadow</span><span class="p">);</span>
<span class="kt">uint32_t</span> <span class="n">FileOffset</span> <span class="o">=</span>
    <span class="n">endian</span><span class="o">::</span><span class="n">readNext</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">little</span><span class="p">,</span> <span class="n">aligned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">CurPtrShadow</span><span class="p">);</span>

<span class="n">tok</span><span class="o">::</span><span class="n">TokenKind</span> <span class="n">TKind</span> <span class="o">=</span> <span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">TokenKind</span><span class="p">)</span> <span class="p">(</span><span class="n">Word0</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
<span class="n">Token</span><span class="o">::</span><span class="n">TokenFlags</span> <span class="n">TFlags</span> <span class="o">=</span> <span class="p">(</span><span class="n">Token</span><span class="o">::</span><span class="n">TokenFlags</span><span class="p">)</span> <span class="p">((</span><span class="n">Word0</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
<span class="kt">uint32_t</span> <span class="n">Len</span> <span class="o">=</span> <span class="n">Word0</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>

<span class="n">CurPtr</span> <span class="o">=</span> <span class="n">CurPtrShadow</span><span class="p">;</span>
</pre></div>


<p>这里的代码展示了<code>PTH</code>文件的具体实现，三个<code>uint32_t</code>存储了<code>Token</code>的基本信息。剩下的就是根据这些信息构造<code>Token</code>:</p>
<div class="codehilite"><pre><span class="c1">//===--------------------------------------==//</span>
<span class="c1">// Construct the token itself.</span>
<span class="c1">//===--------------------------------------==//</span>

<span class="n">Tok</span><span class="p">.</span><span class="n">startToken</span><span class="p">();</span>
<span class="n">Tok</span><span class="p">.</span><span class="n">setKind</span><span class="p">(</span><span class="n">TKind</span><span class="p">);</span>
<span class="n">Tok</span><span class="p">.</span><span class="n">setFlag</span><span class="p">(</span><span class="n">TFlags</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">LexingRawMode</span><span class="p">);</span>
<span class="n">Tok</span><span class="p">.</span><span class="n">setLocation</span><span class="p">(</span><span class="n">FileStartLoc</span><span class="p">.</span><span class="n">getLocWithOffset</span><span class="p">(</span><span class="n">FileOffset</span><span class="p">));</span>
<span class="n">Tok</span><span class="p">.</span><span class="n">setLength</span><span class="p">(</span><span class="n">Len</span><span class="p">);</span>

<span class="c1">// Handle identifiers.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">isLiteral</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">Tok</span><span class="p">.</span><span class="n">setLiteralData</span><span class="p">((</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="n">PTHMgr</span><span class="p">.</span><span class="n">SpellingBase</span> <span class="o">+</span> <span class="n">IdentifierID</span><span class="p">));</span>
<span class="p">}</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IdentifierID</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">MIOpt</span><span class="p">.</span><span class="n">ReadToken</span><span class="p">();</span>
    <span class="n">IdentifierInfo</span> <span class="o">*</span><span class="n">II</span> <span class="o">=</span> <span class="n">PTHMgr</span><span class="p">.</span><span class="n">GetIdentifierInfo</span><span class="p">(</span><span class="n">IdentifierID</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

    <span class="n">Tok</span><span class="p">.</span><span class="n">setIdentifierInfo</span><span class="p">(</span><span class="n">II</span><span class="p">);</span>

    <span class="c1">// Change the kind of this identifier to the appropriate token kind, e.g.</span>
    <span class="c1">// turning &quot;for&quot; into a keyword.</span>
    <span class="n">Tok</span><span class="p">.</span><span class="n">setKind</span><span class="p">(</span><span class="n">II</span><span class="o">-&gt;</span><span class="n">getTokenID</span><span class="p">());</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">II</span><span class="o">-&gt;</span><span class="n">isHandleIdentifierCase</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">PP</span><span class="o">-&gt;</span><span class="n">HandleIdentifier</span><span class="p">(</span><span class="n">Tok</span><span class="p">);</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这个<code>Token</code>所对应的<code>IdentifierInfo</code>是由<code>PTHMgr</code>管理的。</p>
<p>在构造完这个<code>Token</code>之后，我们再进行进一步的处理，主要是处理特殊<code>TokenKind</code>：</p>
<div class="codehilite"><pre><span class="c1">//===--------------------------------------==//</span>
<span class="c1">// Process the token.</span>
<span class="c1">//===--------------------------------------==//</span>
<span class="k">if</span> <span class="p">(</span><span class="n">TKind</span> <span class="o">==</span> <span class="n">tok</span><span class="o">::</span><span class="n">eof</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Save the end-of-file token.</span>
    <span class="n">EofToken</span> <span class="o">=</span> <span class="n">Tok</span><span class="p">;</span>

    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">ParsingPreprocessorDirective</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">LexingRawMode</span><span class="p">);</span>

    <span class="k">return</span> <span class="nf">LexEndOfFile</span><span class="p">(</span><span class="n">Tok</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">TKind</span> <span class="o">==</span> <span class="n">tok</span><span class="o">::</span><span class="n">hash</span> <span class="o">&amp;&amp;</span> <span class="n">Tok</span><span class="p">.</span><span class="n">isAtStartOfLine</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">LastHashTokPtr</span> <span class="o">=</span> <span class="n">CurPtr</span> <span class="o">-</span> <span class="n">StoredTokenSize</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">LexingRawMode</span><span class="p">);</span>
    <span class="n">PP</span><span class="o">-&gt;</span><span class="n">HandleDirective</span><span class="p">(</span><span class="n">Tok</span><span class="p">);</span>

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">TKind</span> <span class="o">==</span> <span class="n">tok</span><span class="o">::</span><span class="n">eod</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">ParsingPreprocessorDirective</span><span class="p">);</span>
    <span class="n">ParsingPreprocessorDirective</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">MIOpt</span><span class="p">.</span><span class="n">ReadToken</span><span class="p">();</span>
<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</pre></div>


<p>这里的执行流程又调用了预处理器中的<code>HandleDirective</code>，这个是处理<code>#</code>开头的行的，其签名如下：</p>
<div class="codehilite"><pre><span class="c1">/// \brief Callback invoked when the lexer sees a # token at the start of a</span>
<span class="c1">/// line.</span>
<span class="c1">///</span>
<span class="c1">/// This consumes the directive, modifies the lexer/preprocessor state, and</span>
<span class="c1">/// advances the lexer(s) so that the next token read is the correct one.</span>
<span class="kt">void</span> <span class="nf">HandleDirective</span><span class="p">(</span><span class="n">Token</span> <span class="o">&amp;</span><span class="n">Result</span><span class="p">);</span>
</pre></div>


<p>在<code>PTHLexer.cpp</code>中还有一个比较重要的函数，来处理条件编译的跳过。该函数比较长，这里就不贴实现，只贴签名了。</p>
<div class="codehilite"><pre><span class="c1">/// SkipBlock - Used by Preprocessor to skip the current conditional block.</span>
<span class="kt">bool</span> <span class="n">PTHLexer</span><span class="o">::</span><span class="n">SkipBlock</span><span class="p">()</span>
</pre></div>


<h2 id="a7d57d">PTH 文件格式</h2>
<p>这个<code>PTH</code>文件还有一个功能就是建立<code>FileEntry</code>与<code>PTH offset</code>之间的映射，实际映射时使用的都是<code>uint32_t</code>，所以里面存储的信息也是这样的：</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">PTHFileData</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">TokenOff</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">PPCondOff</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>很简单，就两个索引字段，完整的信息需要配合文件管理器才能解释。读取文件的时候也非常简单：</p>
<div class="codehilite"><pre><span class="k">static</span> <span class="n">PTHFileData</span> <span class="nf">ReadData</span><span class="p">(</span><span class="k">const</span> <span class="n">internal_key_type</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">d</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">k</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="mh">0x1</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Only file lookups can match!&quot;</span><span class="p">);</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">x</span> <span class="o">=</span> <span class="n">endian</span><span class="o">::</span><span class="n">readNext</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">little</span><span class="p">,</span> <span class="n">unaligned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
    <span class="kt">uint32_t</span> <span class="n">y</span> <span class="o">=</span> <span class="n">endian</span><span class="o">::</span><span class="n">readNext</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">little</span><span class="p">,</span> <span class="n">unaligned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">PTHFileData</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h1 id="d5c82d">PTHManager</h1>
<p>这个<code>PTHManager</code>类似于之前的<code>SourceManager</code>，里面保留了大量的智能指针来管理相关的各种资源。同时提供由<code>String</code>到<code>IdentifierInfo</code>的映射接口，该接口继承自<code>IdentifierInfoLookup</code>类。<code>PTHManager</code>完整的数据成员见下：</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">PTHManager</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IdentifierInfoLookup</span>
<span class="p">{</span>

    <span class="k">class</span> <span class="nc">PTHStringLookupTrait</span><span class="p">;</span>
    <span class="k">class</span> <span class="nc">PTHFileLookupTrait</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">llvm</span><span class="o">::</span><span class="n">OnDiskChainedHashTable</span><span class="o">&lt;</span><span class="n">PTHStringLookupTrait</span><span class="o">&gt;</span> <span class="n">PTHStringIdLookup</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">llvm</span><span class="o">::</span><span class="n">OnDiskChainedHashTable</span><span class="o">&lt;</span><span class="n">PTHFileLookupTrait</span><span class="o">&gt;</span> <span class="n">PTHFileLookup</span><span class="p">;</span>

    <span class="c1">/// The memory mapped PTH file.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">llvm</span><span class="o">::</span><span class="n">MemoryBuffer</span><span class="o">&gt;</span> <span class="n">Buf</span><span class="p">;</span>

    <span class="c1">/// Alloc - Allocator used for IdentifierInfo objects.</span>
    <span class="n">llvm</span><span class="o">::</span><span class="n">BumpPtrAllocator</span> <span class="n">Alloc</span><span class="p">;</span>

    <span class="c1">/// IdMap - A lazily generated cache mapping from persistent identifiers to</span>
    <span class="c1">///  IdentifierInfo*.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IdentifierInfo</span> <span class="o">*</span><span class="p">[],</span> <span class="n">llvm</span><span class="o">::</span><span class="n">FreeDeleter</span><span class="o">&gt;</span> <span class="n">PerIDCache</span><span class="p">;</span>

    <span class="c1">/// FileLookup - Abstract data structure used for mapping between files</span>
    <span class="c1">///  and token data in the PTH file.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">PTHFileLookup</span><span class="o">&gt;</span> <span class="n">FileLookup</span><span class="p">;</span>

    <span class="c1">/// IdDataTable - Array representing the mapping from persistent IDs to the</span>
    <span class="c1">///  data offset within the PTH file containing the information to</span>
    <span class="c1">///  reconsitute an IdentifierInfo.</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">IdDataTable</span><span class="p">;</span>

    <span class="c1">/// SortedIdTable - Abstract data structure mapping from strings to</span>
    <span class="c1">///  persistent IDs.  This is used by get().</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">PTHStringIdLookup</span><span class="o">&gt;</span> <span class="n">StringIdLookup</span><span class="p">;</span>

    <span class="c1">/// NumIds - The number of identifiers in the PTH file.</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">NumIds</span><span class="p">;</span>

    <span class="c1">/// PP - The Preprocessor object that will use this PTHManager to create</span>
    <span class="c1">///  PTHLexer objects.</span>
    <span class="n">Preprocessor</span><span class="o">*</span> <span class="n">PP</span><span class="p">;</span>

    <span class="c1">/// SpellingBase - The base offset within the PTH memory buffer that</span>
    <span class="c1">///  contains the cached spellings for literals.</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">SpellingBase</span><span class="p">;</span>

    <span class="c1">/// OriginalSourceFile - A null-terminated C-string that specifies the name</span>
    <span class="c1">///  if the file (if any) that was to used to generate the PTH cache.</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">OriginalSourceFile</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里有两个用来管理资源的智能指针：</p>
<ul>
<li>
<p><code>Buf</code>:保存了所有的<code>PTH</code>对应的<code>MemoryBuffer</code>;</p>
</li>
<li>
<p><code>PerIDCache</code>：一些<code>IdentifierInfo</code>的<code>cache</code>;</p>
</li>
</ul>
<p>这里还有两个用来维持抽象查询接口的智能指针：</p>
<ul>
<li>
<p><code>FileLookUp</code>：管理各个文件与<code>Token</code>之间的映射。</p>
</li>
<li>
<p><code>StringIdLookup</code>:管理<code>ID</code>与字符串之间的映射，虽然现在我还不知道这个<code>ID</code>是什么，看样子是<code>PTH</code>自己维护的一套<code>ID</code>。</p>
</li>
</ul>
<h2 id="91ad3f">对象构造</h2>
<p>这个很复杂的类的构造被封装在了一个非常复杂的函数里面：</p>
<div class="codehilite"><pre><span class="c1">/// Create - This method creates PTHManager objects.  The &#39;file&#39; argument</span>
    <span class="c1">///  is the name of the PTH file.  This method returns NULL upon failure.</span>
    <span class="k">static</span> <span class="n">PTHManager</span> <span class="o">*</span><span class="nf">Create</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">file</span><span class="p">,</span> <span class="n">DiagnosticsEngine</span> <span class="o">&amp;</span><span class="n">Diags</span><span class="p">);</span>
</pre></div>


<p>由于函数实现太长，这里就大概说一下步骤：</p>
<ul>
<li>
<p>首先根据传入的<code>File</code>参数读取<code>PTH</code>文件，这里有一些格式检查。</p>
</li>
<li>
<p>过了格式检查之后，读取开头的<code>ID-&gt;NameOffset</code>的映射表，构建<code>FileTable</code>、<code>IDTable</code>、<code>spellingBase</code>和<code>StringIdTable</code>，这几个表的<code>Offset</code>是连在一起的，具体的格式参见<code>OnDiskHashTable</code>中的说明。</p>
</li>
<li>
<p>计算原始文件的长度</p>
</li>
</ul>
<h2 id="fbe7e3">名字映射</h2>
<p>在<code>PTHManager</code>中主要包含四个功能，首先就是<code>get</code>函数，用来从标识符名得到标识符，其签名如下：</p>
<div class="codehilite"><pre><span class="c1">/// get - Return the identifier token info for the specified named identifier.</span>
<span class="c1">///  Unlike the version in IdentifierTable, this returns a pointer instead</span>
<span class="c1">///  of a reference.  If the pointer is NULL then the IdentifierInfo cannot</span>
<span class="c1">///  be found.</span>
<span class="n">IdentifierInfo</span> <span class="o">*</span><span class="n">get</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Name</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
</pre></div>


<p>其实这里实现的时候，是通过一个中间层来做两层映射的：<code>String-&gt;ID-&gt;IdentifierInfo</code>。</p>
<div class="codehilite"><pre><span class="c1">// Double check our assumption that the last character isn&#39;t &#39;\0&#39;.</span>
<span class="n">assert</span><span class="p">(</span><span class="n">Name</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">Name</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">);</span>
<span class="n">PTHStringIdLookup</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span> <span class="o">=</span>
    <span class="n">StringIdLookup</span><span class="o">-&gt;</span><span class="n">find</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">Name</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">Name</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>
<span class="k">if</span> <span class="p">(</span><span class="n">I</span> <span class="o">==</span> <span class="n">StringIdLookup</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span> <span class="c1">// No identifier found?</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

<span class="c1">// Match found.  Return the identifier!</span>
<span class="n">assert</span><span class="p">(</span><span class="o">*</span><span class="n">I</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">return</span> <span class="nf">GetIdentifierInfo</span><span class="p">(</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>


<p>这个<code>StringIDLookup</code>处理了第一层的映射，第二层的映射委托在了<code>GetIdentifierInfo</code>里面，其实现代码如下：</p>
<div class="codehilite"><pre><span class="c1">/// GetIdentifierInfo - Used to reconstruct IdentifierInfo objects from the</span>
<span class="c1">///  PTH file.</span>
<span class="kr">inline</span> <span class="n">IdentifierInfo</span><span class="o">*</span> <span class="nf">GetIdentifierInfo</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">PersistentID</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Check if the IdentifierInfo has already been resolved.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IdentifierInfo</span><span class="o">*</span> <span class="n">II</span> <span class="o">=</span> <span class="n">PerIDCache</span><span class="p">[</span><span class="n">PersistentID</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">II</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">LazilyCreateIdentifierInfo</span><span class="p">(</span><span class="n">PersistentID</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>这里又是一层调用，可以看出<code>PerIDCache</code>里面存储着<code>ID-&gt;IdentifierInfo</code>的映射，但是这个映射不一定已经装载进来了。为了装载我们还需要调用下面的函数：</p>
<div class="codehilite"><pre><span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="p">;</span>
<span class="c1">// Look in the PTH file for the string data for the IdentifierInfo object.</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">TableEntry</span> <span class="o">=</span> <span class="n">IdDataTable</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="o">*</span><span class="n">PersistentID</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">IDData</span> <span class="o">=</span>
    <span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">Buf</span><span class="o">-&gt;</span><span class="n">getBufferStart</span><span class="p">()</span> <span class="o">+</span>
    <span class="n">endian</span><span class="o">::</span><span class="n">readNext</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">little</span><span class="p">,</span> <span class="n">aligned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">TableEntry</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="n">IDData</span> <span class="o">&lt;</span> <span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">Buf</span><span class="o">-&gt;</span><span class="n">getBufferEnd</span><span class="p">());</span>

<span class="c1">// Allocate the object.</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">IdentifierInfo</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*&gt;</span> <span class="o">*</span><span class="n">Mem</span> <span class="o">=</span>
    <span class="n">Alloc</span><span class="p">.</span><span class="n">Allocate</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">IdentifierInfo</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*&gt;</span> <span class="o">&gt;</span><span class="p">();</span>

<span class="n">Mem</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">=</span> <span class="n">IDData</span><span class="p">;</span>
<span class="n">assert</span><span class="p">(</span><span class="n">IDData</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">);</span>
<span class="n">IdentifierInfo</span> <span class="o">*</span><span class="n">II</span> <span class="o">=</span> <span class="k">new</span> <span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">Mem</span><span class="p">)</span> <span class="n">IdentifierInfo</span><span class="p">();</span>

<span class="c1">// Store the new IdentifierInfo in the cache.</span>
<span class="n">PerIDCache</span><span class="p">[</span><span class="n">PersistentID</span><span class="p">]</span> <span class="o">=</span> <span class="n">II</span><span class="p">;</span>
<span class="n">assert</span><span class="p">(</span><span class="n">II</span><span class="o">-&gt;</span><span class="n">getNameStart</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">II</span><span class="o">-&gt;</span><span class="n">getNameStart</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">);</span>
<span class="k">return</span> <span class="n">II</span><span class="p">;</span>
</pre></div>


<p>这里的<code>IdDataTable</code>里面存的是每个<code>ID</code>对应的<code>String</code>在<code>MemoryBuffer</code>中的偏移值，然后分配相应的空间来构造<code>pair&lt;IdentifierInfo,char*</code>，并返回这个新构造的地址。总的来说，只是为了得到一个<code>IdentifierInfo</code>的坑，具体怎么填看后面的造化了。</p>
<h2 id="0bcaa4">CreateLexer</h2>
<p>这个函数的作用就是根据特定的<code>PTHFile</code>构造出对应的<code>Lexer</code>，过程很直白，不解释：</p>
<div class="codehilite"><pre><span class="n">PTHLexer</span> <span class="o">*</span><span class="n">PTHManager</span><span class="o">::</span><span class="n">CreateLexer</span><span class="p">(</span><span class="n">FileID</span> <span class="n">FID</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">FileEntry</span> <span class="o">*</span><span class="n">FE</span> <span class="o">=</span> <span class="n">PP</span><span class="o">-&gt;</span><span class="n">getSourceManager</span><span class="p">().</span><span class="n">getFileEntryForID</span><span class="p">(</span><span class="n">FID</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FE</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="p">;</span>

    <span class="c1">// Lookup the FileEntry object in our file lookup data structure.  It will</span>
    <span class="c1">// return a variant that indicates whether or not there is an offset within</span>
    <span class="c1">// the PTH file that contains cached tokens.</span>
    <span class="n">PTHFileLookup</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">FileLookup</span><span class="o">-&gt;</span><span class="n">find</span><span class="p">(</span><span class="n">FE</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">I</span> <span class="o">==</span> <span class="n">FileLookup</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span> <span class="c1">// No tokens available?</span>
        <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">PTHFileData</span><span class="o">&amp;</span> <span class="n">FileData</span> <span class="o">=</span> <span class="o">*</span><span class="n">I</span><span class="p">;</span>

    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">BufStart</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">Buf</span><span class="o">-&gt;</span><span class="n">getBufferStart</span><span class="p">();</span>
    <span class="c1">// Compute the offset of the token data within the buffer.</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">data</span> <span class="o">=</span> <span class="n">BufStart</span> <span class="o">+</span> <span class="n">FileData</span><span class="p">.</span><span class="n">getTokenOffset</span><span class="p">();</span>

    <span class="c1">// Get the location of pp-conditional table.</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">ppcond</span> <span class="o">=</span> <span class="n">BufStart</span> <span class="o">+</span> <span class="n">FileData</span><span class="p">.</span><span class="n">getPPCondOffset</span><span class="p">();</span>
    <span class="kt">uint32_t</span> <span class="n">Len</span> <span class="o">=</span> <span class="n">endian</span><span class="o">::</span><span class="n">readNext</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">little</span><span class="p">,</span> <span class="n">aligned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ppcond</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">ppcond</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="n">assert</span><span class="p">(</span><span class="n">PP</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;No preprocessor set yet!&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">PTHLexer</span><span class="p">(</span><span class="o">*</span><span class="n">PP</span><span class="p">,</span> <span class="n">FID</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">ppcond</span><span class="p">,</span> <span class="o">*</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h1 id="160158">TokenLexer</h1>
<p>这个类型是用来处理宏展开和<code>_Pragma</code>的，由于我们当前只关心常用的C语法，因此只介绍宏展开这部分。</p>
<p><code>TokenLexer</code>这个类相对来说不算复杂，主要的宏相关数据成员包括：</p>
<div class="codehilite"><pre><span class="c1">/// Macro - The macro we are expanding from.  This is null if expanding a</span>
<span class="c1">/// token stream.</span>
<span class="c1">///</span>
<span class="n">MacroInfo</span> <span class="o">*</span><span class="n">Macro</span><span class="p">;</span>

<span class="c1">/// ActualArgs - The actual arguments specified for a function-like macro, or</span>
<span class="c1">/// null.  The TokenLexer owns the pointed-to object.</span>
<span class="n">MacroArgs</span> <span class="o">*</span><span class="n">ActualArgs</span><span class="p">;</span>

<span class="c1">/// PP - The current preprocessor object we are expanding for.</span>
<span class="c1">///</span>
<span class="n">Preprocessor</span> <span class="o">&amp;</span><span class="n">PP</span><span class="p">;</span>

<span class="c1">/// Tokens - This is the pointer to an array of tokens that the macro is</span>
<span class="c1">/// defined to, with arguments expanded for function-like macros.  If this is</span>
<span class="c1">/// a token stream, these are the tokens we are returning.  This points into</span>
<span class="c1">/// the macro definition we are lexing from, a cache buffer that is owned by</span>
<span class="c1">/// the preprocessor, or some other buffer that we may or may not own</span>
<span class="c1">/// (depending on OwnsTokens).</span>
<span class="c1">/// Note that if it points into Preprocessor&#39;s cache buffer, the Preprocessor</span>
<span class="c1">/// may update the pointer as needed.</span>
<span class="k">const</span> <span class="n">Token</span> <span class="o">*</span><span class="n">Tokens</span><span class="p">;</span>
</pre></div>


<p>也就是宏名，相关实参和宏体。</p>
<p>主要的源代码位置相关成员包括：</p>
<div class="codehilite"><pre><span class="c1">/// NumTokens - This is the length of the Tokens array.</span>
<span class="c1">///</span>
<span class="kt">unsigned</span> <span class="n">NumTokens</span><span class="p">;</span>

<span class="c1">/// CurToken - This is the next token that Lex will return.</span>
<span class="c1">///</span>
<span class="kt">unsigned</span> <span class="n">CurToken</span><span class="p">;</span>

<span class="c1">/// ExpandLocStart/End - The source location range where this macro was</span>
<span class="c1">/// expanded.</span>
<span class="n">SourceLocation</span> <span class="n">ExpandLocStart</span><span class="p">,</span> <span class="n">ExpandLocEnd</span><span class="p">;</span>

<span class="c1">/// \brief Source location pointing at the source location entry chunk that</span>
<span class="c1">/// was reserved for the current macro expansion.</span>
<span class="n">SourceLocation</span> <span class="n">MacroExpansionStart</span><span class="p">;</span>

<span class="c1">/// \brief The offset of the macro expansion in the</span>
<span class="c1">/// &quot;source location address space&quot;.</span>
<span class="kt">unsigned</span> <span class="n">MacroStartSLocOffset</span><span class="p">;</span>

<span class="c1">/// \brief Location of the macro definition.</span>
<span class="n">SourceLocation</span> <span class="n">MacroDefStart</span><span class="p">;</span>
<span class="c1">/// \brief Length of the macro definition.</span>
<span class="kt">unsigned</span> <span class="n">MacroDefLength</span><span class="p">;</span>

<span class="c1">/// Lexical information about the expansion point of the macro: the identifier</span>
<span class="c1">/// that the macro expanded from had these properties.</span>
<span class="kt">bool</span> <span class="nl">AtStartOfLine</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">bool</span> <span class="nl">HasLeadingSpace</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// NextTokGetsSpace - When this is true, the next token appended to the</span>
<span class="c1">// output list during function argument expansion will get a leading space,</span>
<span class="c1">// regardless of whether it had one to begin with or not. This is used for</span>
<span class="c1">// placemarker support. If still true after function argument expansion, the</span>
<span class="c1">// leading space will be applied to the first token following the macro</span>
<span class="c1">// expansion.</span>
<span class="kt">bool</span> <span class="nl">NextTokGetsSpace</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">/// OwnsTokens - This is true if this TokenLexer allocated the Tokens</span>
<span class="c1">/// array, and thus needs to free it when destroyed.  For simple object-like</span>
<span class="c1">/// macros (for example) we just point into the token buffer of the macro</span>
<span class="c1">/// definition, we don&#39;t make a copy of it.</span>
<span class="kt">bool</span> <span class="nl">OwnsTokens</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">/// DisableMacroExpansion - This is true when tokens lexed from the TokenLexer</span>
<span class="c1">/// should not be subject to further macro expansion.</span>
<span class="kt">bool</span> <span class="nl">DisableMacroExpansion</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>


<p>这里的注释也算非常详尽，暂不解释。</p>
<h2 id="73e4e5">Function Expansion</h2>
<p>在<code>TokenLexer</code>中最重要的操作就是展开操作，该操作被封装在<code>ExpandFunctionArguments</code>函数中，该函数的签名很简单，无参数无返回值！但是该函数有250多行，比较复杂，分步剖析。</p>
<p>首先是基本存储变量：</p>
<div class="codehilite"><pre><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Token</span><span class="p">,</span> <span class="mi">128</span><span class="o">&gt;</span> <span class="n">ResultToks</span><span class="p">;</span>

<span class="c1">// Loop through &#39;Tokens&#39;, expanding them into ResultToks.  Keep</span>
<span class="c1">// track of whether we change anything.  If not, no need to keep them.  If so,</span>
<span class="c1">// we install the newly expanded sequence as the new &#39;Tokens&#39; list.</span>
<span class="kt">bool</span> <span class="n">MadeChange</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</pre></div>


<p>扫描定义体的时候，首先要判断的是<code>##</code>或者<code>#</code>这个连接符。如果有连接符，则判断后面的是否是形参参数。如果不是形参,则直接报错。如果是形参，则我们需要处理很多细节，如一下代码：</p>
<div class="codehilite"><pre><span class="k">const</span> <span class="n">Token</span> <span class="o">&amp;</span><span class="n">CurTok</span> <span class="o">=</span> <span class="n">Tokens</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">Tokens</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">hashhash</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">CurTok</span><span class="p">.</span><span class="n">hasLeadingSpace</span><span class="p">())</span>
    <span class="n">NextTokGetsSpace</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span><span class="p">.</span><span class="n">isOneOf</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">hash</span><span class="p">,</span> <span class="n">tok</span><span class="o">::</span><span class="n">hashat</span><span class="p">))</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ArgNo</span> <span class="o">=</span> <span class="n">Macro</span><span class="o">-&gt;</span><span class="n">getArgumentNum</span><span class="p">(</span><span class="n">Tokens</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">getIdentifierInfo</span><span class="p">());</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">ArgNo</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Token following # is not an argument?&quot;</span><span class="p">);</span>

    <span class="n">SourceLocation</span> <span class="n">ExpansionLocStart</span> <span class="o">=</span>
        <span class="n">getExpansionLocForMacroDefLoc</span><span class="p">(</span><span class="n">CurTok</span><span class="p">.</span><span class="n">getLocation</span><span class="p">());</span>
    <span class="n">SourceLocation</span> <span class="n">ExpansionLocEnd</span> <span class="o">=</span>
        <span class="n">getExpansionLocForMacroDefLoc</span><span class="p">(</span><span class="n">Tokens</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">getLocation</span><span class="p">());</span>

    <span class="n">Token</span> <span class="n">Res</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">CurTok</span><span class="p">.</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">hash</span><span class="p">))</span>  <span class="c1">// Stringify</span>
        <span class="n">Res</span> <span class="o">=</span> <span class="n">ActualArgs</span><span class="o">-&gt;</span><span class="n">getStringifiedArgument</span><span class="p">(</span><span class="n">ArgNo</span><span class="p">,</span> <span class="n">PP</span><span class="p">,</span>
            <span class="n">ExpansionLocStart</span><span class="p">,</span>
            <span class="n">ExpansionLocEnd</span><span class="p">);</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="c1">// &#39;charify&#39;: don&#39;t bother caching these.</span>
        <span class="n">Res</span> <span class="o">=</span> <span class="n">MacroArgs</span><span class="o">::</span><span class="n">StringifyArgument</span><span class="p">(</span><span class="n">ActualArgs</span><span class="o">-&gt;</span><span class="n">getUnexpArgument</span><span class="p">(</span><span class="n">ArgNo</span><span class="p">),</span>
            <span class="n">PP</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span>
            <span class="n">ExpansionLocStart</span><span class="p">,</span>
            <span class="n">ExpansionLocEnd</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Res</span><span class="p">.</span><span class="n">setFlag</span><span class="p">(</span><span class="n">Token</span><span class="o">::</span><span class="n">StringifiedInMacro</span><span class="p">);</span>

    <span class="c1">// The stringified/charified string leading space flag gets set to match</span>
    <span class="c1">// the #/#@ operator.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">NextTokGetsSpace</span><span class="p">)</span>
        <span class="n">Res</span><span class="p">.</span><span class="n">setFlag</span><span class="p">(</span><span class="n">Token</span><span class="o">::</span><span class="n">LeadingSpace</span><span class="p">);</span>

    <span class="n">ResultToks</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Res</span><span class="p">);</span>
    <span class="n">MadeChange</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>  <span class="c1">// Skip arg name.</span>
    <span class="n">NextTokGetsSpace</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>要想理解这些代码，我们必须搞清楚两种特殊符<code>#</code>和<code>#\@</code>之间的区别。一个是<code>Stringify</code>，一个是<code>Charify</code>。这里我们处理的时候会自动吃掉下一个<code>Token</code>，所以这里会<code>++i</code>。</p>
<p>然后需要特殊对待的是<code>##</code>连接符，判断当前<code>Token</code>的前后<code>Token</code>是否是连接符。</p>
<div class="codehilite"><pre><span class="c1">// Find out if there is a paste (##) operator before or after the token.</span>
<span class="kt">bool</span> <span class="n">NonEmptyPasteBefore</span> <span class="o">=</span>
    <span class="o">!</span><span class="n">ResultToks</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">ResultToks</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">hashhash</span><span class="p">);</span>
<span class="kt">bool</span> <span class="n">PasteBefore</span> <span class="o">=</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">Tokens</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">hashhash</span><span class="p">);</span>
<span class="kt">bool</span> <span class="n">PasteAfter</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">e</span> <span class="o">&amp;&amp;</span> <span class="n">Tokens</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">hashhash</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">NonEmptyPasteBefore</span> <span class="o">||</span> <span class="n">PasteBefore</span><span class="p">);</span>
</pre></div>


<p>然后判断当前<code>Token</code>是否是<code>Arg</code>,如果不是参数的话，直接复制到输出中去：</p>
<div class="codehilite"><pre><span class="c1">// Otherwise, if this is not an argument token, just add the token to the</span>
        <span class="c1">// output buffer.</span>
        <span class="n">IdentifierInfo</span> <span class="o">*</span><span class="n">II</span> <span class="o">=</span> <span class="n">CurTok</span><span class="p">.</span><span class="n">getIdentifierInfo</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">ArgNo</span> <span class="o">=</span> <span class="n">II</span> <span class="o">?</span> <span class="n">Macro</span><span class="o">-&gt;</span><span class="n">getArgumentNum</span><span class="p">(</span><span class="n">II</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ArgNo</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// This isn&#39;t an argument, just add it.</span>
            <span class="n">ResultToks</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">CurTok</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">NextTokGetsSpace</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">ResultToks</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">setFlag</span><span class="p">(</span><span class="n">Token</span><span class="o">::</span><span class="n">LeadingSpace</span><span class="p">);</span>
                <span class="n">NextTokGetsSpace</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">PasteBefore</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">NonEmptyPasteBefore</span><span class="p">)</span>
                <span class="n">ResultToks</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">clearFlag</span><span class="p">(</span><span class="n">Token</span><span class="o">::</span><span class="n">LeadingSpace</span><span class="p">);</span>

            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
</pre></div>


<p>否则就只剩下一种情况了，当前的是参数，我们要对字符串做替换。这里又有两种情况，一种是普通替换，一种是<code>##</code>。</p>
<h3 id="b4cf87">普通替换</h3>
<p>对于普通替换，我们需要提前把参数展开好，然后替换：</p>
<div class="codehilite"><pre><span class="c1">// If it is not the LHS/RHS of a ## operator, we must pre-expand the</span>
<span class="c1">// argument and substitute the expanded tokens into the result.  This is</span>
<span class="c1">// C99 6.10.3.1p1.</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PasteBefore</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PasteAfter</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">Token</span> <span class="o">*</span><span class="n">ResultArgToks</span><span class="p">;</span>

    <span class="c1">// Only preexpand the argument if it could possibly need it.  This</span>
    <span class="c1">// avoids some work in common cases.</span>
    <span class="k">const</span> <span class="n">Token</span> <span class="o">*</span><span class="n">ArgTok</span> <span class="o">=</span> <span class="n">ActualArgs</span><span class="o">-&gt;</span><span class="n">getUnexpArgument</span><span class="p">(</span><span class="n">ArgNo</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ActualArgs</span><span class="o">-&gt;</span><span class="n">ArgNeedsPreexpansion</span><span class="p">(</span><span class="n">ArgTok</span><span class="p">,</span> <span class="n">PP</span><span class="p">))</span>
        <span class="n">ResultArgToks</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ActualArgs</span><span class="o">-&gt;</span><span class="n">getPreExpArgument</span><span class="p">(</span><span class="n">ArgNo</span><span class="p">,</span> <span class="n">Macro</span><span class="p">,</span> <span class="n">PP</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">else</span>
        <span class="n">ResultArgToks</span> <span class="o">=</span> <span class="n">ArgTok</span><span class="p">;</span>  <span class="c1">// Use non-preexpanded tokens.</span>

<span class="c1">// If the arg token expanded into anything, append it.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ResultArgToks</span><span class="o">-&gt;</span><span class="n">isNot</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">eof</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="n">FirstResult</span> <span class="o">=</span> <span class="n">ResultToks</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="kt">unsigned</span> <span class="n">NumToks</span> <span class="o">=</span> <span class="n">MacroArgs</span><span class="o">::</span><span class="n">getArgLength</span><span class="p">(</span><span class="n">ResultArgToks</span><span class="p">);</span>
        <span class="n">ResultToks</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">ResultArgToks</span><span class="p">,</span> <span class="n">ResultArgToks</span> <span class="o">+</span> <span class="n">NumToks</span><span class="p">);</span>

        <span class="c1">// In Microsoft-compatibility mode, we follow MSVC&#39;s preprocessing</span>
        <span class="c1">// behavior by not considering single commas from nested macro</span>
        <span class="c1">// expansions as argument separators. Set a flag on the token so we can</span>
        <span class="c1">// test for this later when the macro expansion is processed.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">PP</span><span class="p">.</span><span class="n">getLangOpts</span><span class="p">().</span><span class="n">MSVCCompat</span> <span class="o">&amp;&amp;</span> <span class="n">NumToks</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
            <span class="n">ResultToks</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">comma</span><span class="p">))</span>
            <span class="n">ResultToks</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">setFlag</span><span class="p">(</span><span class="n">Token</span><span class="o">::</span><span class="n">IgnoredComma</span><span class="p">);</span>

        <span class="c1">// If the &#39;##&#39; came from expanding an argument, turn it into &#39;unknown&#39;</span>
        <span class="c1">// to avoid pasting.</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="n">FirstResult</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">ResultToks</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Token</span> <span class="o">&amp;</span><span class="n">Tok</span> <span class="o">=</span> <span class="n">ResultToks</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">hashhash</span><span class="p">))</span>
                <span class="n">Tok</span><span class="p">.</span><span class="n">setKind</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">unknown</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">ExpandLocStart</span><span class="p">.</span><span class="n">isValid</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">updateLocForMacroArgTokens</span><span class="p">(</span><span class="n">CurTok</span><span class="p">.</span><span class="n">getLocation</span><span class="p">(),</span>
                <span class="n">ResultToks</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">FirstResult</span><span class="p">,</span>
                <span class="n">ResultToks</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="c1">// If any tokens were substituted from the argument, the whitespace</span>
        <span class="c1">// before the first token should match the whitespace of the arg</span>
        <span class="c1">// identifier.</span>
        <span class="n">ResultToks</span><span class="p">[</span><span class="n">FirstResult</span><span class="p">].</span><span class="n">setFlagValue</span><span class="p">(</span><span class="n">Token</span><span class="o">::</span><span class="n">LeadingSpace</span><span class="p">,</span>
            <span class="n">NextTokGetsSpace</span><span class="p">);</span>
        <span class="n">NextTokGetsSpace</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>参数计算好之后，这里的代码除了<code>Token</code>替换之外，主要处理了三个问题：微软带来的逗号分隔标准，参数展开带来的<code>##</code>和新的位置计算。前两个只是做一些标识工作，最后的需要调用函数来重新计算<code>SourceLocation</code>,该函数的定义如下：</p>
<div class="codehilite"><pre><span class="c1">/// \brief Creates SLocEntries and updates the locations of macro argument</span>
<span class="c1">/// tokens to their new expanded locations.</span>
<span class="c1">///</span>
<span class="c1">/// \param ArgIdDefLoc the location of the macro argument id inside the macro</span>
<span class="c1">/// definition.</span>
<span class="c1">/// \param Tokens the macro argument tokens to update.</span>
<span class="kt">void</span> <span class="n">TokenLexer</span><span class="o">::</span><span class="n">updateLocForMacroArgTokens</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">ArgIdSpellLoc</span><span class="p">,</span>
    <span class="n">Token</span> <span class="o">*</span><span class="n">begin_tokens</span><span class="p">,</span>
    <span class="n">Token</span> <span class="o">*</span><span class="n">end_tokens</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SourceManager</span> <span class="o">&amp;</span><span class="n">SM</span> <span class="o">=</span> <span class="n">PP</span><span class="p">.</span><span class="n">getSourceManager</span><span class="p">();</span>

    <span class="n">SourceLocation</span> <span class="n">InstLoc</span> <span class="o">=</span>
        <span class="n">getExpansionLocForMacroDefLoc</span><span class="p">(</span><span class="n">ArgIdSpellLoc</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">begin_tokens</span> <span class="o">&lt;</span> <span class="n">end_tokens</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// If there&#39;s only one token just create a SLocEntry for it.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">end_tokens</span> <span class="o">-</span> <span class="n">begin_tokens</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Token</span> <span class="o">&amp;</span><span class="n">Tok</span> <span class="o">=</span> <span class="o">*</span><span class="n">begin_tokens</span><span class="p">;</span>
            <span class="n">Tok</span><span class="p">.</span><span class="n">setLocation</span><span class="p">(</span><span class="n">SM</span><span class="p">.</span><span class="n">createMacroArgExpansionLoc</span><span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">getLocation</span><span class="p">(),</span>
                <span class="n">InstLoc</span><span class="p">,</span>
                <span class="n">Tok</span><span class="p">.</span><span class="n">getLength</span><span class="p">()));</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">updateConsecutiveMacroArgTokens</span><span class="p">(</span><span class="n">SM</span><span class="p">,</span> <span class="n">InstLoc</span><span class="p">,</span> <span class="n">begin_tokens</span><span class="p">,</span> <span class="n">end_tokens</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p><code>while</code>循环内，会调用<code>UpdateConsecutiveMacroArgTokens</code>这个名字非常长的函数，来处理连续<code>Token</code>的位置调整，这里的<code>begin_tokens</code>和<code>end_tokens</code>是以引用的形式传递进去的，所以循环才可能终止。这个<code>UpdateConsecutiveMacroArgTokens</code>的签名如下：</p>
<div class="codehilite"><pre><span class="c1">// \brief Finds the tokens that are consecutive (from the same FileID)</span>
<span class="c1">/// creates a single SLocEntry, and assigns SourceLocations to each token that</span>
<span class="c1">/// point to that SLocEntry. e.g for</span>
<span class="c1">///   assert(foo == bar);</span>
<span class="c1">/// There will be a single SLocEntry for the &quot;foo == bar&quot; chunk and locations</span>
<span class="c1">/// for the &#39;foo&#39;, &#39;==&#39;, &#39;bar&#39; tokens will point inside that chunk.</span>
<span class="c1">///</span>
<span class="c1">/// \arg begin_tokens will be updated to a position past all the found</span>
<span class="c1">/// consecutive tokens.</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">updateConsecutiveMacroArgTokens</span><span class="p">(</span><span class="n">SourceManager</span> <span class="o">&amp;</span><span class="n">SM</span><span class="p">,</span>
    <span class="n">SourceLocation</span> <span class="n">InstLoc</span><span class="p">,</span>
    <span class="n">Token</span> <span class="o">*&amp;</span><span class="n">begin_tokens</span><span class="p">,</span>
    <span class="n">Token</span> <span class="o">*</span> <span class="n">end_tokens</span><span class="p">)</span>
</pre></div>


<p>其实内部操作很简单，就是一直扫描处于同一文件之中且相邻距离不超过50个字符的<code>Token</code>，合并为一个<code>SlocEntry</code>以压缩存储，但是各个<code>Token</code>的<code>SourceLocation</code>还是各自维持的。寻找连续<code>Token</code>的代码如下：</p>
<div class="codehilite"><pre><span class="n">assert</span><span class="p">(</span><span class="n">begin_tokens</span> <span class="o">&lt;</span> <span class="n">end_tokens</span><span class="p">);</span>

<span class="n">SourceLocation</span> <span class="n">FirstLoc</span> <span class="o">=</span> <span class="n">begin_tokens</span><span class="o">-&gt;</span><span class="n">getLocation</span><span class="p">();</span>
<span class="n">SourceLocation</span> <span class="n">CurLoc</span> <span class="o">=</span> <span class="n">FirstLoc</span><span class="p">;</span>

<span class="c1">// Compare the source location offset of tokens and group together tokens that</span>
<span class="c1">// are close, even if their locations point to different FileIDs. e.g.</span>
<span class="c1">//</span>
<span class="c1">//  |bar    |  foo | cake   |  (3 tokens from 3 consecutive FileIDs)</span>
<span class="c1">//  ^                    ^</span>
<span class="c1">//  |bar       foo   cake|     (one SLocEntry chunk for all tokens)</span>
<span class="c1">//</span>
<span class="c1">// we can perform this &quot;merge&quot; since the token&#39;s spelling location depends</span>
<span class="c1">// on the relative offset.</span>

<span class="n">Token</span> <span class="o">*</span><span class="n">NextTok</span> <span class="o">=</span> <span class="n">begin_tokens</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(;</span> <span class="n">NextTok</span> <span class="o">&lt;</span> <span class="n">end_tokens</span><span class="p">;</span> <span class="o">++</span><span class="n">NextTok</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SourceLocation</span> <span class="n">NextLoc</span> <span class="o">=</span> <span class="n">NextTok</span><span class="o">-&gt;</span><span class="n">getLocation</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">CurLoc</span><span class="p">.</span><span class="n">isFileID</span><span class="p">()</span> <span class="o">!=</span> <span class="n">NextLoc</span><span class="p">.</span><span class="n">isFileID</span><span class="p">())</span>
        <span class="k">break</span><span class="p">;</span> <span class="c1">// Token from different kind of FileID.</span>

    <span class="kt">int</span> <span class="n">RelOffs</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SM</span><span class="p">.</span><span class="n">isInSameSLocAddrSpace</span><span class="p">(</span><span class="n">CurLoc</span><span class="p">,</span> <span class="n">NextLoc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RelOffs</span><span class="p">))</span>
        <span class="k">break</span><span class="p">;</span> <span class="c1">// Token from different local/loaded location.</span>
 <span class="c1">// Check that token is not before the previous token or more than 50</span>
 <span class="c1">// &quot;characters&quot; away.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">RelOffs</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">RelOffs</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">)</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="n">CurLoc</span> <span class="o">=</span> <span class="n">NextLoc</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>之后的处理相对来说就比较简单，填充对应的<code>SlocEntry</code>，维持各个<code>Token</code>的<code>SourceLocation</code>。</p>
<div class="codehilite"><pre><span class="c1">// For the consecutive tokens, find the length of the SLocEntry to contain</span>
<span class="c1">// all of them.</span>
<span class="n">Token</span> <span class="o">&amp;</span><span class="n">LastConsecutiveTok</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">NextTok</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">LastRelOffs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">SM</span><span class="p">.</span><span class="n">isInSameSLocAddrSpace</span><span class="p">(</span><span class="n">FirstLoc</span><span class="p">,</span> <span class="n">LastConsecutiveTok</span><span class="p">.</span><span class="n">getLocation</span><span class="p">(),</span>
    <span class="o">&amp;</span><span class="n">LastRelOffs</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="n">FullLength</span> <span class="o">=</span> <span class="n">LastRelOffs</span> <span class="o">+</span> <span class="n">LastConsecutiveTok</span><span class="p">.</span><span class="n">getLength</span><span class="p">();</span>

<span class="c1">// Create a macro expansion SLocEntry that will &quot;contain&quot; all of the tokens.</span>
<span class="n">SourceLocation</span> <span class="n">Expansion</span> <span class="o">=</span>
    <span class="n">SM</span><span class="p">.</span><span class="n">createMacroArgExpansionLoc</span><span class="p">(</span><span class="n">FirstLoc</span><span class="p">,</span> <span class="n">InstLoc</span><span class="p">,</span> <span class="n">FullLength</span><span class="p">);</span>

<span class="c1">// Change the location of the tokens from the spelling location to the new</span>
<span class="c1">// expanded location.</span>
<span class="k">for</span> <span class="p">(;</span> <span class="n">begin_tokens</span> <span class="o">&lt;</span> <span class="n">NextTok</span><span class="p">;</span> <span class="o">++</span><span class="n">begin_tokens</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Token</span> <span class="o">&amp;</span><span class="n">Tok</span> <span class="o">=</span> <span class="o">*</span><span class="n">begin_tokens</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">RelOffs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">SM</span><span class="p">.</span><span class="n">isInSameSLocAddrSpace</span><span class="p">(</span><span class="n">FirstLoc</span><span class="p">,</span> <span class="n">Tok</span><span class="p">.</span><span class="n">getLocation</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">RelOffs</span><span class="p">);</span>
    <span class="n">Tok</span><span class="p">.</span><span class="n">setLocation</span><span class="p">(</span><span class="n">Expansion</span><span class="p">.</span><span class="n">getLocWithOffset</span><span class="p">(</span><span class="n">RelOffs</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>


<h5 id="a6b363">拼接</h5>
<p>简单来说，在C语言的宏中是容许嵌套的，其嵌套后，一般的展开规律像函数的参数一样，先展开参数，在分析函数，所以展开顺序是由内而外。但是当宏中有<code>#</code>则不再展开参数了，如果宏中有<code>##</code>，则先展开函数，再展开里面的参数。所以在处理<code>##</code>时，不能使用展开之后的实参，只能用未展开之前的实参。所以我们需要如下处理，首先获得实参未展开形式：</p>
<div class="codehilite"><pre><span class="c1">// Okay, we have a token that is either the LHS or RHS of a paste (##)</span>
<span class="c1">// argument.  It gets substituted as its non-pre-expanded tokens.</span>
<span class="k">const</span> <span class="n">Token</span> <span class="o">*</span><span class="n">ArgToks</span> <span class="o">=</span> <span class="n">ActualArgs</span><span class="o">-&gt;</span><span class="n">getUnexpArgument</span><span class="p">(</span><span class="n">ArgNo</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="n">NumToks</span> <span class="o">=</span> <span class="n">MacroArgs</span><span class="o">::</span><span class="n">getArgLength</span><span class="p">(</span><span class="n">ArgToks</span><span class="p">);</span>
</pre></div>


<p>如果实参不为空，则需要进行拼接处理，这里又会遇到<code>GNU comma</code>这个烦人的东西，其形式为<code>, ## __VA_ARGS__</code>，此时我们需要把这个扩展的使用记录下来，同时将<code>##</code>弹出，然后再进行处理。</p>
<p>处理时首先把这个参数放入结果<code>Token</code>数组中，如果压入的这些<code>Token</code>也包含<code>##</code>，标记为<code>tok::unknown</code>。此外还要处理是否保留第一个空格的问题，所以这部分总的代码如下：</p>
<div class="codehilite"><pre><span class="k">if</span> <span class="p">(</span><span class="n">NumToks</span><span class="p">)</span>
<span class="p">{</span>  <span class="c1">// Not an empty argument?</span>
<span class="c1">// If this is the GNU &quot;, ## __VA_ARGS__&quot; extension, and we just learned</span>
<span class="c1">// that __VA_ARGS__ expands to multiple tokens, avoid a pasting error when</span>
<span class="c1">// the expander trys to paste &#39;,&#39; with the first token of the __VA_ARGS__</span>
<span class="c1">// expansion.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">NonEmptyPasteBefore</span> <span class="o">&amp;&amp;</span> <span class="n">ResultToks</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span>
        <span class="n">ResultToks</span><span class="p">[</span><span class="n">ResultToks</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">].</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">comma</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">ArgNo</span> <span class="o">==</span> <span class="n">Macro</span><span class="o">-&gt;</span><span class="n">getNumArgs</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
        <span class="n">Macro</span><span class="o">-&gt;</span><span class="n">isVariadic</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="c1">// Remove the paste operator, report use of the extension.</span>
        <span class="n">PP</span><span class="p">.</span><span class="n">Diag</span><span class="p">(</span><span class="n">ResultToks</span><span class="p">.</span><span class="n">pop_back_val</span><span class="p">().</span><span class="n">getLocation</span><span class="p">(),</span> <span class="n">diag</span><span class="o">::</span><span class="n">ext_paste_comma</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">ResultToks</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">ArgToks</span><span class="p">,</span> <span class="n">ArgToks</span> <span class="o">+</span> <span class="n">NumToks</span><span class="p">);</span>

    <span class="c1">// If the &#39;##&#39; came from expanding an argument, turn it into &#39;unknown&#39;</span>
    <span class="c1">// to avoid pasting.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ResultToks</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="n">NumToks</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">ResultToks</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Token</span> <span class="o">&amp;</span><span class="n">Tok</span> <span class="o">=</span> <span class="n">ResultToks</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">hashhash</span><span class="p">))</span>
            <span class="n">Tok</span><span class="p">.</span><span class="n">setKind</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">unknown</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ExpandLocStart</span><span class="p">.</span><span class="n">isValid</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">updateLocForMacroArgTokens</span><span class="p">(</span><span class="n">CurTok</span><span class="p">.</span><span class="n">getLocation</span><span class="p">(),</span>
            <span class="n">ResultToks</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="n">NumToks</span><span class="p">,</span> <span class="n">ResultToks</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="c1">// If this token (the macro argument) was supposed to get leading</span>
    <span class="c1">// whitespace, transfer this information onto the first token of the</span>
    <span class="c1">// expansion.</span>
    <span class="c1">//</span>
    <span class="c1">// Do not do this if the paste operator occurs before the macro argument,</span>
    <span class="c1">// as in &quot;A ## MACROARG&quot;.  In valid code, the first token will get</span>
    <span class="c1">// smooshed onto the preceding one anyway (forming AMACROARG).  In</span>
    <span class="c1">// assembler-with-cpp mode, invalid pastes are allowed through: in this</span>
    <span class="c1">// case, we do not want the extra whitespace to be added.  For example,</span>
    <span class="c1">// we want &quot;. ## foo&quot; -&gt; &quot;.foo&quot; not &quot;. foo&quot;.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">NextTokGetsSpace</span><span class="p">)</span>
        <span class="n">ResultToks</span><span class="p">[</span><span class="n">ResultToks</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="n">NumToks</span><span class="p">].</span><span class="n">setFlag</span><span class="p">(</span><span class="n">Token</span><span class="o">::</span><span class="n">LeadingSpace</span><span class="p">);</span>

    <span class="n">NextTokGetsSpace</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>此处还有一个特殊情况，如果<code>##</code>连接符的任何一个参数是空的话，直接忽略当前连接符。</p>
<div class="codehilite"><pre><span class="c1">// If an empty argument is on the LHS or RHS of a paste, the standard (C99</span>
        <span class="c1">// 6.10.3.3p2,3) calls for a bunch of placemarker stuff to occur.  We</span>
        <span class="c1">// implement this by eating ## operators when a LHS or RHS expands to</span>
        <span class="c1">// empty.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">PasteAfter</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Discard the argument token and skip (don&#39;t copy to the expansion</span>
            <span class="c1">// buffer) the paste operator after it.</span>
            <span class="o">++</span><span class="n">i</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
</pre></div>


<h3 id="2c3d57">宏cache</h3>
<p>如果这个宏会被多次展开的话，我们可以复用之前分析的结果，放进<code>cacheMacro</code>中，同时当前<code>ResultTokens</code>的所有权也被转移到了<code>PrePocessor</code>之中。</p>
<div class="codehilite"><pre><span class="k">if</span> <span class="p">(</span><span class="n">MadeChange</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">OwnsTokens</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;This would leak if we already own the token list&quot;</span><span class="p">);</span>
    <span class="c1">// This is deleted in the dtor.</span>
    <span class="n">NumTokens</span> <span class="o">=</span> <span class="n">ResultToks</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="c1">// The tokens will be added to Preprocessor&#39;s cache and will be removed</span>
    <span class="c1">// when this TokenLexer finishes lexing them.</span>
    <span class="n">Tokens</span> <span class="o">=</span> <span class="n">PP</span><span class="p">.</span><span class="n">cacheMacroExpandedTokens</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">ResultToks</span><span class="p">);</span>

    <span class="c1">// The preprocessor cache of macro expanded tokens owns these tokens,not us.</span>
    <span class="n">OwnsTokens</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>而<code>TokenLexer</code>的各个构造函数都会调用<code>init</code>这个函数，由此可见他的重要程度。该函数的签名如下：</p>
<div class="codehilite"><pre><span class="c1">/// Init - Initialize this TokenLexer to expand from the specified macro</span>
<span class="c1">/// with the specified argument information.  Note that this ctor takes</span>
<span class="c1">/// ownership of the ActualArgs pointer.  ILEnd specifies the location of the</span>
<span class="c1">/// &#39;)&#39; for a function-like macro or the identifier for an object-like macro.</span>
<span class="kt">void</span> <span class="nf">Init</span><span class="p">(</span><span class="n">Token</span> <span class="o">&amp;</span><span class="n">Tok</span><span class="p">,</span> <span class="n">SourceLocation</span> <span class="n">ILEnd</span><span class="p">,</span> <span class="n">MacroInfo</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span>
    <span class="n">MacroArgs</span> <span class="o">*</span><span class="n">ActualArgs</span><span class="p">);</span>
</pre></div>


<p>这几个参数包括：展开开始位点，展开结束位点，宏定义信息，宏实参信息。</p>
<p>由于<code>TokenLexer</code>是一个可复用的对象，所以我们在调用<code>init</code>时，首先需要释放之前占有的资源，需要调用一个<code>destroy</code>函数：</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="n">TokenLexer</span><span class="o">::</span><span class="n">destroy</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// If this was a function-like macro that actually uses its arguments, delete</span>
    <span class="c1">// the expanded tokens.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">OwnsTokens</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">Tokens</span><span class="p">;</span>
        <span class="n">Tokens</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="n">OwnsTokens</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// TokenLexer owns its formal arguments.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ActualArgs</span><span class="p">)</span> <span class="n">ActualArgs</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">(</span><span class="n">PP</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>这个函数作用就是释放占有的<code>Token</code> 和<code>ActualArgs</code>，这些都是属于上一个宏的。</p>
<p>在释放这些资源之后，以输入参数重置当前<code>TokenLexer</code>，所以<code>init</code>的开头代码定义如下：</p>
<div class="codehilite"><pre><span class="n">destroy</span><span class="p">();</span>

<span class="n">Macro</span> <span class="o">=</span> <span class="n">MI</span><span class="p">;</span>
<span class="n">ActualArgs</span> <span class="o">=</span> <span class="n">Actuals</span><span class="p">;</span>
<span class="n">CurToken</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">ExpandLocStart</span> <span class="o">=</span> <span class="n">Tok</span><span class="p">.</span><span class="n">getLocation</span><span class="p">();</span>
<span class="n">ExpandLocEnd</span> <span class="o">=</span> <span class="n">ELEnd</span><span class="p">;</span>
<span class="n">AtStartOfLine</span> <span class="o">=</span> <span class="n">Tok</span><span class="p">.</span><span class="n">isAtStartOfLine</span><span class="p">();</span>
<span class="n">HasLeadingSpace</span> <span class="o">=</span> <span class="n">Tok</span><span class="p">.</span><span class="n">hasLeadingSpace</span><span class="p">();</span>
<span class="n">NextTokGetsSpace</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="n">Tokens</span> <span class="o">=</span> <span class="o">&amp;*</span><span class="n">Macro</span><span class="o">-&gt;</span><span class="n">tokens_begin</span><span class="p">();</span>
<span class="n">OwnsTokens</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="n">DisableMacroExpansion</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="n">NumTokens</span> <span class="o">=</span> <span class="n">Macro</span><span class="o">-&gt;</span><span class="n">tokens_end</span><span class="p">()</span> <span class="o">-</span> <span class="n">Macro</span><span class="o">-&gt;</span><span class="n">tokens_begin</span><span class="p">();</span>
<span class="n">MacroExpansionStart</span> <span class="o">=</span> <span class="n">SourceLocation</span><span class="p">();</span>

<span class="n">SourceManager</span> <span class="o">&amp;</span><span class="n">SM</span> <span class="o">=</span> <span class="n">PP</span><span class="p">.</span><span class="n">getSourceManager</span><span class="p">();</span>
<span class="n">MacroStartSLocOffset</span> <span class="o">=</span> <span class="n">SM</span><span class="p">.</span><span class="n">getNextLocalOffset</span><span class="p">();</span>
</pre></div>


<p>各种初始化！然后是预留空间:</p>
<div class="codehilite"><pre><span class="k">if</span> <span class="p">(</span><span class="n">NumTokens</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">Tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">getLocation</span><span class="p">().</span><span class="n">isValid</span><span class="p">());</span>
    <span class="n">assert</span><span class="p">((</span><span class="n">Tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">getLocation</span><span class="p">().</span><span class="n">isFileID</span><span class="p">()</span> <span class="o">||</span> <span class="n">Tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">comment</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
        <span class="s">&quot;Macro defined in macro?&quot;</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">ExpandLocStart</span><span class="p">.</span><span class="n">isValid</span><span class="p">());</span>

    <span class="c1">// Reserve a source location entry chunk for the length of the macro</span>
    <span class="c1">// definition. Tokens that get lexed directly from the definition will</span>
    <span class="c1">// have their locations pointing inside this chunk. This is to avoid</span>
    <span class="c1">// creating separate source location entries for each token.</span>
    <span class="n">MacroDefStart</span> <span class="o">=</span> <span class="n">SM</span><span class="p">.</span><span class="n">getExpansionLoc</span><span class="p">(</span><span class="n">Tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">getLocation</span><span class="p">());</span>
    <span class="n">MacroDefLength</span> <span class="o">=</span> <span class="n">Macro</span><span class="o">-&gt;</span><span class="n">getDefinitionLength</span><span class="p">(</span><span class="n">SM</span><span class="p">);</span>
    <span class="n">MacroExpansionStart</span> <span class="o">=</span> <span class="n">SM</span><span class="p">.</span><span class="n">createExpansionLoc</span><span class="p">(</span><span class="n">MacroDefStart</span><span class="p">,</span>
        <span class="n">ExpandLocStart</span><span class="p">,</span>
        <span class="n">ExpandLocEnd</span><span class="p">,</span>
        <span class="n">MacroDefLength</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>如果是带参宏函数，则展开该宏函数：</p>
<div class="codehilite"><pre><span class="c1">// If this is a function-like macro, expand the arguments and change</span>
<span class="c1">// Tokens to point to the expanded tokens.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Macro</span><span class="o">-&gt;</span><span class="n">isFunctionLike</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">Macro</span><span class="o">-&gt;</span><span class="n">getNumArgs</span><span class="p">())</span>
    <span class="n">ExpandFunctionArguments</span><span class="p">();</span>
</pre></div>


<h2 id="976472">Lex</h2>
<p>这里的<code>Lex</code>函数的每次调用会返回一个<code>Token</code>，并把这个<code>Token</code>从结果中剔除，类似于 <code>queue.pop_front()</code> 操作。其函数签名见下：</p>
<div class="codehilite"><pre><span class="c1">/// Lex - Lex and return a token from this macro stream.</span>
<span class="c1">///</span>
<span class="kt">bool</span> <span class="n">TokenLexer</span><span class="o">::</span><span class="n">Lex</span><span class="p">(</span><span class="n">Token</span> <span class="o">&amp;</span><span class="n">Tok</span><span class="p">)</span>
</pre></div>


<p>函数执行时，首先判断是否到了<code>Buffer</code>的末尾。如果到了，则允许当前宏在其他过程中展开，最后的处理会委托到<code>Preprocessor</code>中进行：</p>
<div class="codehilite"><pre><span class="c1">// Lexing off the end of the macro, pop this macro off the expansion stack.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">isAtEnd</span><span class="p">())</span>
<span class="p">{</span>
    <span class="c1">// If this is a macro (not a token stream), mark the macro enabled now</span>
    <span class="c1">// that it is no longer being expanded.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Macro</span><span class="p">)</span> <span class="n">Macro</span><span class="o">-&gt;</span><span class="n">EnableMacro</span><span class="p">();</span>

    <span class="n">Tok</span><span class="p">.</span><span class="n">startToken</span><span class="p">();</span>
    <span class="n">Tok</span><span class="p">.</span><span class="n">setFlagValue</span><span class="p">(</span><span class="n">Token</span><span class="o">::</span><span class="n">StartOfLine</span><span class="p">,</span> <span class="n">AtStartOfLine</span><span class="p">);</span>
    <span class="n">Tok</span><span class="p">.</span><span class="n">setFlagValue</span><span class="p">(</span><span class="n">Token</span><span class="o">::</span><span class="n">LeadingSpace</span><span class="p">,</span> <span class="n">HasLeadingSpace</span> <span class="o">||</span> <span class="n">NextTokGetsSpace</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">CurToken</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">Tok</span><span class="p">.</span><span class="n">setFlag</span><span class="p">(</span><span class="n">Token</span><span class="o">::</span><span class="n">LeadingEmptyMacro</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">PP</span><span class="p">.</span><span class="n">HandleEndOfTokenLexer</span><span class="p">(</span><span class="n">Tok</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>不是末尾的话，获得当前<code>Token</code>，同时判断下一个<code>Token</code>是否是<code>##</code>符。</p>
<div class="codehilite"><pre><span class="n">SourceManager</span> <span class="o">&amp;</span><span class="n">SM</span> <span class="o">=</span> <span class="n">PP</span><span class="p">.</span><span class="n">getSourceManager</span><span class="p">();</span>

<span class="c1">// If this is the first token of the expanded result, we inherit spacing</span>
<span class="c1">// properties later.</span>
<span class="kt">bool</span> <span class="n">isFirstToken</span> <span class="o">=</span> <span class="n">CurToken</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// Get the next token to return.</span>
<span class="n">Tok</span> <span class="o">=</span> <span class="n">Tokens</span><span class="p">[</span><span class="n">CurToken</span><span class="o">++</span><span class="p">];</span>

<span class="kt">bool</span> <span class="n">TokenIsFromPaste</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</pre></div>


<p>如果是<code>##</code>符，则需要<code>PasteToken</code>操作：</p>
<div class="codehilite"><pre><span class="c1">// If this token is followed by a token paste (##) operator, paste the tokens!</span>
<span class="c1">// Note that ## is a normal token when not expanding a macro.</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isAtEnd</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">Macro</span> <span class="o">&amp;&amp;</span>
    <span class="p">(</span><span class="n">Tokens</span><span class="p">[</span><span class="n">CurToken</span><span class="p">].</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">hashhash</span><span class="p">)</span> <span class="o">||</span>
        <span class="c1">// Special processing of L#x macros in -fms-compatibility mode.</span>
        <span class="c1">// Microsoft compiler is able to form a wide string literal from</span>
        <span class="c1">// &#39;L#macro_arg&#39; construct in a function-like macro.</span>
        <span class="p">(</span><span class="n">PP</span><span class="p">.</span><span class="n">getLangOpts</span><span class="p">().</span><span class="n">MSVCCompat</span> <span class="o">&amp;&amp;</span>
            <span class="n">isWideStringLiteralFromMacro</span><span class="p">(</span><span class="n">Tok</span><span class="p">,</span> <span class="n">Tokens</span><span class="p">[</span><span class="n">CurToken</span><span class="p">]))))</span>
<span class="p">{</span>
    <span class="c1">// When handling the microsoft /##/ extension, the final token is</span>
    <span class="c1">// returned by PasteTokens, not the pasted token.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PasteTokens</span><span class="p">(</span><span class="n">Tok</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

    <span class="n">TokenIsFromPaste</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里的<code>PasteTokens</code>操作非常的长，这里就不详细说明了，主要是我自己还看不懂！大意就是将<code>##</code>两边的操作符连接起来组成一个<code>Identifier</code>，需要注意的是有需要递归处理的情况，如多个连接符。这里就贴一下该函数的签名以及注释吧：</p>
<div class="codehilite"><pre><span class="c1">/// PasteTokens - Tok is the LHS of a ## operator, and CurToken is the ##</span>
<span class="c1">/// operator.  Read the ## and RHS, and paste the LHS/RHS together.  If there</span>
<span class="c1">/// are more ## after it, chomp them iteratively.  Return the result as Tok.</span>
<span class="c1">/// If this returns true, the caller should immediately return the token.</span>
<span class="kt">bool</span> <span class="n">TokenLexer</span><span class="o">::</span><span class="n">PasteTokens</span><span class="p">(</span><span class="n">Token</span> <span class="o">&amp;</span><span class="n">Tok</span><span class="p">)</span>
</pre></div>


<p>如果下一个是普通<code>Token</code>，则我们只需要修正一下位置信息即可：</p>
<div class="codehilite"><pre><span class="c1">// The token&#39;s current location indicate where the token was lexed from.  We</span>
<span class="c1">// need this information to compute the spelling of the token, but any</span>
<span class="c1">// diagnostics for the expanded token should appear as if they came from</span>
<span class="c1">// ExpansionLoc.  Pull this information together into a new SourceLocation</span>
<span class="c1">// that captures all of this.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ExpandLocStart</span><span class="p">.</span><span class="n">isValid</span><span class="p">()</span> <span class="o">&amp;&amp;</span>   <span class="c1">// Don&#39;t do this for token streams.</span>
    <span class="c1">// Check that the token&#39;s location was not already set properly.</span>
    <span class="n">SM</span><span class="p">.</span><span class="n">isBeforeInSLocAddrSpace</span><span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">getLocation</span><span class="p">(),</span> <span class="n">MacroStartSLocOffset</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">SourceLocation</span> <span class="n">instLoc</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">is</span><span class="p">(</span><span class="n">tok</span><span class="o">::</span><span class="n">comment</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">instLoc</span> <span class="o">=</span> <span class="n">SM</span><span class="p">.</span><span class="n">createExpansionLoc</span><span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">getLocation</span><span class="p">(),</span>
            <span class="n">ExpandLocStart</span><span class="p">,</span>
            <span class="n">ExpandLocEnd</span><span class="p">,</span>
            <span class="n">Tok</span><span class="p">.</span><span class="n">getLength</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">instLoc</span> <span class="o">=</span> <span class="n">getExpansionLocForMacroDefLoc</span><span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">getLocation</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="n">Tok</span><span class="p">.</span><span class="n">setLocation</span><span class="p">(</span><span class="n">instLoc</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>剩下的就是一些错误处理相关的东西，如果我们当前的<code>Token</code>是一个<code>Identifier</code>，则需要判断该<code>Identifier</code>是否有效，无效的话扔进错误处理：</p>
<div class="codehilite"><pre><span class="c1">// Handle recursive expansion!</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Tok</span><span class="p">.</span><span class="n">isAnnotation</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">Tok</span><span class="p">.</span><span class="n">getIdentifierInfo</span><span class="p">()</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Change the kind of this identifier to the appropriate token kind, e.g.</span>
    <span class="c1">// turning &quot;for&quot; into a keyword.</span>
    <span class="n">IdentifierInfo</span> <span class="o">*</span><span class="n">II</span> <span class="o">=</span> <span class="n">Tok</span><span class="p">.</span><span class="n">getIdentifierInfo</span><span class="p">();</span>
    <span class="n">Tok</span><span class="p">.</span><span class="n">setKind</span><span class="p">(</span><span class="n">II</span><span class="o">-&gt;</span><span class="n">getTokenID</span><span class="p">());</span>

    <span class="c1">// If this identifier was poisoned and from a paste, emit an error.  This</span>
    <span class="c1">// won&#39;t be handled by Preprocessor::HandleIdentifier because this is coming</span>
    <span class="c1">// from a macro expansion.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">II</span><span class="o">-&gt;</span><span class="n">isPoisoned</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">TokenIsFromPaste</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">PP</span><span class="p">.</span><span class="n">HandlePoisonedIdentifier</span><span class="p">(</span><span class="n">Tok</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">DisableMacroExpansion</span> <span class="o">&amp;&amp;</span> <span class="n">II</span><span class="o">-&gt;</span><span class="n">isHandleIdentifierCase</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">PP</span><span class="p">.</span><span class="n">HandleIdentifier</span><span class="p">(</span><span class="n">Tok</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h1 id="c99c80">Lexer</h1>
<p>这里的实现有4000多行，没有对<code>C99</code>的深入了解看代码是无意义的，以后再说。</p>
<h1 id="ee2cf0">Preprocessor</h1>
<p>这里光头文件就有2000行，明年再说吧。</p>
    </div>
    <div id="content-comments">
<div id="disqus_thread"></div>
<script type="text/javascript">var disqus_shortname="SpiritsAway";(function(){var a=document.createElement("script");a.type="text/javascript";a.async=true;a.src="//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)})();</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</div>
<div class="niu2-right-container col-md-2">
    <div id="niu2-sidebar-meta" class="niu2-sidebar">
        <div class="niu2-sidebar-label"><i class="icon-calendar"></i>发布时间:</div>
        <div class="niu2-sidebar-value">2015-11-27 23:35</div>
        <div class="niu2-sidebar-label"><i class="icon-open-folder"></i>分类:</div>
        <div class="niu2-sidebar-value"><a href="http://spiritsaway.info/compiler/index.html">Compiler</a></div>
        <div class="niu2-sidebar-label"><i class="icon-tag"></i>标签:</div>
 
            <div class="niu2-sidebar-inter-value niu2-sidebar-tag"><a href="http://spiritsaway.info/tag/compiler.html">Compiler</a><sup>2</sup></div>
            <div class="niu2-sidebar-inter-value niu2-sidebar-tag"><a href="http://spiritsaway.info/tag/clang.html">Clang</a><sup>2</sup></div>
            <div class="niu2-sidebar-inter-value niu2-sidebar-tag"><a href="http://spiritsaway.info/tag/cpp.html">Cpp</a><sup>10</sup></div>
    </div>

    <div id="niu2-sidebar-toc" class="niu2-sidebar" data-status="closed">
        <div class="niu2-sidebar-label">
            <i id="niu2-sidebar-toc-ctrl" class="icon-open-tocs"></i>目录
        </div>
        <ol id="niu2-sidebar-toc-list">
            <li><a href="#content-heading">Clang Lexer</a></li>
            <li><a href='#459a6f'>Token</a></li><li><a href='#9eb729'>符号</a></li><li><a href='#ceb0aa'>符号表</a></li><li><a href='#af6598'>宏管理</a><ol><li><a href='#887c57'>MacroArgs</a></li><li><a href='#426eb0'>MacroInfo</a></li><li><a href='#a15340'>MacroDirective</a></li><li><a href='#84847d'>MuduleMacro</a></li><li><a href='#b7345d'>MacroDefinition</a></li></ol></li><li><a href='#4985e4'>头文件管理</a><ol><li><a href='#028d64'>Multiple Include Optimization</a></li><li><a href='#c5d09e'>HeaderMap</a></li></ol></li><li><a href='#82fdcc'>头文件定位</a></li><li><a href='#b9e535'>预处理器</a><ol><li><a href='#5e6b8d'>PreprocessorLexer.h</a></li><li><a href='#fd1ea3'>PTHLexer</a></li><li><a href='#a7d57d'>PTH 文件格式</a></li></ol></li><li><a href='#d5c82d'>PTHManager</a><ol><li><a href='#91ad3f'>对象构造</a></li><li><a href='#fbe7e3'>名字映射</a></li><li><a href='#0bcaa4'>CreateLexer</a></li></ol></li><li><a href='#160158'>TokenLexer</a><ol><li><a href='#73e4e5'>Function Expansion</a><ol><li><a href='#b4cf87'>普通替换</a><ol><li><a href='#a6b363'>拼接</a></li></ol></li><li><a href='#2c3d57'>宏cache</a></li></ol></li><li><a href='#976472'>Lex</a></li></ol></li><li><a href='#c99c80'>Lexer</a></li><li><a href='#ee2cf0'>Preprocessor</a></li>
            <li><a href="#content-comments">评论</a></li>
        </ol>
    </div>
</div>    </div>

    <div class="niu2-footer">
        <div id="body-footer" class="col-md-6 col-md-offset-2">
<hr/>
<p>
    Powered by <a href="https://github.com/getpelican/pelican">Pelican</a>, 
    <a href="https://github.com/mawenbao/niu-x2-sidebar">theme</a> built with <a href="http://getbootstrap.com">Bootstrap3</a>
    by <a href="http://blog.atime.me">Ma Wenbao</a>, icons by 
    <a href="http://fortawesome.github.io/Font-Awesome">Font Awesome</a>.
</p>
<p>
    ©
            2014-2015
    <a class="niu2-footer-link" href="http://spiritsaway.info">Huiliang Huang</a>
</p>
<p class="niu2-icons">
        <a class="niu2-footer-icon" href="mailto: spiritsaway@outlook.com" title="my email address">
            <i class="fa-envelope-alt icon-lg"></i>
        </a>
        <a class="niu2-footer-icon" href="https://github.com/huangfeidian" title="my github page">
            <i class="fa-github-alt icon-lg"></i>
        </a>
</p>        </div>
    </div>
    
    <div id="niu2-pygments" data-theme="github"></div>

    <script type="text/javascript" src="http://spiritsaway.info/theme/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="http://spiritsaway.info/theme/js/niu2.min.js"></script>
    <script type="text/javascript" src="http://spiritsaway.info/theme/js/bootstrap.min.js"></script>
    <script type="text/javascript">onContentLoaded();</script>
  </body>
</html>
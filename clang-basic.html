<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clang Basic - spirits away</title>
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.png">
    <link rel="stylesheet" href="./theme/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="./theme/font-icons/style.min.css" type="text/css" />
    <link rel="stylesheet" href="./theme/css/niu2.min.css" type="text/css" />

    <link rel="canonical" href="./clang-basic.html" />
    
    <script type="text/javascript">window.onload=function(){};</script>
    <!--[if lt IE 9]>
        <script src="./theme/js/html5shiv.js"></script>
        <script src="./theme/js/respond.min.js"></script>
    <![endif]-->
  </head>
  <body> 
    <div id="body-header">
<div class="navbar navbar-inverse navbar-fixed-top">
<div class="col-md-12">
    <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href=".">
            <i class="icon-home"></i>spirits away
        </a>
    </div>
    <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
        <ul class="nav navbar-nav">
            <li><a href="/pages/about.html" title="about">
                <i class="icon-anchor"></i>关于</a>
            </li>
            <li><a href="/archives.html" title="archives">
                <i class="icon-archive"></i>存档</a>
            </li>
            <li><a href="/tags.html" title="tags">
                <i class="icon-tag"></i>标签</a>
            </li>
        <!-- category dropdown list -->
        <!--  self defined dropdown list -->
        </ul>
        
        <!-- right nav bar -->
        <ul class="nav navbar-nav navbar-right">
        <!-- google custom search -->
       </ul>
    </nav>
</div>
</div>    </div>
    
    <div id="body-content">
<div class="col-md-8 col-md-offset-2">
    <h1 id="content-heading">Clang Basic</h1>
</div>
<div id="niu2-left-container" class="col-md-6 col-md-offset-2 with-right-border">
    <div id="niu2-main-content">
        <h1 id="5d961e">基本类型</h1>
<h2 id="007513">FileManager</h2>
<h3 id="41691b">FileID</h3>
<p>这个<code>FileID</code>只包含一个数据成员<code>int ID</code>，作为其代表文件的索引。通过这个索引，<code>SourceManager</code>可以得到其<code>MemoryBuffer</code>和引入该文件的位置。</p>
<p>这里还提到了加载域，如果当前文件是从当前模块中加载的，则这个<code>ID</code>是正的，否则是负的。实现时是通过一个全局的<code>ID=index++</code>来分配，如果是从其他模块中加载进来的，则设置为<code>ID=-ID-2</code>。如果<code>ID=-1</code>，则认为是非法<code>FileID</code>.</p>
<h3 id="c8787f">FileInfo</h3>
<p><code>FileInfo</code>代表的是一个文件相关的引入文件信息和自身的被引入信息。</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">FileInfo</span>
<span class="p">{</span>
    <span class="c1">/// \brief The location of the #include that brought in this file.</span>
    <span class="c1">///</span>
    <span class="c1">/// This is an invalid SLOC for the main file (top of the #include chain).</span>
    <span class="kt">unsigned</span> <span class="n">IncludeLoc</span><span class="p">;</span>  <span class="c1">// Really a SourceLocation</span>

    <span class="c1">/// \brief Number of FileIDs (files and macros) that were created during</span>
    <span class="c1">/// preprocessing of this #include, including this SLocEntry.</span>
    <span class="c1">///</span>
    <span class="c1">/// Zero means the preprocessor didn&#39;t provide such info for this SLocEntry.</span>
    <span class="kt">unsigned</span> <span class="n">NumCreatedFIDs</span><span class="p">;</span>

    <span class="c1">/// \brief Contains the ContentCache* and the bits indicating the</span>
    <span class="c1">/// characteristic of the file and whether it has #line info, all</span>
    <span class="c1">/// bitmangled together.</span>
    <span class="kt">uintptr_t</span> <span class="n">Data</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<ul>
<li>
<p><code>IncludeLoc</code>:代表当前文件被引入的位置，也就是<code>#include</code>当前文件的那一行代码所在位置。这个位置使用<code>SourceLocation</code>表示的，其实就是一个<code>unsigned</code>。对于<code>cpp</code>文件来说，他是引用链的头，所以他的值为0.</p>
</li>
<li>
<p><code>NumCreatedFIDs</code>:代表的是当前文件所引入的新的<code>#include</code>文件和宏展开的数目。</p>
</li>
<li>
<p><code>Data</code>:这个是一个非常复杂的指针域，注释里面说这个糅合了<code>ContentCache*</code>和两个标志位。</p>
</li>
</ul>
<p>这个<code>FileInfo</code>的构造是通过一个静态函数来做的：</p>
<div class="codehilite"><pre><span></span><span class="k">static</span> <span class="n">FileInfo</span> <span class="nf">get</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">IL</span><span class="p">,</span> <span class="k">const</span> <span class="n">ContentCache</span> <span class="o">*</span><span class="n">Con</span><span class="p">,</span>
    <span class="n">CharacteristicKind</span> <span class="n">FileCharacter</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">FileInfo</span> <span class="n">X</span><span class="p">;</span>
    <span class="n">X</span><span class="p">.</span><span class="n">IncludeLoc</span> <span class="o">=</span> <span class="n">IL</span><span class="p">.</span><span class="n">getRawEncoding</span><span class="p">();</span>
    <span class="n">X</span><span class="p">.</span><span class="n">NumCreatedFIDs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">X</span><span class="p">.</span><span class="n">Data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">Con</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">((</span><span class="n">X</span><span class="p">.</span><span class="n">Data</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;ContentCache pointer insufficiently aligned&quot;</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">FileCharacter</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;invalid file character&quot;</span><span class="p">);</span>
    <span class="n">X</span><span class="p">.</span><span class="n">Data</span> <span class="o">|=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">FileCharacter</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">X</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里的<code>CharacteristicKind</code>是一个很简单的枚举类，用来指明当前文件是用户文件还是系统文件还是通过<code>extern C</code>引入的系统文件：</p>
<div class="codehilite"><pre><span></span><span class="k">enum</span> <span class="n">CharacteristicKind</span>
<span class="p">{</span>
    <span class="n">C_User</span><span class="p">,</span> <span class="n">C_System</span><span class="p">,</span> <span class="n">C_ExternCSystem</span>
<span class="p">};</span>
</pre></div>


<h3 id="a71181">ContentCache</h3>
<p><code>clang</code>为每一个读入的文件都提供了一个<code>ContentCache</code>结构来管理缓存：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nf">LLVM_ALIGNAS</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="n">ContentCache</span>
<span class="p">{</span>
    <span class="k">enum</span> <span class="n">CCFlags</span>
    <span class="p">{</span>
        <span class="c1">/// \brief Whether the buffer is invalid.</span>
        <span class="n">InvalidFlag</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">,</span>
        <span class="c1">/// \brief Whether the buffer should not be freed on destruction.</span>
        <span class="n">DoNotFreeFlag</span> <span class="o">=</span> <span class="mh">0x02</span>
    <span class="p">};</span>

    <span class="c1">/// \brief The actual buffer containing the characters from the input</span>
    <span class="c1">/// file.</span>
    <span class="c1">///</span>
    <span class="c1">/// This is owned by the ContentCache object.  The bits indicate</span>
    <span class="c1">/// whether the buffer is invalid.</span>
    <span class="k">mutable</span> <span class="n">llvm</span><span class="o">::</span><span class="n">PointerIntPair</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">MemoryBuffer</span> <span class="o">*</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">Buffer</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="kt">unsigned</span> <span class="nl">NumLines</span> <span class="p">:</span> <span class="mi">31</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">FileEntry</span> <span class="o">*</span><span class="n">OrigEntry</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">FileEntry</span> <span class="o">*</span><span class="n">ContentsEntry</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="o">*</span><span class="n">SourceLineCache</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="nl">BufferOverridden</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="nl">IsSystemFile</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里的<code>CCFlags</code>是标志位，存储在<code>llvm::PointerIntPair&lt;llvm::MemoryBuffer *, 2&gt;</code>的后两位中。这个<code>PointerIntPair&lt;T*, unsinged num&gt;</code>是一个压缩指针，代表的是该指针指向一个对齐分配的对象T，同时该指针的后num位作为标志位使用。一般来说，对象类型分配都是按照8字节对齐的，所以可以使用的位只有三位，因此<span class="math">\(num\le 3\)</span>，使用时先占用高位，然后再使用低位。这样我们就可以处理嵌套的<code>PointIntPair</code>，如<code>PointIntPair&lt;PointIntPair&lt;T,2&gt;,1&gt;</code> 这种，否则按照低位优先就完全错了。</p>
<p>这里有一个不怎么好理解的<code>OrigEntry</code>和<code>ContentEntry</code>：<code>OrigEntry</code>代表的是当前文件的句柄，而<code>ContentEntry</code>代表的是实际内容来源的文件句柄，这两者一般是相同的。如果当前文件是在内存中建立的临时文件的话，<code>origEntry</code>可以是空的。如果当前文件被另外一个文件的内容覆盖了的话，<code>ContentEntry</code>就是覆盖文件的句柄。</p>
<p>对于<code>ContentCache</code>具体包含的内容，存储在<code>SourceLineCache</code>这个数据成员中，指向缓存的初始位置。这是一个<code>bump the pointer</code>，具体的不怎么清楚，涉及到自动内存管理相关。同时用<code>NumLines</code>记录缓存中的行数。<code>BufferOverridden</code>代表的是当前缓存是否最后将写回相关文件。</p>
<p>在这一层又一层的封装下，最后<code>SourceManager</code>中的处理就简单多了：</p>
<div class="codehilite"><pre><span></span><span class="n">llvm</span><span class="o">::</span><span class="n">MemoryBuffer</span> <span class="o">*</span><span class="n">SourceManager</span><span class="o">::</span><span class="n">getMemoryBufferForFile</span><span class="p">(</span><span class="k">const</span> <span class="n">FileEntry</span> <span class="o">*</span><span class="n">File</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="o">*</span><span class="n">Invalid</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">SrcMgr</span><span class="o">::</span><span class="n">ContentCache</span> <span class="o">*</span><span class="n">IR</span> <span class="o">=</span> <span class="n">getOrCreateContentCache</span><span class="p">(</span><span class="n">File</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">IR</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;getOrCreateContentCache() cannot return NULL&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">IR</span><span class="o">-&gt;</span><span class="n">getBuffer</span><span class="p">(</span><span class="n">Diag</span><span class="p">,</span> <span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">SourceLocation</span><span class="p">(),</span> <span class="n">Invalid</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>在从<code>ContentCache</code>中获得<code>MemoryBuffer</code>的函数比较复杂，就先分部分介绍。其函数签名如下：</p>
<div class="codehilite"><pre><span></span><span class="n">llvm</span><span class="o">::</span><span class="n">MemoryBuffer</span> <span class="o">*</span><span class="n">ContentCache</span><span class="o">::</span><span class="n">getBuffer</span><span class="p">(</span><span class="n">DiagnosticsEngine</span> <span class="o">&amp;</span><span class="n">Diag</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">SourceManager</span> <span class="o">&amp;</span><span class="n">SM</span><span class="p">,</span>
    <span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="o">*</span><span class="n">Invalid</span><span class="p">)</span> <span class="k">const</span>
</pre></div>


<p>首先，我们并不能直接返回<code>ContentCache</code>所存储的 <code>MemoryBuffer</code>的指针。因为文件的<code>MemoryBuffer</code>是延迟构造的，只有在需要的时候才会分配这些资源，否则整个内存空间就炸了。</p>
<p>所以我们首先需要判断<code>ContentCache</code>保存的这个内部<code>memoryBuffer</code>指针是否是有效的，如果有效则直接返回，否则再建立一个<code>MemoryBuffer</code>，然后再返回。</p>
<div class="codehilite"><pre><span></span><span class="c1">// Lazily create the Buffer for ContentCaches that wrap files.  If we already</span>
<span class="c1">// computed it, just return what we have.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Buffer</span><span class="p">.</span><span class="n">getPointer</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">ContentsEntry</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Invalid</span><span class="p">)</span>
        <span class="o">*</span><span class="n">Invalid</span> <span class="o">=</span> <span class="n">isBufferInvalid</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">Buffer</span><span class="p">.</span><span class="n">getPointer</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">isVolatile</span> <span class="o">=</span> <span class="n">SM</span><span class="p">.</span><span class="n">userFilesAreVolatile</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IsSystemFile</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">BufferOrError</span> <span class="o">=</span>
    <span class="n">SM</span><span class="p">.</span><span class="n">getFileManager</span><span class="p">().</span><span class="n">getBufferForFile</span><span class="p">(</span><span class="n">ContentsEntry</span><span class="p">,</span> <span class="n">isVolatile</span><span class="p">);</span>
</pre></div>


<p>如果这个操作返回的并不是<code>MemoryBuffer</code>，而是错误的话(基本可以肯定是源文件不见了被删了)，我们需要做一些错误处理：</p>
<div class="codehilite"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">BufferOrError</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">StringRef</span> <span class="n">FillStr</span><span class="p">(</span><span class="s">&quot;&lt;&lt;&lt;MISSING SOURCE FILE&gt;&gt;&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">Buffer</span><span class="p">.</span><span class="n">setPointer</span><span class="p">(</span><span class="n">MemoryBuffer</span><span class="o">::</span><span class="n">getNewUninitMemBuffer</span><span class="p">(</span>
        <span class="n">ContentsEntry</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">(),</span> <span class="s">&quot;&lt;invalid&gt;&quot;</span><span class="p">).</span><span class="n">release</span><span class="p">());</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">Ptr</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">Buffer</span><span class="p">.</span><span class="n">getPointer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getBufferStart</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">ContentsEntry</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">Ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">FillStr</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">FillStr</span><span class="p">.</span><span class="n">size</span><span class="p">()];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Diag</span><span class="p">.</span><span class="n">isDiagnosticInFlight</span><span class="p">())</span>
        <span class="n">Diag</span><span class="p">.</span><span class="n">SetDelayedDiagnostic</span><span class="p">(</span><span class="n">diag</span><span class="o">::</span><span class="n">err_cannot_open_file</span><span class="p">,</span>
            <span class="n">ContentsEntry</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">(),</span>
            <span class="n">BufferOrError</span><span class="p">.</span><span class="n">getError</span><span class="p">().</span><span class="n">message</span><span class="p">());</span>
    <span class="k">else</span>
        <span class="n">Diag</span><span class="p">.</span><span class="n">Report</span><span class="p">(</span><span class="n">Loc</span><span class="p">,</span> <span class="n">diag</span><span class="o">::</span><span class="n">err_cannot_open_file</span><span class="p">)</span>
        <span class="o">&lt;&lt;</span> <span class="n">ContentsEntry</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">BufferOrError</span><span class="p">.</span><span class="n">getError</span><span class="p">().</span><span class="n">message</span><span class="p">();</span>

    <span class="n">Buffer</span><span class="p">.</span><span class="n">setInt</span><span class="p">(</span><span class="n">Buffer</span><span class="p">.</span><span class="n">getInt</span><span class="p">()</span> <span class="o">|</span> <span class="n">InvalidFlag</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Invalid</span><span class="p">)</span> <span class="o">*</span><span class="n">Invalid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">Buffer</span><span class="p">.</span><span class="n">getPointer</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p>主要的操作就是分配一个<code>MemoryBuffer</code>，这个<code>MemoryBuffer</code>的名字就是<code>&lt;invalid&gt;</code>，其中的内容就是错误信息的循环填充。同时向错误诊断管理器中报告错误，最后返回这个错误的<code>MemoryBuffer</code>。</p>
<p>如果没有返回错误，则检查我们新建的<code>MemoryBuffer</code>的大小是否等于我们所期待的大小。如果不是的话，说明源文件被修改了，向诊断管理器中报告错误，同时返回这个<code>MemoryBuffer</code>。如果是的话，再检查文件头的UTF Byte Order Mark。</p>
<div class="codehilite"><pre><span></span><span class="c1">// If the buffer is valid, check to see if it has a UTF Byte Order Mark</span>
<span class="c1">// (BOM).  We only support UTF-8 with and without a BOM right now.  See</span>
<span class="c1">// http://en.wikipedia.org/wiki/Byte_order_mark for more information.</span>
<span class="n">StringRef</span> <span class="n">BufStr</span> <span class="o">=</span> <span class="n">Buffer</span><span class="p">.</span><span class="n">getPointer</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getBuffer</span><span class="p">();</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">InvalidBOM</span> <span class="o">=</span> <span class="n">llvm</span><span class="o">::</span><span class="n">StringSwitch</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">BufStr</span><span class="p">)</span>
    <span class="p">.</span><span class="n">StartsWith</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\xFE\xFF</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;UTF-16 (BE)&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">StartsWith</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\xFF\xFE</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;UTF-16 (LE)&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">StartsWith</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\x00\x00\xFE\xFF</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;UTF-32 (BE)&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">StartsWith</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\xFF\xFE\x00\x00</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;UTF-32 (LE)&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">StartsWith</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\x2B\x2F\x76</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;UTF-7&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">StartsWith</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\xF7\x64\x4C</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;UTF-1&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">StartsWith</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\xDD\x73\x66\x73</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;UTF-EBCDIC&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">StartsWith</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\x0E\xFE\xFF</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;SDSU&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">StartsWith</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\xFB\xEE\x28</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;BOCU-1&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">StartsWith</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\x84\x31\x95\x33</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;GB-18030&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Default</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>
</pre></div>


<p>如果并不是合法的BOM，则继续报错。</p>
<p>首先获得文件对应的<code>ContentCache</code>，然后再由<code>ContentCache</code>获得<code>MemoryBuffer</code>。</p>
<p>如果文件的内容被<code>MemoryBuffer</code>给重写了，就将对应的<code>ContentCache</code>里面的<code>MemoryBuffer</code>替换一下，然后往缓存替换表里注册一下。这里又涉及到了延迟构造的问题，真烦。</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">SourceManager</span><span class="o">::</span><span class="n">overrideFileContents</span><span class="p">(</span><span class="k">const</span> <span class="n">FileEntry</span> <span class="o">*</span><span class="n">SourceFile</span><span class="p">,</span>
    <span class="n">llvm</span><span class="o">::</span><span class="n">MemoryBuffer</span> <span class="o">*</span><span class="n">Buffer</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">DoNotFree</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">SrcMgr</span><span class="o">::</span><span class="n">ContentCache</span> <span class="o">*</span><span class="n">IR</span> <span class="o">=</span> <span class="n">getOrCreateContentCache</span><span class="p">(</span><span class="n">SourceFile</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">IR</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;getOrCreateContentCache() cannot return NULL&quot;</span><span class="p">);</span>

    <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">SrcMgr</span><span class="o">::</span><span class="n">ContentCache</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">IR</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">replaceBuffer</span><span class="p">(</span><span class="n">Buffer</span><span class="p">,</span> <span class="n">DoNotFree</span><span class="p">);</span>
    <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">SrcMgr</span><span class="o">::</span><span class="n">ContentCache</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">IR</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">BufferOverridden</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="n">getOverriddenFilesInfo</span><span class="p">().</span><span class="n">OverriddenFilesWithBuffer</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">SourceFile</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>如果文件内容是被另外一个文件所覆盖的话，处理也是比较简单，直接向文件覆盖表中添加映射就可以了。</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">SourceManager</span><span class="o">::</span><span class="n">overrideFileContents</span><span class="p">(</span><span class="k">const</span> <span class="n">FileEntry</span> <span class="o">*</span><span class="n">SourceFile</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">FileEntry</span> <span class="o">*</span><span class="n">NewFile</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">SourceFile</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">()</span> <span class="o">==</span> <span class="n">NewFile</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
        <span class="s">&quot;Different sizes, use the FileManager to create a virtual file with &quot;</span>
        <span class="s">&quot;the correct size&quot;</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">FileInfos</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">SourceFile</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
        <span class="s">&quot;This function should be called at the initialization stage, before &quot;</span>
        <span class="s">&quot;any parsing occurs.&quot;</span><span class="p">);</span>
    <span class="n">getOverriddenFilesInfo</span><span class="p">().</span><span class="n">OverriddenFiles</span><span class="p">[</span><span class="n">SourceFile</span><span class="p">]</span> <span class="o">=</span> <span class="n">NewFile</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>搞笑的是这里还提供了撤销操作：</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">SourceManager</span><span class="o">::</span><span class="n">disableFileContentsOverride</span><span class="p">(</span><span class="k">const</span> <span class="n">FileEntry</span> <span class="o">*</span><span class="n">File</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isFileOverridden</span><span class="p">(</span><span class="n">File</span><span class="p">))</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">SrcMgr</span><span class="o">::</span><span class="n">ContentCache</span> <span class="o">*</span><span class="n">IR</span> <span class="o">=</span> <span class="n">getOrCreateContentCache</span><span class="p">(</span><span class="n">File</span><span class="p">);</span>
    <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">SrcMgr</span><span class="o">::</span><span class="n">ContentCache</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">IR</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">replaceBuffer</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>
    <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">SrcMgr</span><span class="o">::</span><span class="n">ContentCache</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">IR</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ContentsEntry</span> <span class="o">=</span> <span class="n">IR</span><span class="o">-&gt;</span><span class="n">OrigEntry</span><span class="p">;</span>

    <span class="n">assert</span><span class="p">(</span><span class="n">OverriddenFilesInfo</span><span class="p">);</span>
    <span class="n">OverriddenFilesInfo</span><span class="o">-&gt;</span><span class="n">OverriddenFiles</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">File</span><span class="p">);</span>
    <span class="n">OverriddenFilesInfo</span><span class="o">-&gt;</span><span class="n">OverriddenFilesWithBuffer</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">File</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h2 id="6c9f9e">SourceLocation</h2>
<p>SourceLocation：Encodes a location in the source. The SourceManager can decode this to get at the full include stack, line and column information.在编译器中需要用到的三个“重要”Location：行号，列号，声明和调用文件路径，都与SourceManager有关，其中行号和列号用SourceLocation表示。<code>clang</code>中，将<code>SourceLocation</code>分为了三种类型:</p>
<ul>
<li>
<p>Spelling Location 宏的定义位置</p>
</li>
<li>
<p>Expansion Location 宏的展开位置，即使用位置</p>
</li>
<li>
<p>Presumed Location  根据<code>#line</code>导言调整之后的展开位置</p>
</li>
</ul>
<p>同一个物理位置他的<code>expansion location</code>与<code>presumed location</code>只有行号不一样，这种差异是<code>#line</code>导言造成的。举个例子来说，在下面的代码中</p>
<div class="codehilite"><pre><span></span><span class="cp">#define min(x,y) (x)&gt;(y)?(y):(x)</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span><span class="kt">char</span><span class="o">**</span><span class="n">argv</span><span class="p">){</span>

<span class="cp">#line 4</span>
<span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="n">min</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>第6行的数字2的<code>spelling location</code>是第一行，其<code>expansion location</code>是第六行，而<code>presumed location</code>是第4行。</p>
<h3 id="6c9f9e_1">SourceLocation</h3>
<p>SourceLocation是一个偏移，整个type大小为四个字节（4==sizeof（SourceLocation）），SourceRange是两个SourceLocation组成的区间。<code>SourceLocation</code>的具体定义如下，数据成员只有一个<code>unsigned int</code></p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">SourceLocation</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">ID</span><span class="p">;</span>
    <span class="k">enum</span> <span class="o">:</span> <span class="kt">unsigned</span>
    <span class="p">{</span>
        <span class="n">MacroIDBit</span> <span class="o">=</span> <span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>


<p>这个ID的最高位是用来表明当前Location是宏展开还是正常文本，同时有效的SourceLocation的ID不为0。实现时是这样做的，一个全局的递增<code>index</code>作为<code>ID</code>的分配值，如果这个是文件中的文本，则<code>index=ID</code>，否则是宏的话<code>index=-ID-2</code>。根据这个性质，这个类内置了几个函数，比较简单，分别是判断是否有效和是否是宏：</p>
<div class="codehilite"><pre><span></span><span class="n">SourceLocation</span><span class="p">()</span> <span class="o">:</span> <span class="n">ID</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
<span class="c1">//默认无效Location</span>
<span class="kt">bool</span> <span class="n">isFileID</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">ID</span> <span class="o">&amp;</span> <span class="n">MacroIDBit</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">bool</span> <span class="n">isMacroID</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">ID</span> <span class="o">&amp;</span> <span class="n">MacroIDBit</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">/// \brief Return true if this is a valid SourceLocation object.</span>
<span class="c1">///</span>
<span class="c1">/// Invalid SourceLocations are often used when events have no corresponding</span>
<span class="c1">/// location in the source (e.g. a diagnostic is required for a command line</span>
<span class="c1">/// option).</span>
<span class="kt">bool</span> <span class="n">isValid</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ID</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">bool</span> <span class="n">isInvalid</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ID</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
</pre></div>


<p>作为无效的Location，一般是用来组成SourceRange的end端的，表明当前并不需要这个end，一般是处理单token的时候。</p>
<p>为了构造有效的SourceLocation，需要用到另外的几个静态构造函数：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief Return the offset into the manager&#39;s global input view.</span>
<span class="kt">unsigned</span> <span class="nf">getOffset</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">ID</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MacroIDBit</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">SourceLocation</span> <span class="nf">getFileLoc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ID</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">((</span><span class="n">ID</span> <span class="o">&amp;</span> <span class="n">MacroIDBit</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Ran out of source locations!&quot;</span><span class="p">);</span>
    <span class="n">SourceLocation</span> <span class="n">L</span><span class="p">;</span>
    <span class="n">L</span><span class="p">.</span><span class="n">ID</span> <span class="o">=</span> <span class="n">ID</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">L</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">SourceLocation</span> <span class="nf">getMacroLoc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ID</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">((</span><span class="n">ID</span> <span class="o">&amp;</span> <span class="n">MacroIDBit</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Ran out of source locations!&quot;</span><span class="p">);</span>
    <span class="n">SourceLocation</span> <span class="n">L</span><span class="p">;</span>
    <span class="n">L</span><span class="p">.</span><span class="n">ID</span> <span class="o">=</span> <span class="n">MacroIDBit</span> <span class="o">|</span> <span class="n">ID</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">L</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>虽然这几个都是<code>private</code>的，不过由于声明了几个友元类，所以还是可以调用的。</p>
<p>对于<code>SourceRange</code>来说，很简单，就是两个<code>SourceLocation</code>的复合。</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">SourceRange</span>
<span class="p">{</span>
    <span class="n">SourceLocation</span> <span class="n">B</span><span class="p">;</span>
    <span class="n">SourceLocation</span> <span class="n">E</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>相关的代码也比较简单直白，基本都是一些<code>get,set valid</code>方法，就懒得说了。</p>
<h3 id="1460b6">CharSourceRange</h3>
<p>这里还定义了一个<code>CharSourceRange</code>，在<code>SourceRange</code>上加了一个<code>bool IsTokenRange</code>作为一个标志位。</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">CharSourceRange</span>
<span class="p">{</span>
    <span class="n">SourceRange</span> <span class="n">Range</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">IsTokenRange</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>当这个<code>IsTokenRange</code>为真时，这里的<code>Range</code>的<code>end</code>指明的是我们所指代区域内最后一个<code>token</code>的第一个字节的<code>SourceLocation</code>；否则指的是该区域内最后一个字节的<code>SourceLocation</code>。</p>
<h3 id="8f4b07">FullSourceLoc</h3>
<p>一个<code>SourceLocation</code>只包含一个<code>ID</code>，其具体意义需要相应的<code>SourceManager</code>来管理。<code>SourceLocation</code>与<code>SourceManager</code>的复合体为<code>FullSourceLoc</code></p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">FullSourceLoc</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SourceLocation</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">SourceManager</span> <span class="o">*</span><span class="n">SrcMgr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这个类型主要是用来传递<code>SourceLocation</code>和<code>SourceManager</code>这两个参数的，打包传递。</p>
<p>事实上很多操作都被打包进了这个<code>FullSourceLoc</code>之中，主要的就是行号、列号、文件名、宏定义位置、宏展开位置等</p>
<div class="codehilite"><pre><span></span><span class="n">FileID</span> <span class="nf">getFileID</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="n">FullSourceLoc</span> <span class="nf">getExpansionLoc</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="n">FullSourceLoc</span> <span class="nf">getSpellingLoc</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="nf">getExpansionLineNumber</span><span class="p">(</span><span class="kt">bool</span> <span class="o">*</span><span class="n">Invalid</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="nf">getExpansionColumnNumber</span><span class="p">(</span><span class="kt">bool</span> <span class="o">*</span><span class="n">Invalid</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="nf">getSpellingLineNumber</span><span class="p">(</span><span class="kt">bool</span> <span class="o">*</span><span class="n">Invalid</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="nf">getSpellingColumnNumber</span><span class="p">(</span><span class="kt">bool</span> <span class="o">*</span><span class="n">Invalid</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">getCharacterData</span><span class="p">(</span><span class="kt">bool</span> <span class="o">*</span><span class="n">Invalid</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>


<p>不过这些操作都被委托进了<code>SourceManager</code>的对应操作中，这些函数只是作为转接存在的。。</p>
<h3 id="b8ce1f">PresumedLoc</h3>
<p>这个<code>PresumedLoc</code>其实也是一个打包类，因为<code>SourceLocation</code>就可以判断是不是经过 <code>#line</code>导言调整过的行号了，这个主要是通过<code>SourceManager</code>来进行。但是作为参数传递出去的时候，不想让另外一方操作<code>SourceManager</code>，所以把相关信息都提取出来了，作为了 <code>PresumedLoc</code>:</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">PresumedLoc</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Filename</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">Line</span><span class="p">,</span> <span class="n">Col</span><span class="p">;</span>
    <span class="n">SourceLocation</span> <span class="n">IncludeLoc</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>事实上这个<code>PresumedLoc</code>就是以一个<code>SourceLocation</code>通过<code>SourceManager</code>构造出来的，非常复杂：</p>
<div class="codehilite"><pre><span></span><span class="n">PresumedLoc</span> <span class="n">SourceManager</span><span class="o">::</span><span class="n">getPresumedLoc</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">UseLineDirectives</span><span class="p">)</span> <span class="k">const</span>
</pre></div>


<p>对于这个函数的具体逻辑我们在这里先不详细解释，因为这个依赖于<code>SourceManager</code>的定义，需要先介绍<code>SourceManager</code>的相关操作。</p>
<h2 id="bc4716">LineTable</h2>
<p>这个<code>LineTable</code>是用来处理<code>#line</code>导言的，所以需要记录所有文件中该类型导言的相关信息，每一个信息都存储为一个<code>LineEntry</code>结构，记录了改导言所在文件的行位置<code>FileOffset</code>、该导言自定义的行号<code>LineNo</code>和文件名<code>FilenameID</code>。</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">LineEntry</span>
<span class="p">{</span>
    <span class="c1">/// \brief The offset in this file that the line entry occurs at.</span>
    <span class="kt">unsigned</span> <span class="n">FileOffset</span><span class="p">;</span>

    <span class="c1">/// \brief The presumed line number of this line entry: #line 4.</span>
    <span class="kt">unsigned</span> <span class="n">LineNo</span><span class="p">;</span>

    <span class="c1">/// \brief The ID of the filename identified by this line entry:</span>
    <span class="c1">/// #line 4 &quot;foo.c&quot;.  This is -1 if not specified.</span>
    <span class="kt">int</span> <span class="n">FilenameID</span><span class="p">;</span>

    <span class="c1">/// \brief Set the 0 if no flags, 1 if a system header,</span>
    <span class="n">SrcMgr</span><span class="o">::</span><span class="n">CharacteristicKind</span> <span class="n">FileKind</span><span class="p">;</span>

    <span class="c1">/// \brief The offset of the virtual include stack location,</span>
    <span class="c1">/// which is manipulated by GNU linemarker directives.</span>
    <span class="c1">///</span>
    <span class="c1">/// If this is 0 then there is no virtual #includer.</span>
    <span class="c1">//都是GNU自己做得死</span>
    <span class="kt">unsigned</span> <span class="n">IncludeOffset</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>按照惯例，这个类型的构造仍然是通过<code>static</code>来做的，就是简单的字段赋值，不再说明。</p>
<p>而所有的<code>LineEntry</code>信息都维护在一个<code>LineTableInfo</code>中，记录了每一个文件中所包含的<code>LineEntry</code>信息。</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief Used to hold and unique data used to represent #line information.</span>
<span class="k">class</span> <span class="nc">LineTableInfo</span>
<span class="p">{</span>
    <span class="c1">/// \brief Map used to assign unique IDs to filenames in #line directives. </span>
    <span class="c1">///</span>
    <span class="c1">/// This allows us to unique the filenames that</span>
    <span class="c1">/// frequently reoccur and reference them with indices.  FilenameIDs holds</span>
    <span class="c1">/// the mapping from string -&gt; ID, and FilenamesByID holds the mapping of ID</span>
    <span class="c1">/// to string.</span>
    <span class="n">llvm</span><span class="o">::</span><span class="n">StringMap</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">llvm</span><span class="o">::</span><span class="n">BumpPtrAllocator</span><span class="o">&gt;</span> <span class="n">FilenameIDs</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">StringMapEntry</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;*&gt;</span> <span class="n">FilenamesByID</span><span class="p">;</span>

    <span class="c1">/// \brief Map from FileIDs to a list of line entries (sorted by the offset</span>
    <span class="c1">/// at which they occur in the file).</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">FileID</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LineEntry</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">LineEntries</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里的<code>FilenameIDs</code>和<code>FilenamesByID</code>是一个典型的互索引结构，新的<code>Filename</code>首先通过 <code>FilenamesByID.size()</code>获得其<code>ID</code>，然后将这二元组插入到<code>FilenameIDs</code>中。根据所获得的    <code>llvm::StringMapEntry</code>再<code>push_back</code>到<code>FilenamesByID</code>中。所以这里管理了<code>FileID</code>的注册于发放。</p>
<p>在使用的时候，我们希望得到的是给定<code>expansion</code>的行号，如何获得其在<code>presumed</code>中的行号。这个操作需要获得在当前文件中离当前行最近的<code>LineEntry</code>信息，基本就是一个二分查找过程。</p>
<div class="codehilite"><pre><span></span><span class="k">const</span> <span class="n">LineEntry</span> <span class="o">*</span><span class="n">LineTableInfo</span><span class="o">::</span><span class="n">FindNearestLineEntry</span><span class="p">(</span><span class="n">FileID</span> <span class="n">FID</span><span class="p">,</span>
    <span class="kt">unsigned</span> <span class="n">Offset</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LineEntry</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Entries</span> <span class="o">=</span> <span class="n">LineEntries</span><span class="p">[</span><span class="n">FID</span><span class="p">];</span>
    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">Entries</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;No #line entries for this FID after all!&quot;</span><span class="p">);</span>

    <span class="c1">// It is very common for the query to be after the last #line, check this</span>
    <span class="c1">// first.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Entries</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">FileOffset</span> <span class="o">&lt;=</span> <span class="n">Offset</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">&amp;</span><span class="n">Entries</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>

    <span class="c1">// Do a binary search to find the maximal element that is still before Offset.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LineEntry</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">I</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">upper_bound</span><span class="p">(</span><span class="n">Entries</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">Entries</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">Offset</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">I</span> <span class="o">==</span> <span class="n">Entries</span><span class="p">.</span><span class="n">begin</span><span class="p">())</span> <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">&amp;*--</span><span class="n">I</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h2 id="3525a6">ExpansionInfo</h2>
<p>这个<code>ExpansionInfo</code>代表了宏展开相关的信息：展开位置和宏定义位置。</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">ExpansionInfo</span>
<span class="p">{</span>
    <span class="c1">// Really these are all SourceLocations.</span>
    <span class="c1">/// \brief Where the spelling for the token can be found.</span>
    <span class="kt">unsigned</span> <span class="n">SpellingLoc</span><span class="p">;</span>

    <span class="c1">/// In a macro expansion, ExpansionLocStart and ExpansionLocEnd</span>
    <span class="c1">/// indicate the start and end of the expansion. In object-like macros,</span>
    <span class="c1">/// they will be the same. In a function-like macro expansion, the start</span>
    <span class="c1">/// will be the identifier and the end will be the &#39;)&#39;. Finally, in</span>
    <span class="c1">/// macro-argument instantiations, the end will be &#39;SourceLocation()&#39;, an</span>
    <span class="c1">/// invalid location.</span>
    <span class="kt">unsigned</span> <span class="n">ExpansionLocStart</span><span class="p">,</span> <span class="n">ExpansionLocEnd</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>上面的注释已经说的很清楚了，</p>
<ul>
<li>
<p>如果是简单的文本替换，则<code>start</code>和<code>end</code>是相等的。</p>
</li>
<li>
<p>如果是函数调用宏展开，则<code>end</code>指向的是<code>)</code>。</p>
</li>
<li>
<p>如果是宏参数展开，则<code>end</code>是非法<code>Location</code>，此时他的值为0.</p>
</li>
</ul>
<p>这个类型的默认构造函数也是无效的，构造都委托到了下面这个静态函数里面：</p>
<div class="codehilite"><pre><span></span><span class="k">static</span> <span class="n">ExpansionInfo</span> <span class="nf">create</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">SpellingLoc</span><span class="p">,</span>
    <span class="n">SourceLocation</span> <span class="n">Start</span><span class="p">,</span> <span class="n">SourceLocation</span> <span class="n">End</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ExpansionInfo</span> <span class="n">X</span><span class="p">;</span>
    <span class="n">X</span><span class="p">.</span><span class="n">SpellingLoc</span> <span class="o">=</span> <span class="n">SpellingLoc</span><span class="p">.</span><span class="n">getRawEncoding</span><span class="p">();</span>
    <span class="n">X</span><span class="p">.</span><span class="n">ExpansionLocStart</span> <span class="o">=</span> <span class="n">Start</span><span class="p">.</span><span class="n">getRawEncoding</span><span class="p">();</span>
    <span class="n">X</span><span class="p">.</span><span class="n">ExpansionLocEnd</span> <span class="o">=</span> <span class="n">End</span><span class="p">.</span><span class="n">getRawEncoding</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">X</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>对于参数展开来说，那就直接调用上面这个函数了，非常机制啊：</p>
<div class="codehilite"><pre><span></span><span class="k">static</span> <span class="n">ExpansionInfo</span> <span class="nf">createForMacroArg</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">SpellingLoc</span><span class="p">,</span>
    <span class="n">SourceLocation</span> <span class="n">ExpansionLoc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// We store an intentionally invalid source location for the end of the</span>
    <span class="c1">// expansion range to mark that this is a macro argument ion rather than</span>
    <span class="c1">// a normal one.</span>
    <span class="k">return</span> <span class="n">create</span><span class="p">(</span><span class="n">SpellingLoc</span><span class="p">,</span> <span class="n">ExpansionLoc</span><span class="p">,</span> <span class="n">SourceLocation</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>


<h2 id="f2128a">SLocEntry</h2>
<p>这个类型是一个联合类，包含了<code>FileInfo</code>和<code>ExpansionInfo</code>这两种类型：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">SLocEntry</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">Offset</span><span class="p">;</span>   <span class="c1">// low bit is set for expansion info.</span>
    <span class="k">union</span>
    <span class="p">{</span>
        <span class="n">FileInfo</span> <span class="n">File</span><span class="p">;</span>
        <span class="n">ExpansionInfo</span> <span class="n">Expansion</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>


<p>这里的<code>Offset</code>的最低位用来作为标志位，来区分是哪一个具体类型：</p>
<div class="codehilite"><pre><span></span><span class="kt">unsigned</span> <span class="nf">getOffset</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Offset</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">bool</span> <span class="nf">isExpansion</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Offset</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">bool</span> <span class="nf">isFile</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="n">isExpansion</span><span class="p">();</span> <span class="p">}</span>
</pre></div>


<p>这个类的构造函数也是静态的，主要是这个对象经常需要临时构造，静态处理比较方便。</p>
<div class="codehilite"><pre><span></span><span class="k">static</span> <span class="n">SLocEntry</span> <span class="nf">get</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">Offset</span><span class="p">,</span> <span class="k">const</span> <span class="n">FileInfo</span> <span class="o">&amp;</span><span class="n">FI</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SLocEntry</span> <span class="n">E</span><span class="p">;</span>
    <span class="n">E</span><span class="p">.</span><span class="n">Offset</span> <span class="o">=</span> <span class="n">Offset</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">E</span><span class="p">.</span><span class="n">File</span> <span class="o">=</span> <span class="n">FI</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">E</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">SLocEntry</span> <span class="nf">get</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">Offset</span><span class="p">,</span> <span class="k">const</span> <span class="n">ExpansionInfo</span> <span class="o">&amp;</span><span class="n">Expansion</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SLocEntry</span> <span class="n">E</span><span class="p">;</span>
    <span class="n">E</span><span class="p">.</span><span class="n">Offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">Offset</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">E</span><span class="p">.</span><span class="n">Expansion</span> <span class="o">=</span> <span class="n">Expansion</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">E</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h2 id="390ca7">SourceManager</h2>
<p>这个类是一个非常大的类，管理了所有与源文件相关的资源，同时他也是一个被侵入式引用计数<code>IntrusiveRefPtr</code>管理的资源，因为在其他地方经常有<code>SourceManager</code>的指针副本。</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">SourceManager</span> <span class="o">:</span> <span class="k">public</span> <span class="n">RefCountedBase</span><span class="o">&lt;</span><span class="n">SourceManager</span><span class="o">&gt;</span>
</pre></div>


<h1 id="6478fc">资源管理</h1>
<h2 id="51bef6">资源句柄</h2>
<p>在<code>SourceManager</code>中，首先保存了<code>DiagnosticEngine</code>和<code>FileManager</code>这两个引用，至此源文件管理相关的大类已经集合完毕。</p>
<div class="codehilite"><pre><span></span><span class="n">DiagnosticsEngine</span> <span class="o">&amp;</span><span class="n">Diag</span><span class="p">;</span>

<span class="n">FileManager</span> <span class="o">&amp;</span><span class="n">FileMgr</span><span class="p">;</span>
</pre></div>


<p>首先记录在案的是文件<code>FileEntry</code>与相应缓存<code>ContentCache</code>之间的映射，这是通过一个<code>map</code>来实现的。</p>
<div class="codehilite"><pre><span></span><span class="n">llvm</span><span class="o">::</span><span class="n">DenseMap</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">FileEntry</span><span class="o">*</span><span class="p">,</span> <span class="n">SrcMgr</span><span class="o">::</span><span class="n">ContentCache</span><span class="o">*&gt;</span> <span class="n">FileInfos</span><span class="p">;</span>
</pre></div>


<p>对于文件被重写的情况，<code>SourceManager</code>也记录了这些信息</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">OverriddenFilesInfoTy</span>
<span class="p">{</span>
    <span class="c1">/// \brief Files that have been overridden with the contents from another</span>
    <span class="c1">/// file.</span>
    <span class="n">llvm</span><span class="o">::</span><span class="n">DenseMap</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">FileEntry</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">FileEntry</span> <span class="o">*&gt;</span> <span class="n">OverriddenFiles</span><span class="p">;</span>
    <span class="c1">/// \brief Files that were overridden with a memory buffer.</span>
    <span class="n">llvm</span><span class="o">::</span><span class="n">DenseSet</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">FileEntry</span> <span class="o">*&gt;</span> <span class="n">OverriddenFilesWithBuffer</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">/// \brief Lazily create the object keeping overridden files info, since</span>
<span class="c1">/// it is uncommonly used.</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">OverriddenFilesInfoTy</span><span class="o">&gt;</span> <span class="n">OverriddenFilesInfo</span><span class="p">;</span>

<span class="n">OverriddenFilesInfoTy</span> <span class="o">&amp;</span><span class="n">getOverriddenFilesInfo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OverriddenFilesInfo</span><span class="p">)</span>
        <span class="n">OverriddenFilesInfo</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">OverriddenFilesInfoTy</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">OverriddenFilesInfo</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里还设置这个覆盖结构为延迟实例化的，注释里面说这个东西很少用到。但是你们真的缺这两个<code>map,set</code>的内存空间吗！过早优化是万恶之源啊。</p>
<p>这里还管理了所有的<code>ContentCache</code></p>
<div class="codehilite"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SrcMgr</span><span class="o">::</span><span class="n">ContentCache</span><span class="o">*&gt;</span> <span class="n">MemBufferInfos</span><span class="p">;</span>
</pre></div>


<p>同时还对错误处理专门分配了缓存空间</p>
<div class="codehilite"><pre><span></span><span class="c1">// Cache for the &quot;fake&quot; buffer used for error-recovery purposes.</span>
<span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">MemoryBuffer</span><span class="o">&gt;</span> <span class="n">FakeBufferForRecovery</span><span class="p">;</span>

<span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">SrcMgr</span><span class="o">::</span><span class="n">ContentCache</span><span class="o">&gt;</span> <span class="n">FakeContentCacheForRecovery</span><span class="p">;</span>
</pre></div>


<p>对于<code>SlocEntry</code>的管理，分为了两个部分，一个是本模块内的<code>SlocEntry</code>，另外一个是从其他模块中装载进来的<code>SlocEntry</code>，也就是<code>local</code>和<code>loaded</code>之分。</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief The table of SLocEntries that are local to this module.</span>
<span class="c1">///</span>
<span class="c1">/// Positive FileIDs are indexes into this table. Entry 0 indicates an invalid</span>
<span class="c1">/// expansion.</span>
<span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">SrcMgr</span><span class="o">::</span><span class="n">SLocEntry</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="n">LocalSLocEntryTable</span><span class="p">;</span>

<span class="c1">/// \brief The table of SLocEntries that are loaded from other modules.</span>
<span class="c1">///</span>
<span class="c1">/// Negative FileIDs are indexes into this table. To get from ID to an index,</span>
<span class="c1">/// use (-ID - 2).</span>
<span class="k">mutable</span> <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">SrcMgr</span><span class="o">::</span><span class="n">SLocEntry</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="n">LoadedSLocEntryTable</span><span class="p">;</span>
</pre></div>


<p>还有一个位图来表示外部的<code>SlocEntry</code>是否真正的加载进来了，看来加载过程是延迟的：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief A bitmap that indicates whether the entries of LoadedSLocEntryTable</span>
<span class="c1">/// have already been loaded from the external source.</span>
<span class="c1">///</span>
<span class="c1">/// Same indexing as LoadedSLocEntryTable.</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">SLocEntryLoaded</span><span class="p">;</span>
</pre></div>


<p><code>SourceManager</code>中也有一个<code>LineTable</code>的指针，用来延迟实例化这个结构。由于延迟实例化导致了每次使用的时候都需要判断是否已经实例化，真是蛋疼。</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief Holds information for #line directives.</span>
<span class="c1">///</span>
<span class="c1">/// This is referenced by indices from SLocEntryTable.</span>
<span class="n">LineTableInfo</span> <span class="o">*</span><span class="n">LineTable</span><span class="p">;</span>
</pre></div>


<p>对于宏参数的处理，则存储在另外一个<code>Map</code>中：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief Lazily computed map of macro argument chunks to their expanded</span>
<span class="c1">/// source location.</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">SourceLocation</span><span class="o">&gt;</span> <span class="n">MacroArgsMap</span><span class="p">;</span>

<span class="k">mutable</span> <span class="n">llvm</span><span class="o">::</span><span class="n">DenseMap</span><span class="o">&lt;</span><span class="n">FileID</span><span class="p">,</span> <span class="n">MacroArgsMap</span> <span class="o">*&gt;</span> <span class="n">MacroArgsCacheMap</span><span class="p">;</span>
</pre></div>


<p>这里还记录了几个重要的<code>FileID</code>，包括当前文件的和预编译导言区，话说这个预编译导言区是干嘛的？</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief The file ID for the main source file of the translation unit.</span>
<span class="n">FileID</span> <span class="n">MainFileID</span><span class="p">;</span>

<span class="c1">/// \brief The file ID for the precompiled preamble there is one.</span>
<span class="n">FileID</span> <span class="n">PreambleFileID</span><span class="p">;</span>
</pre></div>


<p>对于模块之间的引用与依赖关系，存储于一个<code>vector</code>中。</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief The stack of modules being built, which is used to detect</span>
<span class="c1">/// cycles in the module dependency graph as modules are being built, as</span>
<span class="c1">/// well as to describe why we&#39;re rebuilding a particular module.</span>
<span class="c1">///</span>
<span class="c1">/// There is no way to set this value from the command line. If we ever need</span>
<span class="c1">/// to do so (e.g., if on-demand module construction moves out-of-process),</span>
<span class="c1">/// we can add a cc1-level option to do so.</span>
<span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">FullSourceLoc</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">StoredModuleBuildStack</span><span class="p">;</span>
</pre></div>


<p>这里的<code>pair&lt;string,FullSourceLoc&gt;</code>中的<code>string</code>是模块名称，而<code>FullSourceLoc</code>则是引入模块的位置。</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="nf">pushModuleBuildStack</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">moduleName</span><span class="p">,</span> <span class="n">FullSourceLoc</span> <span class="n">importLoc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">StoredModuleBuildStack</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">moduleName</span><span class="p">.</span><span class="n">str</span><span class="p">(),</span> <span class="n">importLoc</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>


<h2 id="e91e3f">为File构建MemoryBuffer</h2>
<p>为<code>File</code>准备<code>MemoryBuffer</code>分为了好几步来进行。首先记录文件的大小，如果文件是处于编辑状态的话，设置大小为-1。如果文件为打开状态，则调用<code>vfs::getBuffer</code>准备好<code>Buffer</code>，并按照要求选择是否关闭文件，感觉像把文件完整的读进来啊。如果文件没有打开的话，则打开或者建立这个文件，然后获得<code>MemoryBuffer</code>。值得注意的是，这个操作有可能不成功，从而返回错误。具体见下面的代码：</p>
<div class="codehilite"><pre><span></span><span class="n">llvm</span><span class="o">::</span><span class="n">ErrorOr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">MemoryBuffer</span><span class="o">&gt;&gt;</span>
<span class="n">FileManager</span><span class="o">::</span><span class="n">getBufferForFile</span><span class="p">(</span><span class="k">const</span> <span class="n">FileEntry</span> <span class="o">*</span><span class="n">Entry</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isVolatile</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">ShouldCloseOpenFile</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">FileSize</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">();</span>
    <span class="c1">// If there&#39;s a high enough chance that the file have changed since we</span>
    <span class="c1">// got its size, force a stat before opening it.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isVolatile</span><span class="p">)</span>
        <span class="n">FileSize</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Filename</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">();</span>
    <span class="c1">// If the file is already open, use the open file descriptor.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Entry</span><span class="o">-&gt;</span><span class="n">File</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">Result</span> <span class="o">=</span>
            <span class="n">Entry</span><span class="o">-&gt;</span><span class="n">File</span><span class="o">-&gt;</span><span class="n">getBuffer</span><span class="p">(</span><span class="n">Filename</span><span class="p">,</span> <span class="n">FileSize</span><span class="p">,</span>
                <span class="cm">/*RequiresNullTerminator=*/</span><span class="nb">true</span><span class="p">,</span> <span class="n">isVolatile</span><span class="p">);</span>
        <span class="c1">// FIXME: we need a set of APIs that can make guarantees about whether a</span>
        <span class="c1">// FileEntry is open or not.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ShouldCloseOpenFile</span><span class="p">)</span>
            <span class="n">Entry</span><span class="o">-&gt;</span><span class="n">closeFile</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">Result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Otherwise, open the file.</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">FileSystemOpts</span><span class="p">.</span><span class="n">WorkingDir</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">FS</span><span class="o">-&gt;</span><span class="n">getBufferForFile</span><span class="p">(</span><span class="n">Filename</span><span class="p">,</span> <span class="n">FileSize</span><span class="p">,</span>
            <span class="cm">/*RequiresNullTerminator=*/</span><span class="nb">true</span><span class="p">,</span> <span class="n">isVolatile</span><span class="p">);</span>

    <span class="n">SmallString</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;</span> <span class="n">FilePath</span><span class="p">(</span><span class="n">Entry</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">());</span>
    <span class="n">FixupRelativePath</span><span class="p">(</span><span class="n">FilePath</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">FS</span><span class="o">-&gt;</span><span class="n">getBufferForFile</span><span class="p">(</span><span class="n">FilePath</span><span class="p">,</span> <span class="n">FileSize</span><span class="p">,</span>
        <span class="cm">/*RequiresNullTerminator=*/</span><span class="nb">true</span><span class="p">,</span> <span class="n">isVolatile</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h2 id="2819f8">为File构建ContentCache</h2>
<p>对于每个文件来说，其<code>ContentCache</code>就是其内容的内存镜像。我们不能把所有的文件直接装载进内存中，这样会爆内存的，所以需要延迟装载这个<code>ContentCache</code>。所以对于文件的<code>ContentCache</code>的引用需要考虑还没装载的情况，统一以下面这个函数来操作<code>getOrCreateContentCache</code>。</p>
<div class="codehilite"><pre><span></span><span class="c1">/// getOrCreateContentCache - Create or return a cached ContentCache for the</span>
<span class="c1">/// specified file.</span>
<span class="k">const</span> <span class="n">ContentCache</span> <span class="o">*</span>
<span class="n">SourceManager</span><span class="o">::</span><span class="n">getOrCreateContentCache</span><span class="p">(</span><span class="k">const</span> <span class="n">FileEntry</span> <span class="o">*</span><span class="n">FileEnt</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">isSystemFile</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">FileEnt</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Didn&#39;t specify a file entry to use?&quot;</span><span class="p">);</span>

    <span class="c1">// Do we already have information about this file?</span>
    <span class="n">ContentCache</span> <span class="o">*&amp;</span><span class="n">Entry</span> <span class="o">=</span> <span class="n">FileInfos</span><span class="p">[</span><span class="n">FileEnt</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Entry</span><span class="p">)</span> <span class="k">return</span> <span class="n">Entry</span><span class="p">;</span>

    <span class="c1">// Nope, create a new Cache entry.</span>
    <span class="n">Entry</span> <span class="o">=</span> <span class="n">ContentCacheAlloc</span><span class="p">.</span><span class="n">Allocate</span><span class="o">&lt;</span><span class="n">ContentCache</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">OverriddenFilesInfo</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// If the file contents are overridden with contents from another file,</span>
        <span class="c1">// pass that file to ContentCache.</span>
        <span class="n">llvm</span><span class="o">::</span><span class="n">DenseMap</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">FileEntry</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">FileEntry</span> <span class="o">*&gt;::</span><span class="n">iterator</span>
            <span class="n">overI</span> <span class="o">=</span> <span class="n">OverriddenFilesInfo</span><span class="o">-&gt;</span><span class="n">OverriddenFiles</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">FileEnt</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">overI</span> <span class="o">==</span> <span class="n">OverriddenFilesInfo</span><span class="o">-&gt;</span><span class="n">OverriddenFiles</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
            <span class="k">new</span> <span class="p">(</span><span class="n">Entry</span><span class="p">)</span> <span class="n">ContentCache</span><span class="p">(</span><span class="n">FileEnt</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="nf">new</span> <span class="p">(</span><span class="n">Entry</span><span class="p">)</span> <span class="n">ContentCache</span><span class="p">(</span><span class="n">OverridenFilesKeepOriginalName</span> <span class="o">?</span> <span class="nl">FileEnt</span>
                <span class="p">:</span> <span class="n">overI</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">,</span>
                <span class="n">overI</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">new</span> <span class="p">(</span><span class="n">Entry</span><span class="p">)</span> <span class="n">ContentCache</span><span class="p">(</span><span class="n">FileEnt</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">Entry</span><span class="o">-&gt;</span><span class="n">IsSystemFile</span> <span class="o">=</span> <span class="n">isSystemFile</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">Entry</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>该函数的逻辑还是比较简单的，首先判断是有已经有了对应的<code>ContentCache</code>，没有的话生成一个。生成时又需要判断这个文件是否已经被其他文件给覆盖了，如果是的话还需要把这个覆盖关系传递过去。</p>
<h2 id="442ccb">生成新的FileID</h2>
<p>对于<code>FileID</code>，通过以下两种方式生成，一个处理头文件引用，一个处理缓存映射。</p>
<p>如果以头文件引用的形式生成，则需要调用一下函数：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief Create a new FileID that represents the specified file</span>
<span class="c1">/// being #included from the specified IncludePosition.</span>
<span class="c1">///</span>
<span class="c1">/// This translates NULL into standard input.</span>
<span class="n">FileID</span> <span class="nf">createFileID</span><span class="p">(</span><span class="k">const</span> <span class="n">FileEntry</span> <span class="o">*</span><span class="n">SourceFile</span><span class="p">,</span> <span class="n">SourceLocation</span> <span class="n">IncludePos</span><span class="p">,</span>
    <span class="n">SrcMgr</span><span class="o">::</span><span class="n">CharacteristicKind</span> <span class="n">FileCharacter</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">LoadedID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">LoadedOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">SrcMgr</span><span class="o">::</span><span class="n">ContentCache</span> <span class="o">*</span>
        <span class="n">IR</span> <span class="o">=</span> <span class="n">getOrCreateContentCache</span><span class="p">(</span><span class="n">SourceFile</span><span class="p">,</span>
            <span class="cm">/*isSystemFile=*/</span><span class="n">FileCharacter</span> <span class="o">!=</span> <span class="n">SrcMgr</span><span class="o">::</span><span class="n">C_User</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">IR</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;getOrCreateContentCache() cannot return NULL&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">createFileID</span><span class="p">(</span><span class="n">IR</span><span class="p">,</span> <span class="n">IncludePos</span><span class="p">,</span> <span class="n">FileCharacter</span><span class="p">,</span> <span class="n">LoadedID</span><span class="p">,</span> <span class="n">LoadedOffset</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>首先获得其<code>FileEntry</code>对应的<code>ContentCache</code>，然后再调用具体的执行函数。</p>
<p>如果我们是以一个内存缓冲区来建立一个新的<code>FileID</code>的话，则需要调用另外一个函数了：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief Create a new FileID that represents the specified memory buffer.</span>
<span class="c1">///</span>
<span class="c1">/// This does no caching of the buffer and takes ownership of the</span>
<span class="c1">/// MemoryBuffer, so only pass a MemoryBuffer to this once.</span>
<span class="n">FileID</span> <span class="nf">createFileID</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">MemoryBuffer</span><span class="o">&gt;</span> <span class="n">Buffer</span><span class="p">,</span>
    <span class="n">SrcMgr</span><span class="o">::</span><span class="n">CharacteristicKind</span> <span class="n">FileCharacter</span> <span class="o">=</span> <span class="n">SrcMgr</span><span class="o">::</span><span class="n">C_User</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">LoadedID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">LoadedOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">SourceLocation</span> <span class="n">IncludeLoc</span> <span class="o">=</span> <span class="n">SourceLocation</span><span class="p">())</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">createFileID</span><span class="p">(</span><span class="n">createMemBufferContentCache</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Buffer</span><span class="p">)),</span>
        <span class="n">IncludeLoc</span><span class="p">,</span> <span class="n">FileCharacter</span><span class="p">,</span> <span class="n">LoadedID</span><span class="p">,</span> <span class="n">LoadedOffset</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>这里的逻辑也差不多，根据一个<code>MemoryBuffer</code>来生成一个<code>ContentCache</code>，基本只需要<code>move</code>就行了。</p>
<p>这两种<code>FileID</code>的创建方式最后都需要调用<code>createFileID</code>这个函数：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// createFileID - Create a new FileID for the specified ContentCache and</span>
<span class="c1">/// include position.  This works regardless of whether the ContentCache</span>
<span class="c1">/// corresponds to a file or some other input source.</span>
<span class="n">FileID</span> <span class="n">SourceManager</span><span class="o">::</span><span class="n">createFileID</span><span class="p">(</span><span class="k">const</span> <span class="n">ContentCache</span> <span class="o">*</span><span class="n">File</span><span class="p">,</span>
    <span class="n">SourceLocation</span> <span class="n">IncludePos</span><span class="p">,</span>
    <span class="n">SrcMgr</span><span class="o">::</span><span class="n">CharacteristicKind</span> <span class="n">FileCharacter</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">LoadedID</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">LoadedOffset</span><span class="p">)</span>
</pre></div>


<p>这里的参数<code>LoadedID</code>其实就是<code>FileID</code>的编号。如果这个<code>ID</code>的值小于0，则他加载自外部模块，其值被限定为<code>LoadedSlocEntryTable.size()</code>内。此时的执行逻辑如下，这里还涉及到了延迟加载，所以会有一个<code>vector&lt;bool&gt;</code>来表明是否已经加载了，：</p>
<div class="codehilite"><pre><span></span><span class="n">assert</span><span class="p">(</span><span class="n">LoadedID</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Loading sentinel FileID&quot;</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="n">Index</span> <span class="o">=</span> <span class="kt">unsigned</span><span class="p">(</span><span class="o">-</span><span class="n">LoadedID</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">assert</span><span class="p">(</span><span class="n">Index</span> <span class="o">&lt;</span> <span class="n">LoadedSLocEntryTable</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;FileID out of range&quot;</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">SLocEntryLoaded</span><span class="p">[</span><span class="n">Index</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;FileID already loaded&quot;</span><span class="p">);</span>
<span class="n">LoadedSLocEntryTable</span><span class="p">[</span><span class="n">Index</span><span class="p">]</span> <span class="o">=</span> <span class="n">SLocEntry</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">LoadedOffset</span><span class="p">,</span>
    <span class="n">FileInfo</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">IncludePos</span><span class="p">,</span> <span class="n">File</span><span class="p">,</span> <span class="n">FileCharacter</span><span class="p">));</span>
<span class="n">SLocEntryLoaded</span><span class="p">[</span><span class="n">Index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="k">return</span> <span class="n">FileID</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">LoadedID</span><span class="p">);</span>
</pre></div>


<p>反之，其<code>ID</code>大于等于0，这是本模块内的<code>ID</code>，则直接加入到<code>LocalSlocEntryTable</code>中，并返回这个加入的索引：</p>
<div class="codehilite"><pre><span></span><span class="n">LocalSLocEntryTable</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">SLocEntry</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">NextLocalOffset</span><span class="p">,</span>
    <span class="n">FileInfo</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">IncludePos</span><span class="p">,</span> <span class="n">File</span><span class="p">,</span>
        <span class="n">FileCharacter</span><span class="p">)));</span>
<span class="kt">unsigned</span> <span class="n">FileSize</span> <span class="o">=</span> <span class="n">File</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">();</span>
<span class="n">assert</span><span class="p">(</span><span class="n">NextLocalOffset</span> <span class="o">+</span> <span class="n">FileSize</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">NextLocalOffset</span> <span class="o">&amp;&amp;</span>
    <span class="n">NextLocalOffset</span> <span class="o">+</span> <span class="n">FileSize</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">CurrentLoadedOffset</span> <span class="o">&amp;&amp;</span>
    <span class="s">&quot;Ran out of source locations!&quot;</span><span class="p">);</span>
<span class="c1">// We do a +1 here because we want a SourceLocation that means &quot;the end of the</span>
<span class="c1">// file&quot;, e.g. for the &quot;no newline at the end of the file&quot; diagnostic.</span>
<span class="n">NextLocalOffset</span> <span class="o">+=</span> <span class="n">FileSize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// Set LastFileIDLookup to the newly created file.  The next getFileID call is</span>
<span class="c1">// almost guaranteed to be from that file.</span>
<span class="n">FileID</span> <span class="n">FID</span> <span class="o">=</span> <span class="n">FileID</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">LocalSLocEntryTable</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">return</span> <span class="n">LastFileIDLookup</span> <span class="o">=</span> <span class="n">FID</span><span class="p">;</span>
</pre></div>


<h2 id="a16f55">为ContentCache生成行号索引</h2>
<p><code>ContentCache</code>中的<code>SourceLineCache</code>是一个延迟填充的数据成员，只有在被使用时才初始化行号缓存，来指明这个文件中每一行的开始位置偏移。这个行号缓存的构建函数签名如下：</p>
<div class="codehilite"><pre><span></span><span class="k">static</span> <span class="n">LLVM_ATTRIBUTE_NOINLINE</span> <span class="kt">void</span>
<span class="nf">ComputeLineNumbers</span><span class="p">(</span><span class="n">DiagnosticsEngine</span> <span class="o">&amp;</span><span class="n">Diag</span><span class="p">,</span> <span class="n">ContentCache</span> <span class="o">*</span><span class="n">FI</span><span class="p">,</span>
    <span class="n">llvm</span><span class="o">::</span><span class="n">BumpPtrAllocator</span> <span class="o">&amp;</span><span class="n">Alloc</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">SourceManager</span> <span class="o">&amp;</span><span class="n">SM</span><span class="p">,</span> <span class="kt">bool</span> <span class="o">&amp;</span><span class="n">Invalid</span><span class="p">);</span>
</pre></div>


<p>这个是一个全局函数，而不是内部函数。其实现比较长，看到这一个条件开关简直虎躯一震：</p>
<div class="codehilite"><pre><span></span><span class="cp">#ifdef __SSE2__</span>
<span class="cp">#include</span> <span class="cpf">&lt;emmintrin.h&gt;</span><span class="cp"></span>
<span class="cp">#endif</span>
</pre></div>


<p>其实他的逻辑很简单，就是对一个<code>ContentCache</code>进行一个线性扫描换行符，<code>SSE</code>指令很适合这种情况：</p>
<div class="codehilite"><pre><span></span><span class="kr">__m128i</span> <span class="n">CRs</span> <span class="o">=</span> <span class="n">_mm_set1_epi8</span><span class="p">(</span><span class="sc">&#39;\r&#39;</span><span class="p">);</span>
<span class="kr">__m128i</span> <span class="n">LFs</span> <span class="o">=</span> <span class="n">_mm_set1_epi8</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">);</span>
<span class="k">while</span> <span class="p">(</span><span class="n">NextBuf</span> <span class="o">+</span> <span class="mi">16</span> <span class="o">&lt;=</span> <span class="n">End</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kr">__m128i</span> <span class="n">Chunk</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="kr">__m128i</span><span class="o">*</span><span class="p">)</span><span class="n">NextBuf</span><span class="p">;</span>
    <span class="kr">__m128i</span> <span class="n">Cmp</span> <span class="o">=</span> <span class="n">_mm_or_si128</span><span class="p">(</span><span class="n">_mm_cmpeq_epi8</span><span class="p">(</span><span class="n">Chunk</span><span class="p">,</span> <span class="n">CRs</span><span class="p">),</span>
        <span class="n">_mm_cmpeq_epi8</span><span class="p">(</span><span class="n">Chunk</span><span class="p">,</span> <span class="n">LFs</span><span class="p">));</span>
    <span class="kt">unsigned</span> <span class="n">Mask</span> <span class="o">=</span> <span class="n">_mm_movemask_epi8</span><span class="p">(</span><span class="n">Cmp</span><span class="p">);</span>

    <span class="c1">// If we found a newline, adjust the pointer and jump to the handling code.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">NextBuf</span> <span class="o">+=</span> <span class="n">llvm</span><span class="o">::</span><span class="n">countTrailingZeros</span><span class="p">(</span><span class="n">Mask</span><span class="p">);</span>
        <span class="k">goto</span> <span class="n">FoundSpecialChar</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">NextBuf</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>遇到换行的时候就记录位置到<code>ContentCache.SourceLineCache</code>中。</p>
<p>对于给定文件内<code>Offset</code>，寻找对应的行号则只需要在<code>SourceLineCache</code>中二分查找就可以了。</p>
<h2 id="9fd146">Macro展开位置的建立</h2>
<p>对于宏的展开分为了两种：宏调用展开和宏参数展开，宏调用展开包含了宏参数展开。这两个都是先生成一个<code>ExpansionInfo</code>，然后再调用最后执行该任务的函数。</p>
<div class="codehilite"><pre><span></span><span class="n">SourceLocation</span>
<span class="n">SourceManager</span><span class="o">::</span><span class="n">createMacroArgExpansionLoc</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">SpellingLoc</span><span class="p">,</span>
    <span class="n">SourceLocation</span> <span class="n">ExpansionLoc</span><span class="p">,</span>
    <span class="kt">unsigned</span> <span class="n">TokLength</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ExpansionInfo</span> <span class="n">Info</span> <span class="o">=</span> <span class="n">ExpansionInfo</span><span class="o">::</span><span class="n">createForMacroArg</span><span class="p">(</span><span class="n">SpellingLoc</span><span class="p">,</span>
        <span class="n">ExpansionLoc</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">createExpansionLocImpl</span><span class="p">(</span><span class="n">Info</span><span class="p">,</span> <span class="n">TokLength</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">SourceLocation</span>
<span class="n">SourceManager</span><span class="o">::</span><span class="n">createExpansionLoc</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">SpellingLoc</span><span class="p">,</span>
    <span class="n">SourceLocation</span> <span class="n">ExpansionLocStart</span><span class="p">,</span>
    <span class="n">SourceLocation</span> <span class="n">ExpansionLocEnd</span><span class="p">,</span>
    <span class="kt">unsigned</span> <span class="n">TokLength</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">LoadedID</span><span class="p">,</span>
    <span class="kt">unsigned</span> <span class="n">LoadedOffset</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ExpansionInfo</span> <span class="n">Info</span> <span class="o">=</span> <span class="n">ExpansionInfo</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">SpellingLoc</span><span class="p">,</span> <span class="n">ExpansionLocStart</span><span class="p">,</span>
        <span class="n">ExpansionLocEnd</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">createExpansionLocImpl</span><span class="p">(</span><span class="n">Info</span><span class="p">,</span> <span class="n">TokLength</span><span class="p">,</span> <span class="n">LoadedID</span><span class="p">,</span> <span class="n">LoadedOffset</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>上面的代码中<code>createForMacroArg</code>只需要一个<code>ExpansionLoc</code>，是因为宏参数只是一个<code>token</code>，第二个<code>SourceLocation</code>默认为无效的。</p>
<p>具体执行函数的签名如下，有两个默认参数:</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief Return a new SourceLocation that encodes the fact</span>
<span class="c1">/// that a token from SpellingLoc should actually be referenced from</span>
<span class="c1">/// ExpansionLoc.</span>
<span class="n">SourceLocation</span> <span class="nf">createExpansionLoc</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">,</span>
    <span class="n">SourceLocation</span> <span class="n">ExpansionLocStart</span><span class="p">,</span>
    <span class="n">SourceLocation</span> <span class="n">ExpansionLocEnd</span><span class="p">,</span>
    <span class="kt">unsigned</span> <span class="n">TokLength</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">LoadedID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="kt">unsigned</span> <span class="n">LoadedOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>


<p>该函数的执行逻辑与上面的<code>CreateFileID</code>的执行逻辑差不多，也是分为了外部模块和本地模块来讨论的。当处理的展开是外部模块时，执行以下代码：</p>
<div class="codehilite"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">LoadedID</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">LoadedID</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Loading sentinel FileID&quot;</span><span class="p">);</span>
    <span class="kt">unsigned</span> <span class="n">Index</span> <span class="o">=</span> <span class="kt">unsigned</span><span class="p">(</span><span class="o">-</span><span class="n">LoadedID</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">Index</span> <span class="o">&lt;</span> <span class="n">LoadedSLocEntryTable</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;FileID out of range&quot;</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">SLocEntryLoaded</span><span class="p">[</span><span class="n">Index</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;FileID already loaded&quot;</span><span class="p">);</span>
    <span class="n">LoadedSLocEntryTable</span><span class="p">[</span><span class="n">Index</span><span class="p">]</span> <span class="o">=</span> <span class="n">SLocEntry</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">LoadedOffset</span><span class="p">,</span> <span class="n">Info</span><span class="p">);</span>
    <span class="n">SLocEntryLoaded</span><span class="p">[</span><span class="n">Index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">SourceLocation</span><span class="o">::</span><span class="n">getMacroLoc</span><span class="p">(</span><span class="n">LoadedOffset</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>当处理的是本地模块的时候，执行以下代码：</p>
<div class="codehilite"><pre><span></span><span class="n">LocalSLocEntryTable</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">SLocEntry</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">NextLocalOffset</span><span class="p">,</span> <span class="n">Info</span><span class="p">));</span>
<span class="n">assert</span><span class="p">(</span><span class="n">NextLocalOffset</span> <span class="o">+</span> <span class="n">TokLength</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">NextLocalOffset</span> <span class="o">&amp;&amp;</span>
    <span class="n">NextLocalOffset</span> <span class="o">+</span> <span class="n">TokLength</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">CurrentLoadedOffset</span> <span class="o">&amp;&amp;</span>
    <span class="s">&quot;Ran out of source locations!&quot;</span><span class="p">);</span>
<span class="c1">// See createFileID for that +1.</span>
<span class="n">NextLocalOffset</span> <span class="o">+=</span> <span class="n">TokLength</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">return</span> <span class="n">SourceLocation</span><span class="o">::</span><span class="n">getMacroLoc</span><span class="p">(</span><span class="n">NextLocalOffset</span> <span class="o">-</span> <span class="p">(</span><span class="n">TokLength</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
</pre></div>


<p>从这些代码中可以看出，本地模块与外部模块最主要的差异就是：本地模块内需要更新 <code>NextLocalOffset</code>，而外部模块则不需要，但是外部模块中的 <code>FileID</code>很多是延迟加载的，处理的时候需要判断是否已经加载。</p>
<h2 id="74d66d">为FileID建立宏参数映射</h2>
<p>宏参数缓存全称为<code>MacroArgsMap</code>，<code>clang</code>中对于这个的解释还是不清楚：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief Compute a map of macro argument chunks to their expanded source</span>
<span class="c1">/// location. Chunks that are not part of a macro argument will map to an</span>
<span class="c1">/// invalid source location. e.g. if a file contains one macro argument at</span>
<span class="c1">/// offset 100 with length 10, this is how the map will be formed:</span>
<span class="c1">///     0   -&gt; SourceLocation()</span>
<span class="c1">///     100 -&gt; Expanded macro arg location</span>
<span class="c1">///     110 -&gt; SourceLocation()</span>
</pre></div>


<p>好像大意是：把源文件按照是否是宏参数切分为多个区间，对于是宏参数的区域，映射为该位置的<code>SourceLocation</code>，否则映射为无效的<code>SourceLocation</code>。</p>
<p>对于一个特定的文件<code>FileID</code>，它可以引入多个新的<code>FileID</code>，有些是头文件引用，有些是宏展开。处理的时候我们需要明确一下<code>FileID</code>的分配规则，每处理一个新的头文件引入或者宏展开，这个全局的<code>FileID</code>会自增。同时会先处理这个新引入的头文件，然后再回到原始的位置，继续处理当前文件后面的头文件引入或者展开。当前文件后面的第一个<code>FileID</code>偏移值会等于上一个头文件所引入的新<code>FileID</code>个数。</p>
<p>所以完整的逻辑是这样的。当前<code>FileID</code>自增，如果遇到头文件引入，首先判断这个头文件引入位置是否是当前文件，不是的话说明<code>FileID</code>已经越界不需要处理了，否则<code>FileID+ =NumCreatedFIDs</code>。如果遇到的是宏展开，也需要判断这个展开是否来自于当前文件，不是的话也表明<code>FileID</code>越界，不需要再处理，否则将这个加入到<code>MacroArgMap</code>里面做记录。完整的代码如下：</p>
<div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="n">ID</span> <span class="o">=</span> <span class="n">FID</span><span class="p">.</span><span class="n">ID</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">++</span><span class="n">ID</span><span class="p">;</span>
    <span class="c1">// Stop if there are no more FileIDs to check.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ID</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">(</span><span class="n">ID</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">local_sloc_entry_size</span><span class="p">())</span>
            <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ID</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">Invalid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">SrcMgr</span><span class="o">::</span><span class="n">SLocEntry</span> <span class="o">&amp;</span><span class="n">Entry</span> <span class="o">=</span> <span class="n">getSLocEntryByID</span><span class="p">(</span><span class="n">ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Invalid</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Invalid</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Entry</span><span class="p">.</span><span class="n">isFile</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">SourceLocation</span> <span class="n">IncludeLoc</span> <span class="o">=</span> <span class="n">Entry</span><span class="p">.</span><span class="n">getFile</span><span class="p">().</span><span class="n">getIncludeLoc</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">IncludeLoc</span><span class="p">.</span><span class="n">isInvalid</span><span class="p">())</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isInFileID</span><span class="p">(</span><span class="n">IncludeLoc</span><span class="p">,</span> <span class="n">FID</span><span class="p">))</span>
            <span class="k">return</span><span class="p">;</span> <span class="c1">// No more files/macros that may be &quot;contained&quot; in this file.</span>

  <span class="c1">// Skip the files/macros of the #include&#39;d file, we only care about macros</span>
  <span class="c1">// that lexed macro arguments from our file.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Entry</span><span class="p">.</span><span class="n">getFile</span><span class="p">().</span><span class="n">NumCreatedFIDs</span><span class="p">)</span>
            <span class="n">ID</span> <span class="o">+=</span> <span class="n">Entry</span><span class="p">.</span><span class="n">getFile</span><span class="p">().</span><span class="n">NumCreatedFIDs</span> <span class="o">-</span> <span class="mi">1</span><span class="cm">/*because of next ++ID*/</span><span class="p">;</span>
        <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">ExpansionInfo</span> <span class="o">&amp;</span><span class="n">ExpInfo</span> <span class="o">=</span> <span class="n">Entry</span><span class="p">.</span><span class="n">getExpansion</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ExpInfo</span><span class="p">.</span><span class="n">getExpansionLocStart</span><span class="p">().</span><span class="n">isFileID</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isInFileID</span><span class="p">(</span><span class="n">ExpInfo</span><span class="p">.</span><span class="n">getExpansionLocStart</span><span class="p">(),</span> <span class="n">FID</span><span class="p">))</span>
            <span class="k">return</span><span class="p">;</span> <span class="c1">// No more files/macros that may be &quot;contained&quot; in this file.</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ExpInfo</span><span class="p">.</span><span class="n">isMacroArgExpansion</span><span class="p">())</span>
        <span class="k">continue</span><span class="p">;</span>

    <span class="n">associateFileChunkWithMacroArgExp</span><span class="p">(</span><span class="n">MacroArgsCache</span><span class="p">,</span> <span class="n">FID</span><span class="p">,</span>
        <span class="n">ExpInfo</span><span class="p">.</span><span class="n">getSpellingLoc</span><span class="p">(),</span>
        <span class="n">SourceLocation</span><span class="o">::</span><span class="n">getMacroLoc</span><span class="p">(</span><span class="n">Entry</span><span class="p">.</span><span class="n">getOffset</span><span class="p">()),</span>
        <span class="n">getFileIDSize</span><span class="p">(</span><span class="n">FileID</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">ID</span><span class="p">)));</span>
<span class="p">}</span>
</pre></div>


<p>最后的的记录函数是<code>associateFileChunkWithMacroArgExp</code>,需要考虑的是宏参数也是一个宏函数的时候。此时我们要把整个宏参数展开过程记录下来，所以要递归处理。</p>
<div class="codehilite"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SpellLoc</span><span class="p">.</span><span class="n">isFileID</span><span class="p">())</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">SpellBeginOffs</span> <span class="o">=</span> <span class="n">SpellLoc</span><span class="p">.</span><span class="n">getOffset</span><span class="p">();</span>
    <span class="kt">unsigned</span> <span class="n">SpellEndOffs</span> <span class="o">=</span> <span class="n">SpellBeginOffs</span> <span class="o">+</span> <span class="n">ExpansionLength</span><span class="p">;</span>

    <span class="c1">// The spelling range for this macro argument expansion can span multiple</span>
    <span class="c1">// consecutive FileID entries. Go through each entry contained in the</span>
    <span class="c1">// spelling range and if one is itself a macro argument expansion, recurse</span>
    <span class="c1">// and associate the file chunk that it represents.</span>

    <span class="n">FileID</span> <span class="n">SpellFID</span><span class="p">;</span> <span class="c1">// Current FileID in the spelling range.</span>
    <span class="kt">unsigned</span> <span class="n">SpellRelativeOffs</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">SpellFID</span><span class="p">,</span> <span class="n">SpellRelativeOffs</span><span class="p">)</span> <span class="o">=</span> <span class="n">getDecomposedLoc</span><span class="p">(</span><span class="n">SpellLoc</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">SLocEntry</span> <span class="o">&amp;</span><span class="n">Entry</span> <span class="o">=</span> <span class="n">getSLocEntry</span><span class="p">(</span><span class="n">SpellFID</span><span class="p">);</span>
        <span class="kt">unsigned</span> <span class="n">SpellFIDBeginOffs</span> <span class="o">=</span> <span class="n">Entry</span><span class="p">.</span><span class="n">getOffset</span><span class="p">();</span>
        <span class="kt">unsigned</span> <span class="n">SpellFIDSize</span> <span class="o">=</span> <span class="n">getFileIDSize</span><span class="p">(</span><span class="n">SpellFID</span><span class="p">);</span>
        <span class="kt">unsigned</span> <span class="n">SpellFIDEndOffs</span> <span class="o">=</span> <span class="n">SpellFIDBeginOffs</span> <span class="o">+</span> <span class="n">SpellFIDSize</span><span class="p">;</span>
        <span class="k">const</span> <span class="n">ExpansionInfo</span> <span class="o">&amp;</span><span class="n">Info</span> <span class="o">=</span> <span class="n">Entry</span><span class="p">.</span><span class="n">getExpansion</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Info</span><span class="p">.</span><span class="n">isMacroArgExpansion</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="kt">unsigned</span> <span class="n">CurrSpellLength</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">SpellFIDEndOffs</span> <span class="o">&lt;</span> <span class="n">SpellEndOffs</span><span class="p">)</span>
                <span class="n">CurrSpellLength</span> <span class="o">=</span> <span class="n">SpellFIDSize</span> <span class="o">-</span> <span class="n">SpellRelativeOffs</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="n">CurrSpellLength</span> <span class="o">=</span> <span class="n">ExpansionLength</span><span class="p">;</span>
            <span class="n">associateFileChunkWithMacroArgExp</span><span class="p">(</span><span class="n">MacroArgsCache</span><span class="p">,</span> <span class="n">FID</span><span class="p">,</span>
                <span class="n">Info</span><span class="p">.</span><span class="n">getSpellingLoc</span><span class="p">().</span><span class="n">getLocWithOffset</span><span class="p">(</span><span class="n">SpellRelativeOffs</span><span class="p">),</span>
                <span class="n">ExpansionLoc</span><span class="p">,</span> <span class="n">CurrSpellLength</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">SpellFIDEndOffs</span> <span class="o">&gt;=</span> <span class="n">SpellEndOffs</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span> <span class="c1">// we covered all FileID entries in the spelling range.</span>

  <span class="c1">// Move to the next FileID entry in the spelling range.</span>
        <span class="kt">unsigned</span> <span class="n">advance</span> <span class="o">=</span> <span class="n">SpellFIDSize</span> <span class="o">-</span> <span class="n">SpellRelativeOffs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">ExpansionLoc</span> <span class="o">=</span> <span class="n">ExpansionLoc</span><span class="p">.</span><span class="n">getLocWithOffset</span><span class="p">(</span><span class="n">advance</span><span class="p">);</span>
        <span class="n">ExpansionLength</span> <span class="o">-=</span> <span class="n">advance</span><span class="p">;</span>
        <span class="o">++</span><span class="n">SpellFID</span><span class="p">.</span><span class="n">ID</span><span class="p">;</span>
        <span class="n">SpellRelativeOffs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></div>


<h1 id="eb9b5b">查询访问</h1>
<h2 id="05ec09">访问缓存管理与统计</h2>
<p>这个结构体还给了很大的笔墨来记录一些最近的访问记录和一些统计信息：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief A one-entry cache to speed up getFileID.</span>
<span class="c1">///</span>
<span class="c1">/// LastFileIDLookup records the last FileID looked up or created, because it</span>
<span class="c1">/// is very common to look up many tokens from the same file.</span>
<span class="k">mutable</span> <span class="n">FileID</span> <span class="n">LastFileIDLookup</span><span class="p">;</span>
<span class="c1">/// \brief These ivars serve as a cache used in the getLineNumber</span>
<span class="c1">/// method which is used to speedup getLineNumber calls to nearby locations.</span>
<span class="k">mutable</span> <span class="n">FileID</span> <span class="n">LastLineNoFileIDQuery</span><span class="p">;</span>
<span class="k">mutable</span> <span class="n">SrcMgr</span><span class="o">::</span><span class="n">ContentCache</span> <span class="o">*</span><span class="n">LastLineNoContentCache</span><span class="p">;</span>
<span class="k">mutable</span> <span class="kt">unsigned</span> <span class="n">LastLineNoFilePos</span><span class="p">;</span>
<span class="k">mutable</span> <span class="kt">unsigned</span> <span class="n">LastLineNoResult</span><span class="p">;</span>
<span class="c1">// Statistics for -print-stats.</span>
<span class="k">mutable</span> <span class="kt">unsigned</span> <span class="n">NumLinearScans</span><span class="p">,</span> <span class="n">NumBinaryProbes</span><span class="p">;</span>

<span class="c1">/// \brief Associates a FileID with its &quot;included/expanded in&quot; decomposed</span>
<span class="c1">/// location.</span>
<span class="c1">///</span>
<span class="c1">/// Used to cache results from and speed-up \c getDecomposedIncludedLoc</span>
<span class="c1">/// function.</span>
<span class="k">mutable</span> <span class="n">llvm</span><span class="o">::</span><span class="n">DenseMap</span><span class="o">&lt;</span><span class="n">FileID</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">FileID</span><span class="p">,</span> <span class="kt">unsigned</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">IncludedLocMap</span><span class="p">;</span>
</pre></div>


<h2 id="87424a">根据SLocOffset查询FileID</h2>
<p>在为<code>FileEntry</code>创建<code>ContentCache</code>的代码中，为了维护<code>NextLocalOffset</code>，有如下判断断言</p>
<div class="codehilite"><pre><span></span><span class="n">assert</span><span class="p">(</span><span class="n">NextLocalOffset</span> <span class="o">+</span> <span class="n">FileSize</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">NextLocalOffset</span> <span class="o">&amp;&amp;</span>
    <span class="n">NextLocalOffset</span> <span class="o">+</span> <span class="n">FileSize</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">CurrentLoadedOffset</span> <span class="o">&amp;&amp;</span>
    <span class="s">&quot;Ran out of source locations!&quot;</span><span class="p">);</span>
</pre></div>


<p>上面的代码中的<code>assert</code>是用来来判断这个 <code>NextLocalOffset</code>是否有效。第一个判断 <code>NextLocalOffset</code>是否可能溢出，第二个判断<code>NextLocalOffset</code>是否会干涉到<code>CurrentLoadedOffset</code>。这里之所以要与<code>CurrentLoadedOffset</code>做比较，是因为全局只有一个<code>SlocOffset</code>，<code>NextLocalOffset</code>与<code>CurrentLoadedOffset</code>共享一个地址空间，一个从0向上增长，一个从<span class="math">\(2^{32}-1\)</span>向下增长。</p>
<p>给定一个<code>SlocOffset</code>判断他是<code>local</code>还是<code>loaded</code>就只需要与其中一个做大小比较就可以了。具体的见下面的代码：</p>
<div class="codehilite"><pre><span></span><span class="n">FileID</span> <span class="n">SourceManager</span><span class="o">::</span><span class="n">getFileIDSlow</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">SLocOffset</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SLocOffset</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FileID</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="c1">// Now it is time to search for the correct file. See where the SLocOffset</span>
    <span class="c1">// sits in the global view and consult local or loaded buffers for it.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">SLocOffset</span> <span class="o">&lt;</span> <span class="n">NextLocalOffset</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">getFileIDLocal</span><span class="p">(</span><span class="n">SLocOffset</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">getFileIDLoaded</span><span class="p">(</span><span class="n">SLocOffset</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>对于<code>local</code>的处理，其代码比较长，所以我们分片介绍。</p>
<p>首先判断这个<code>local</code>的<code>Offset</code>是否有效，直接与<code>NextLocalOffset</code>做比较。在有效的情况下，找到一个<code>Offset</code>比他大的<code>SlocEntry</code>，能用上一次查询的位点就用，<code>clang</code>说局部性很好。</p>
<div class="codehilite"><pre><span></span><span class="k">const</span> <span class="n">SrcMgr</span><span class="o">::</span><span class="n">SLocEntry</span> <span class="o">*</span><span class="n">I</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">LastFileIDLookup</span><span class="p">.</span><span class="n">ID</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span>
    <span class="n">LocalSLocEntryTable</span><span class="p">[</span><span class="n">LastFileIDLookup</span><span class="p">.</span><span class="n">ID</span><span class="p">].</span><span class="n">getOffset</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">SLocOffset</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Neither loc prunes our search.</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">LocalSLocEntryTable</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="c1">// Perhaps it is near the file point.</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">LocalSLocEntryTable</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">LastFileIDLookup</span><span class="p">.</span><span class="n">ID</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>找到这个位点之后，逆向遍历，获得第一个比<code>Offset</code>小的<code>SLocEntry</code>，这个就是包含当前<code>Offset</code>的文件位点。这里的寻找策略也是非常诡异，首先线性查找8个单位，如果遇到结果则返回。</p>
<div class="codehilite"><pre><span></span><span class="c1">// Find the FileID that contains this.  &quot;I&quot; is an iterator that points to a</span>
<span class="c1">// FileID whose offset is known to be larger than SLocOffset.</span>
<span class="kt">unsigned</span> <span class="n">NumProbes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">--</span><span class="n">I</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">I</span><span class="o">-&gt;</span><span class="n">getOffset</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">SLocOffset</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">FileID</span> <span class="n">Res</span> <span class="o">=</span> <span class="n">FileID</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="n">I</span> <span class="o">-</span> <span class="n">LocalSLocEntryTable</span><span class="p">.</span><span class="n">begin</span><span class="p">()));</span>

        <span class="c1">// If this isn&#39;t an expansion, remember it.  We have good locality across</span>
        <span class="c1">// FileID lookups.</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">I</span><span class="o">-&gt;</span><span class="n">isExpansion</span><span class="p">())</span>
            <span class="n">LastFileIDLookup</span> <span class="o">=</span> <span class="n">Res</span><span class="p">;</span>
        <span class="n">NumLinearScans</span> <span class="o">+=</span> <span class="n">NumProbes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">Res</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">NumProbes</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span>
        <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Convert &quot;I&quot; back into an index.  We know that it is an entry whose index is</span>
<span class="c1">// larger than the offset we are looking for.</span>
<span class="kt">unsigned</span> <span class="n">GreaterIndex</span> <span class="o">=</span> <span class="n">I</span> <span class="o">-</span> <span class="n">LocalSLocEntryTable</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="c1">// LessIndex - This is the lower bound of the range that we&#39;re searching.</span>
<span class="c1">// We know that the offset corresponding to the FileID is is less than</span>
<span class="c1">// SLocOffset.</span>
</pre></div>


<p>如果这8次探寻都没中，则开始二分查找：</p>
<div class="codehilite"><pre><span></span><span class="kt">unsigned</span> <span class="n">LessIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">NumProbes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">Invalid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">MiddleIndex</span> <span class="o">=</span> <span class="p">(</span><span class="n">GreaterIndex</span> <span class="o">-</span> <span class="n">LessIndex</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">LessIndex</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">MidOffset</span> <span class="o">=</span> <span class="n">getLocalSLocEntry</span><span class="p">(</span><span class="n">MiddleIndex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Invalid</span><span class="p">).</span><span class="n">getOffset</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Invalid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FileID</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="o">++</span><span class="n">NumProbes</span><span class="p">;</span>

    <span class="c1">// If the offset of the midpoint is too large, chop the high side of the</span>
    <span class="c1">// range to the midpoint.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">MidOffset</span> <span class="o">&gt;</span> <span class="n">SLocOffset</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">GreaterIndex</span> <span class="o">=</span> <span class="n">MiddleIndex</span><span class="p">;</span>
        <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// If the middle index contains the value, succeed and return.</span>
    <span class="c1">// FIXME: This could be made faster by using a function that&#39;s aware of</span>
    <span class="c1">// being in the local area.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isOffsetInFileID</span><span class="p">(</span><span class="n">FileID</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">MiddleIndex</span><span class="p">),</span> <span class="n">SLocOffset</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">FileID</span> <span class="n">Res</span> <span class="o">=</span> <span class="n">FileID</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">MiddleIndex</span><span class="p">);</span>

        <span class="c1">// If this isn&#39;t a macro expansion, remember it.  We have good locality</span>
        <span class="c1">// across FileID lookups.</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LocalSLocEntryTable</span><span class="p">[</span><span class="n">MiddleIndex</span><span class="p">].</span><span class="n">isExpansion</span><span class="p">())</span>
            <span class="n">LastFileIDLookup</span> <span class="o">=</span> <span class="n">Res</span><span class="p">;</span>
        <span class="n">NumBinaryProbes</span> <span class="o">+=</span> <span class="n">NumProbes</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">Res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Otherwise, move the low-side up to the middle index.</span>
    <span class="n">LessIndex</span> <span class="o">=</span> <span class="n">MiddleIndex</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>至于<code>loaded</code>的<code>FileID</code>的查找也是大同小异，唯一的不同是比较符号是反的，同时里面的文件可能木有<code>Load</code>进来。</p>
<p>首先是线性扫描部分：</p>
<div class="codehilite"><pre><span></span><span class="c1">// Sanity checking, otherwise a bug may lead to hanging in release build.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">SLocOffset</span> <span class="o">&lt;</span> <span class="n">CurrentLoadedOffset</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Invalid SLocOffset or bad function choice&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">FileID</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Essentially the same as the local case, but the loaded array is sorted</span>
<span class="c1">// in the other direction.</span>

<span class="c1">// First do a linear scan from the last lookup position, if possible.</span>
<span class="kt">unsigned</span> <span class="n">I</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">LastID</span> <span class="o">=</span> <span class="n">LastFileIDLookup</span><span class="p">.</span><span class="n">ID</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">LastID</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">getLoadedSLocEntryByID</span><span class="p">(</span><span class="n">LastID</span><span class="p">).</span><span class="n">getOffset</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">SLocOffset</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">else</span>
    <span class="n">I</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">LastID</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="n">NumProbes</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">NumProbes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">NumProbes</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">NumProbes</span><span class="p">,</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Make sure the entry is loaded!</span>
    <span class="k">const</span> <span class="n">SrcMgr</span><span class="o">::</span><span class="n">SLocEntry</span> <span class="o">&amp;</span><span class="n">E</span> <span class="o">=</span> <span class="n">getLoadedSLocEntry</span><span class="p">(</span><span class="n">I</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">E</span><span class="p">.</span><span class="n">getOffset</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">SLocOffset</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">FileID</span> <span class="n">Res</span> <span class="o">=</span> <span class="n">FileID</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="o">-</span><span class="kt">int</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">E</span><span class="p">.</span><span class="n">isExpansion</span><span class="p">())</span>
            <span class="n">LastFileIDLookup</span> <span class="o">=</span> <span class="n">Res</span><span class="p">;</span>
        <span class="n">NumLinearScans</span> <span class="o">+=</span> <span class="n">NumProbes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">Res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>然后是二分查找部分：</p>
<div class="codehilite"><pre><span></span><span class="c1">// Linear scan failed. Do the binary search. Note the reverse sorting of the</span>
<span class="c1">// table: GreaterIndex is the one where the offset is greater, which is</span>
<span class="c1">// actually a lower index!</span>
<span class="kt">unsigned</span> <span class="n">GreaterIndex</span> <span class="o">=</span> <span class="n">I</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="n">LessIndex</span> <span class="o">=</span> <span class="n">LoadedSLocEntryTable</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="n">NumProbes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">++</span><span class="n">NumProbes</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">MiddleIndex</span> <span class="o">=</span> <span class="p">(</span><span class="n">LessIndex</span> <span class="o">-</span> <span class="n">GreaterIndex</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">GreaterIndex</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">SrcMgr</span><span class="o">::</span><span class="n">SLocEntry</span> <span class="o">&amp;</span><span class="n">E</span> <span class="o">=</span> <span class="n">getLoadedSLocEntry</span><span class="p">(</span><span class="n">MiddleIndex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">E</span><span class="p">.</span><span class="n">getOffset</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FileID</span><span class="p">();</span> <span class="c1">// invalid entry.</span>

    <span class="o">++</span><span class="n">NumProbes</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">E</span><span class="p">.</span><span class="n">getOffset</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">SLocOffset</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Sanity checking, otherwise a bug may lead to hanging in release build.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">GreaterIndex</span> <span class="o">==</span> <span class="n">MiddleIndex</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;binary search missed the entry&quot;</span><span class="p">);</span>
            <span class="k">return</span> <span class="nf">FileID</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">GreaterIndex</span> <span class="o">=</span> <span class="n">MiddleIndex</span><span class="p">;</span>
        <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">isOffsetInFileID</span><span class="p">(</span><span class="n">FileID</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="o">-</span><span class="kt">int</span><span class="p">(</span><span class="n">MiddleIndex</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">),</span> <span class="n">SLocOffset</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">FileID</span> <span class="n">Res</span> <span class="o">=</span> <span class="n">FileID</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="o">-</span><span class="kt">int</span><span class="p">(</span><span class="n">MiddleIndex</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">E</span><span class="p">.</span><span class="n">isExpansion</span><span class="p">())</span>
            <span class="n">LastFileIDLookup</span> <span class="o">=</span> <span class="n">Res</span><span class="p">;</span>
        <span class="n">NumBinaryProbes</span> <span class="o">+=</span> <span class="n">NumProbes</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">Res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Sanity checking, otherwise a bug may lead to hanging in release build.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">LessIndex</span> <span class="o">==</span> <span class="n">MiddleIndex</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;binary search missed the entry&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nf">FileID</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">LessIndex</span> <span class="o">=</span> <span class="n">MiddleIndex</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>至此，由一个<code>offset</code>寻找对应的<code>FileID</code>的功能就完成了，这个功能的主要调用者是下面这个函数，由<code>SpellingLoc</code>寻找对应的<code>FileID</code>，因为这个才需要跨文件寻找：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// This is a very hot method that is used for all SourceManager queries</span>
<span class="c1">/// that start with a SourceLocation object.  It is responsible for finding</span>
<span class="c1">/// the entry in SLocEntryTable which contains the specified location.</span>
<span class="c1">///</span>
<span class="n">FileID</span> <span class="nf">getFileID</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">SpellingLoc</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">SLocOffset</span> <span class="o">=</span> <span class="n">SpellingLoc</span><span class="p">.</span><span class="n">getOffset</span><span class="p">();</span>

    <span class="c1">// If our one-entry cache covers this offset, just return it.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isOffsetInFileID</span><span class="p">(</span><span class="n">LastFileIDLookup</span><span class="p">,</span> <span class="n">SLocOffset</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">LastFileIDLookup</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">getFileIDSlow</span><span class="p">(</span><span class="n">SLocOffset</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>注意第10行的处理，看来访问局部性还是很高啊。</p>
<p>很多时候我们需要的是文件名和文件内偏移这个<code>pair</code>。在我们实现了由<code>SLocOffset</code>获得对应的文件<code>FileID</code>之后，这个功能其实很简单，直接相减即可以得到文件内偏移：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief Decompose the specified location into a raw FileID + Offset pair.</span>
<span class="c1">///</span>
<span class="c1">/// The first element is the FileID, the second is the offset from the</span>
<span class="c1">/// start of the buffer of the location.</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">FileID</span><span class="p">,</span> <span class="kt">unsigned</span><span class="o">&gt;</span> <span class="n">getDecomposedLoc</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">FileID</span> <span class="n">FID</span> <span class="o">=</span> <span class="n">getFileID</span><span class="p">(</span><span class="n">Loc</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">Invalid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">SrcMgr</span><span class="o">::</span><span class="n">SLocEntry</span> <span class="o">&amp;</span><span class="n">E</span> <span class="o">=</span> <span class="n">getSLocEntry</span><span class="p">(</span><span class="n">FID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Invalid</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Invalid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">FileID</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">FID</span><span class="p">,</span> <span class="n">Loc</span><span class="p">.</span><span class="n">getOffset</span><span class="p">()</span> <span class="o">-</span> <span class="n">E</span><span class="p">.</span><span class="n">getOffset</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>


<h2 id="5da256">根据FileEntry查询FileID</h2>
<p>这个操作是由<code>translateFile</code>函数来完成的。根据<code>FileEntry</code>得到对应的<code>FileID</code>，看上去很简单的功能居然有140多行，分部分来讲。首先是函数签名：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief Get the FileID for the given file.</span>
<span class="c1">///</span>
<span class="c1">/// If the source file is included multiple times, the FileID will be the</span>
<span class="c1">/// first inclusion.</span>
<span class="n">FileID</span> <span class="n">SourceManager</span><span class="o">::</span><span class="n">translateFile</span><span class="p">(</span><span class="k">const</span> <span class="n">FileEntry</span> <span class="o">*</span><span class="n">SourceFile</span><span class="p">)</span> <span class="k">const</span>
</pre></div>


<p>这里的注释说一个文件可能被<code>include</code>多次，我们返回第一次引入所生成的<code>FileID</code>。</p>
<p>首先我们检查当前的翻译单元是否就是要找的<code>FileID</code></p>
<div class="codehilite"><pre><span></span><span class="n">FileID</span> <span class="n">FirstFID</span><span class="p">;</span>

<span class="c1">// First, check the main file ID, since it is common to look for a</span>
<span class="c1">// location in the main file.</span>
<span class="n">Optional</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">sys</span><span class="o">::</span><span class="n">fs</span><span class="o">::</span><span class="n">UniqueID</span><span class="o">&gt;</span> <span class="n">SourceFileUID</span><span class="p">;</span>
<span class="n">Optional</span><span class="o">&lt;</span><span class="n">StringRef</span><span class="o">&gt;</span> <span class="n">SourceFileName</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">MainFileID</span><span class="p">.</span><span class="n">isValid</span><span class="p">())</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">Invalid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">SLocEntry</span> <span class="o">&amp;</span><span class="n">MainSLoc</span> <span class="o">=</span> <span class="n">getSLocEntry</span><span class="p">(</span><span class="n">MainFileID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Invalid</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Invalid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FileID</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">MainSLoc</span><span class="p">.</span><span class="n">isFile</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="n">ContentCache</span> <span class="o">*</span><span class="n">MainContentCache</span>
            <span class="o">=</span> <span class="n">MainSLoc</span><span class="p">.</span><span class="n">getFile</span><span class="p">().</span><span class="n">getContentCache</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MainContentCache</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Can&#39;t do anything</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">MainContentCache</span><span class="o">-&gt;</span><span class="n">OrigEntry</span> <span class="o">==</span> <span class="n">SourceFile</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">FirstFID</span> <span class="o">=</span> <span class="n">MainFileID</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="c1">// Fall back: check whether we have the same base name and inode</span>
            <span class="c1">// as the main file.</span>
            <span class="c1">//此处省略很多字</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>这么多<code>if</code>简直太恐怖了，其实流程上来说很简单，根据<code>MainFileID</code>获得对应的<code>SLocEntry</code>，然后再获得对应的<code>ContentCache</code>，比较里面存储的<code>OrigEntry</code>是否等价于当前的<code>FileEntry</code>。如果等价则直接返回，否则继续检查文件名是否相等，相等的情况下去检查文件系统里面的<code>ID</code>是否相等。</p>
<div class="codehilite"><pre><span></span><span class="k">const</span> <span class="n">FileEntry</span> <span class="o">*</span><span class="n">MainFile</span> <span class="o">=</span> <span class="n">MainContentCache</span><span class="o">-&gt;</span><span class="n">OrigEntry</span><span class="p">;</span>
<span class="n">SourceFileName</span> <span class="o">=</span> <span class="n">llvm</span><span class="o">::</span><span class="n">sys</span><span class="o">::</span><span class="n">path</span><span class="o">::</span><span class="n">filename</span><span class="p">(</span><span class="n">SourceFile</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">());</span>
<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">SourceFileName</span> <span class="o">==</span> <span class="n">llvm</span><span class="o">::</span><span class="n">sys</span><span class="o">::</span><span class="n">path</span><span class="o">::</span><span class="n">filename</span><span class="p">(</span><span class="n">MainFile</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">()))</span>
<span class="p">{</span>
    <span class="n">SourceFileUID</span> <span class="o">=</span> <span class="n">getActualFileUID</span><span class="p">(</span><span class="n">SourceFile</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">SourceFileUID</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Optional</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">sys</span><span class="o">::</span><span class="n">fs</span><span class="o">::</span><span class="n">UniqueID</span><span class="o">&gt;</span> <span class="n">MainFileUID</span> <span class="o">=</span>
            <span class="n">getActualFileUID</span><span class="p">(</span><span class="n">MainFile</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">SourceFileUID</span> <span class="o">==</span> <span class="o">*</span><span class="n">MainFileUID</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">FirstFID</span> <span class="o">=</span> <span class="n">MainFileID</span><span class="p">;</span>
                <span class="n">SourceFile</span> <span class="o">=</span> <span class="n">MainFile</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>如果各种检查都没有通过，则遍历整个<code>LocalSLocEntry</code>一一判断，好蠢：</p>
<div class="codehilite"><pre><span></span><span class="c1">// The location we&#39;re looking for isn&#39;t in the main file; look</span>
<span class="c1">// through all of the local source locations.</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">local_sloc_entry_size</span><span class="p">();</span> <span class="n">I</span> <span class="o">!=</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">Invalid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">SLocEntry</span> <span class="o">&amp;</span><span class="n">SLoc</span> <span class="o">=</span> <span class="n">getLocalSLocEntry</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Invalid</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Invalid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FileID</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">SLoc</span><span class="p">.</span><span class="n">isFile</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
        <span class="n">SLoc</span><span class="p">.</span><span class="n">getFile</span><span class="p">().</span><span class="n">getContentCache</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
        <span class="n">SLoc</span><span class="p">.</span><span class="n">getFile</span><span class="p">().</span><span class="n">getContentCache</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">OrigEntry</span> <span class="o">==</span> <span class="n">SourceFile</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">FirstFID</span> <span class="o">=</span> <span class="n">FileID</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">I</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>如果还是没找到，开始遍历外部的<code>LoadedSLocEntry</code>，也是一一比较，好蠢：</p>
<div class="codehilite"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">loaded_sloc_entry_size</span><span class="p">();</span> <span class="n">I</span> <span class="o">!=</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">SLocEntry</span> <span class="o">&amp;</span><span class="n">SLoc</span> <span class="o">=</span> <span class="n">getLoadedSLocEntry</span><span class="p">(</span><span class="n">I</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">SLoc</span><span class="p">.</span><span class="n">isFile</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
        <span class="n">SLoc</span><span class="p">.</span><span class="n">getFile</span><span class="p">().</span><span class="n">getContentCache</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
        <span class="n">SLoc</span><span class="p">.</span><span class="n">getFile</span><span class="p">().</span><span class="n">getContentCache</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">OrigEntry</span> <span class="o">==</span> <span class="n">SourceFile</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">FirstFID</span> <span class="o">=</span> <span class="n">FileID</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="o">-</span><span class="kt">int</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>如果还是没有找到，就重新遍历一次<code>LocalSLocEntry</code>，不过这次又加上了文件系统级别的比较，这里就不贴代码了，与<code>MainID</code>那里的比较相似。</p>
<p>话说为什么会这么麻烦，建立一个映射表不就完事了么？居然需要遍历，而且还是两次！</p>
<h2 id="4a45d7">Macro展开位置的查询</h2>
<p>对于一个给定的<code>SourceLocation</code>，我们有些时候需要找出对应宏展开的起始位点，这是一个递归的过程，因为宏展开是一个递归的过程。</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief Given a SourceLocation object \p Loc, return the expansion</span>
<span class="c1">/// location referenced by the ID.</span>
<span class="n">SourceLocation</span> <span class="nf">getExpansionLoc</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// Handle the non-mapped case inline, defer to out of line code to handle</span>
    <span class="c1">// expansions.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Loc</span><span class="p">.</span><span class="n">isFileID</span><span class="p">())</span> <span class="k">return</span> <span class="n">Loc</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">getExpansionLocSlowCase</span><span class="p">(</span><span class="n">Loc</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">SourceLocation</span> <span class="n">SourceManager</span><span class="o">::</span>
<span class="n">getExpansionLocSlowCase</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">do</span>
    <span class="p">{</span>
        <span class="c1">// Note: If Loc indicates an offset into a token that came from a macro</span>
        <span class="c1">// expansion (e.g. the 5th character of the token) we do not want to add</span>
        <span class="c1">// this offset when going to the expansion location.  The expansion</span>
        <span class="c1">// location is the macro invocation, which the offset has nothing to do</span>
        <span class="c1">// with.  This is unlike when we get the spelling loc, because the offset</span>
        <span class="c1">// directly correspond to the token whose spelling we&#39;re inspecting.</span>
        <span class="n">Loc</span> <span class="o">=</span> <span class="n">getSLocEntry</span><span class="p">(</span><span class="n">getFileID</span><span class="p">(</span><span class="n">Loc</span><span class="p">)).</span><span class="n">getExpansion</span><span class="p">().</span><span class="n">getExpansionLocStart</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">Loc</span><span class="p">.</span><span class="n">isFileID</span><span class="p">());</span>

    <span class="k">return</span> <span class="n">Loc</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>只要中间的查询结果还是<code>Expansion</code>相关的<code>SourceLocation</code>，就一直递归查询。</p>
<p>类似的，寻找<code>SpellingLoc</code>也是递归查询的，直到查询到一个真正的<code>FileID</code></p>
<div class="codehilite"><pre><span></span><span class="n">SourceLocation</span> <span class="n">SourceManager</span><span class="o">::</span><span class="n">getSpellingLocSlowCase</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">do</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">FileID</span><span class="p">,</span> <span class="kt">unsigned</span><span class="o">&gt;</span> <span class="n">LocInfo</span> <span class="o">=</span> <span class="n">getDecomposedLoc</span><span class="p">(</span><span class="n">Loc</span><span class="p">);</span>
        <span class="n">Loc</span> <span class="o">=</span> <span class="n">getSLocEntry</span><span class="p">(</span><span class="n">LocInfo</span><span class="p">.</span><span class="n">first</span><span class="p">).</span><span class="n">getExpansion</span><span class="p">().</span><span class="n">getSpellingLoc</span><span class="p">();</span>
        <span class="n">Loc</span> <span class="o">=</span> <span class="n">Loc</span><span class="p">.</span><span class="n">getLocWithOffset</span><span class="p">(</span><span class="n">LocInfo</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">Loc</span><span class="p">.</span><span class="n">isFileID</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">Loc</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这里的代码依赖于<code>LocInfo.second</code>的值是2的倍数，这样就不会影响<code>Loc</code>的最低位。是否是2的倍数依赖于<code>getDecomposedLoc</code>的实现：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief Decompose the specified location into a raw FileID + Offset pair.</span>
<span class="c1">///</span>
<span class="c1">/// The first element is the FileID, the second is the offset from the</span>
<span class="c1">/// start of the buffer of the location.</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">FileID</span><span class="p">,</span> <span class="kt">unsigned</span><span class="o">&gt;</span> <span class="n">getDecomposedLoc</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">FileID</span> <span class="n">FID</span> <span class="o">=</span> <span class="n">getFileID</span><span class="p">(</span><span class="n">Loc</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">Invalid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">SrcMgr</span><span class="o">::</span><span class="n">SLocEntry</span> <span class="o">&amp;</span><span class="n">E</span> <span class="o">=</span> <span class="n">getSLocEntry</span><span class="p">(</span><span class="n">FID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Invalid</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Invalid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">FileID</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">FID</span><span class="p">,</span> <span class="n">Loc</span><span class="p">.</span><span class="n">getOffset</span><span class="p">()</span> <span class="o">-</span> <span class="n">E</span><span class="p">.</span><span class="n">getOffset</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>


<p>由于<code>getOffset</code>这个函数返回的是已经经过位修正的<code>offset</code>，所以2的倍数得到了满足。</p>
<p>这个函数只是处理了宏展开相关的开始位点，我们很多时候还需要开始与结束位点，即完整的展开区间。相关的函数有两个，一个只处理一次展开，一个处理完整的展开链：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief Return the start/end of the expansion information for an</span>
<span class="c1">/// expansion location.</span>
<span class="c1">///</span>
<span class="c1">/// \pre \p Loc is required to be an expansion location.</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">SourceLocation</span><span class="p">,</span> <span class="n">SourceLocation</span><span class="o">&gt;</span>
<span class="n">getImmediateExpansionRange</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">/// \brief Given a SourceLocation object, return the range of</span>
<span class="c1">/// tokens covered by the expansion in the ultimate file.</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">SourceLocation</span><span class="p">,</span> <span class="n">SourceLocation</span><span class="o">&gt;</span>
    <span class="n">getExpansionRange</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>


<p>直接展开很好解决，直接返回存储的展开区间就可以了：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// getImmediateExpansionRange - Loc is required to be an expansion location.</span>
<span class="c1">/// Return the start/end of the expansion information.</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">SourceLocation</span><span class="p">,</span> <span class="n">SourceLocation</span><span class="o">&gt;</span>
<span class="n">SourceManager</span><span class="o">::</span><span class="n">getImmediateExpansionRange</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">Loc</span><span class="p">.</span><span class="n">isMacroID</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Not a macro expansion loc!&quot;</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">ExpansionInfo</span> <span class="o">&amp;</span><span class="n">Expansion</span> <span class="o">=</span> <span class="n">getSLocEntry</span><span class="p">(</span><span class="n">getFileID</span><span class="p">(</span><span class="n">Loc</span><span class="p">)).</span><span class="n">getExpansion</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">Expansion</span><span class="p">.</span><span class="n">getExpansionLocRange</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p>而对于完整的宏展开来说，就不能这样做了，又需要递归处理，对于上面这个函数所获得的值，递归查询：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// getExpansionRange - Given a SourceLocation object, return the range of</span>
<span class="c1">/// tokens covered by the expansion in the ultimate file.</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">SourceLocation</span><span class="p">,</span> <span class="n">SourceLocation</span><span class="o">&gt;</span>
<span class="n">SourceManager</span><span class="o">::</span><span class="n">getExpansionRange</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Loc</span><span class="p">.</span><span class="n">isFileID</span><span class="p">())</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">Loc</span><span class="p">,</span> <span class="n">Loc</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">SourceLocation</span><span class="p">,</span> <span class="n">SourceLocation</span><span class="o">&gt;</span> <span class="n">Res</span> <span class="o">=</span>
        <span class="n">getImmediateExpansionRange</span><span class="p">(</span><span class="n">Loc</span><span class="p">);</span>

    <span class="c1">// Fully resolve the start and end locations to their ultimate expansion</span>
    <span class="c1">// points.</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">Res</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">isFileID</span><span class="p">())</span>
        <span class="n">Res</span><span class="p">.</span><span class="n">first</span> <span class="o">=</span> <span class="n">getImmediateExpansionRange</span><span class="p">(</span><span class="n">Res</span><span class="p">.</span><span class="n">first</span><span class="p">).</span><span class="n">first</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">Res</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">isFileID</span><span class="p">())</span>
        <span class="n">Res</span><span class="p">.</span><span class="n">second</span> <span class="o">=</span> <span class="n">getImmediateExpansionRange</span><span class="p">(</span><span class="n">Res</span><span class="p">.</span><span class="n">second</span><span class="p">).</span><span class="n">second</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>最后还剩下两个有趣的函数，一个是判断当前位置是不是直接宏展开的头部，一个是判断当前位置是不是直接宏展开的尾部。这两个函数的执行逻辑都是类似的，首先判断位置有效性：是不是宏展开位置，是不是文件头或者文件尾。然后再得到该展开区域的<code>Range</code>,继续判断。</p>
<h2 id="348256">BeforeInTUCache</h2>
<p>目前还不是很懂这个词的意思，好像处理的是两个<code>SourceLocation</code>在转换单元中的处理顺序。</p>
<div class="codehilite"><pre><span></span><span class="c1">/// The key value into the IsBeforeInTUCache table.</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">FileID</span><span class="p">,</span> <span class="n">FileID</span><span class="o">&gt;</span> <span class="n">IsBeforeInTUCacheKey</span><span class="p">;</span>

<span class="c1">/// The IsBeforeInTranslationUnitCache is a mapping from FileID pairs</span>
<span class="c1">/// to cache results.</span>
<span class="k">typedef</span> <span class="n">llvm</span><span class="o">::</span><span class="n">DenseMap</span><span class="o">&lt;</span><span class="n">IsBeforeInTUCacheKey</span><span class="p">,</span> <span class="n">InBeforeInTUCacheEntry</span><span class="o">&gt;</span>
    <span class="n">InBeforeInTUCache</span><span class="p">;</span>

<span class="c1">/// Cache results for the isBeforeInTranslationUnit method.</span>
<span class="k">mutable</span> <span class="n">InBeforeInTUCache</span> <span class="n">IBTUCache</span><span class="p">;</span>
<span class="k">mutable</span> <span class="n">InBeforeInTUCacheEntry</span> <span class="n">IBTUCacheOverflow</span><span class="p">;</span>

<span class="c1">/// Return the cache entry for comparing the given file IDs</span>
<span class="c1">/// for isBeforeInTranslationUnit.</span>
<span class="n">InBeforeInTUCacheEntry</span> <span class="o">&amp;</span><span class="n">getInBeforeInTUCache</span><span class="p">(</span><span class="n">FileID</span> <span class="n">LFID</span><span class="p">,</span> <span class="n">FileID</span> <span class="n">RFID</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>


<h2 id="6be805">行列号管理</h2>
<h3 id="187da1">列号查询</h3>
<p>注释里面说列号比行号好处理的多，因此我们就先以列号来说吧。使用时是通过文件标识符和偏移位置来计算的，其函数签名如下:</p>
<div class="codehilite"><pre><span></span><span class="c1">/// getColumnNumber - Return the column # for the specified file position.</span>
<span class="c1">/// this is significantly cheaper to compute than the line number.</span>
<span class="kt">unsigned</span> <span class="n">SourceManager</span><span class="o">::</span><span class="n">getColumnNumber</span><span class="p">(</span><span class="n">FileID</span> <span class="n">FID</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">FilePos</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="o">*</span><span class="n">Invalid</span><span class="p">)</span> <span class="k">const</span>
</pre></div>


<p>具体执行流程是首先判断该文件是否有对应的<code>MemoryBuffer</code>，没有则直接返回无效值。如果偏移量大于缓冲大小也直接返回无效值。</p>
<div class="codehilite"><pre><span></span><span class="kt">bool</span> <span class="n">MyInvalid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="n">llvm</span><span class="o">::</span><span class="n">MemoryBuffer</span> <span class="o">*</span><span class="n">MemBuf</span> <span class="o">=</span> <span class="n">getBuffer</span><span class="p">(</span><span class="n">FID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MyInvalid</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Invalid</span><span class="p">)</span>
    <span class="o">*</span><span class="n">Invalid</span> <span class="o">=</span> <span class="n">MyInvalid</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">MyInvalid</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">// It is okay to request a position just past the end of the buffer.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">FilePos</span> <span class="o">&gt;</span> <span class="n">MemBuf</span><span class="o">-&gt;</span><span class="n">getBufferSize</span><span class="p">())</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Invalid</span><span class="p">)</span>
        <span class="o">*</span><span class="n">Invalid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>然后再利用<code>SourceManager</code>中存储的最近查询记录，如果该位置在最近查询的行内，则直接计算列偏移。</p>
<div class="codehilite"><pre><span></span><span class="c1">// See if we just calculated the line number for this FilePos and can use</span>
<span class="c1">// that to lookup the start of the line instead of searching for it.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">LastLineNoFileIDQuery</span> <span class="o">==</span> <span class="n">FID</span> <span class="o">&amp;&amp;</span>
    <span class="n">LastLineNoContentCache</span><span class="o">-&gt;</span><span class="n">SourceLineCache</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="o">&amp;&amp;</span>
    <span class="n">LastLineNoResult</span> <span class="o">&lt;</span> <span class="n">LastLineNoContentCache</span><span class="o">-&gt;</span><span class="n">NumLines</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="o">*</span><span class="n">SourceLineCache</span> <span class="o">=</span> <span class="n">LastLineNoContentCache</span><span class="o">-&gt;</span><span class="n">SourceLineCache</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">LineStart</span> <span class="o">=</span> <span class="n">SourceLineCache</span><span class="p">[</span><span class="n">LastLineNoResult</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="kt">unsigned</span> <span class="n">LineEnd</span> <span class="o">=</span> <span class="n">SourceLineCache</span><span class="p">[</span><span class="n">LastLineNoResult</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FilePos</span> <span class="o">&gt;=</span> <span class="n">LineStart</span> <span class="o">&amp;&amp;</span> <span class="n">FilePos</span> <span class="o">&lt;</span> <span class="n">LineEnd</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FilePos</span> <span class="o">-</span> <span class="n">LineStart</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>否则的话，就一直回退到换行符<code>\textbackslash r\textbackslash n</code>，记录后退了多少步，直接返回。</p>
<div class="codehilite"><pre><span></span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Buf</span> <span class="o">=</span> <span class="n">MemBuf</span><span class="o">-&gt;</span><span class="n">getBufferStart</span><span class="p">();</span>
<span class="kt">unsigned</span> <span class="n">LineStart</span> <span class="o">=</span> <span class="n">FilePos</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">LineStart</span> <span class="o">&amp;&amp;</span> <span class="n">Buf</span><span class="p">[</span><span class="n">LineStart</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">Buf</span><span class="p">[</span><span class="n">LineStart</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\r&#39;</span><span class="p">)</span>
    <span class="o">--</span><span class="n">LineStart</span><span class="p">;</span>
<span class="k">return</span> <span class="n">FilePos</span> <span class="o">-</span> <span class="n">LineStart</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>


<h3 id="ac17d7">行号查询</h3>
<p>对于行号的计算就没有这么爽了，<code>SourceManager</code>内有一个函数来执行寻找行号这个操作，其函数签名如下：</p>
<div class="codehilite"><pre><span></span><span class="kt">unsigned</span> <span class="n">SourceManager</span><span class="o">::</span><span class="n">getLineNumber</span><span class="p">(</span><span class="n">FileID</span> <span class="n">FID</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">FilePos</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="o">*</span><span class="n">Invalid</span><span class="p">)</span> <span class="k">const</span>
</pre></div>


<p>这个函数也比较复杂，所以分部分说明。首先找到这个文件的<code>ContentCache</code>，这里可以利用缓存。</p>
<div class="codehilite"><pre><span></span><span class="n">ContentCache</span> <span class="o">*</span><span class="n">Content</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">LastLineNoFileIDQuery</span> <span class="o">==</span> <span class="n">FID</span><span class="p">)</span>
    <span class="n">Content</span> <span class="o">=</span> <span class="n">LastLineNoContentCache</span><span class="p">;</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">MyInvalid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">SLocEntry</span> <span class="o">&amp;</span><span class="n">Entry</span> <span class="o">=</span> <span class="n">getSLocEntry</span><span class="p">(</span><span class="n">FID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MyInvalid</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">MyInvalid</span> <span class="o">||</span> <span class="o">!</span><span class="n">Entry</span><span class="p">.</span><span class="n">isFile</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Invalid</span><span class="p">)</span>
            <span class="o">*</span><span class="n">Invalid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Content</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">ContentCache</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">Entry</span><span class="p">.</span><span class="n">getFile</span><span class="p">().</span><span class="n">getContentCache</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>


<p>获得这个<code>ContentCache</code>之后，在获得其<code>SourceLineCache</code>，如果没有的话则需要调用前面的<code>ComputeLineNumbers</code>函数来建立：</p>
<div class="codehilite"><pre><span></span><span class="c1">// If this is the first use of line information for this buffer, compute the</span>
<span class="c1">/// SourceLineCache for it on demand.</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Content</span><span class="o">-&gt;</span><span class="n">SourceLineCache</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">MyInvalid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">ComputeLineNumbers</span><span class="p">(</span><span class="n">Diag</span><span class="p">,</span> <span class="n">Content</span><span class="p">,</span> <span class="n">ContentCacheAlloc</span><span class="p">,</span> <span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">MyInvalid</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Invalid</span><span class="p">)</span>
        <span class="o">*</span><span class="n">Invalid</span> <span class="o">=</span> <span class="n">MyInvalid</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">MyInvalid</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Invalid</span><span class="p">)</span>
    <span class="o">*</span><span class="n">Invalid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</pre></div>


<p>之后就是二分查找的过程，但是这里又搞了一些复杂的事来寻找一个比较好的上界.如果上次的查询的是同一个文件，则当前查询的位点应该离上次查询的位点不远，何必呢！：</p>
<div class="codehilite"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">LastLineNoFileIDQuery</span> <span class="o">==</span> <span class="n">FID</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">QueriedFilePos</span> <span class="o">&gt;=</span> <span class="n">LastLineNoFilePos</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// FIXME: Potential overflow?</span>
        <span class="n">SourceLineCache</span> <span class="o">=</span> <span class="n">SourceLineCache</span> <span class="o">+</span> <span class="n">LastLineNoResult</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="c1">// The query is likely to be nearby the previous one.  Here we check to</span>
        <span class="c1">// see if it is within 5, 10 or 20 lines.  It can be far away in cases</span>
        <span class="c1">// where big comment blocks and vertical whitespace eat up lines but</span>
        <span class="c1">// contribute no tokens.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">SourceLineCache</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">&lt;</span> <span class="n">SourceLineCacheEnd</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">SourceLineCache</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">QueriedFilePos</span><span class="p">)</span>
                <span class="n">SourceLineCacheEnd</span> <span class="o">=</span> <span class="n">SourceLineCache</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">SourceLineCache</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">&lt;</span> <span class="n">SourceLineCacheEnd</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">SourceLineCache</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">QueriedFilePos</span><span class="p">)</span>
                    <span class="n">SourceLineCacheEnd</span> <span class="o">=</span> <span class="n">SourceLineCache</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>
                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">SourceLineCache</span> <span class="o">+</span> <span class="mi">20</span> <span class="o">&lt;</span> <span class="n">SourceLineCacheEnd</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">SourceLineCache</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">QueriedFilePos</span><span class="p">)</span>
                        <span class="n">SourceLineCacheEnd</span> <span class="o">=</span> <span class="n">SourceLineCache</span> <span class="o">+</span> <span class="mi">20</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">LastLineNoResult</span> <span class="o">&lt;</span> <span class="n">Content</span><span class="o">-&gt;</span><span class="n">NumLines</span><span class="p">)</span>
            <span class="n">SourceLineCacheEnd</span> <span class="o">=</span> <span class="n">SourceLineCache</span> <span class="o">+</span> <span class="n">LastLineNoResult</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>现在我们才可以调用二分查找过程了，并同时填好最近访问记录：</p>
<div class="codehilite"><pre><span></span><span class="kt">unsigned</span> <span class="o">*</span><span class="n">Pos</span>
    <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">SourceLineCache</span><span class="p">,</span> <span class="n">SourceLineCacheEnd</span><span class="p">,</span> <span class="n">QueriedFilePos</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="n">LineNo</span> <span class="o">=</span> <span class="n">Pos</span> <span class="o">-</span> <span class="n">SourceLineCacheStart</span><span class="p">;</span>

<span class="n">LastLineNoFileIDQuery</span> <span class="o">=</span> <span class="n">FID</span><span class="p">;</span>
<span class="n">LastLineNoContentCache</span> <span class="o">=</span> <span class="n">Content</span><span class="p">;</span>
<span class="n">LastLineNoFilePos</span> <span class="o">=</span> <span class="n">QueriedFilePos</span><span class="p">;</span>
<span class="n">LastLineNoResult</span> <span class="o">=</span> <span class="n">LineNo</span><span class="p">;</span>
<span class="k">return</span> <span class="n">LineNo</span><span class="p">;</span>
</pre></div>


<p>在做了这么多的铺垫之后，上级函数实现起来就非常简单了：</p>
<div class="codehilite"><pre><span></span><span class="kt">unsigned</span> <span class="n">SourceManager</span><span class="o">::</span><span class="n">getSpellingLineNumber</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="o">*</span><span class="n">Invalid</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isInvalid</span><span class="p">(</span><span class="n">Loc</span><span class="p">,</span> <span class="n">Invalid</span><span class="p">))</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">FileID</span><span class="p">,</span> <span class="kt">unsigned</span><span class="o">&gt;</span> <span class="n">LocInfo</span> <span class="o">=</span> <span class="n">getDecomposedSpellingLoc</span><span class="p">(</span><span class="n">Loc</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">getLineNumber</span><span class="p">(</span><span class="n">LocInfo</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">LocInfo</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">unsigned</span> <span class="n">SourceManager</span><span class="o">::</span><span class="n">getExpansionLineNumber</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="o">*</span><span class="n">Invalid</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isInvalid</span><span class="p">(</span><span class="n">Loc</span><span class="p">,</span> <span class="n">Invalid</span><span class="p">))</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">FileID</span><span class="p">,</span> <span class="kt">unsigned</span><span class="o">&gt;</span> <span class="n">LocInfo</span> <span class="o">=</span> <span class="n">getDecomposedExpansionLoc</span><span class="p">(</span><span class="n">Loc</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">getLineNumber</span><span class="p">(</span><span class="n">LocInfo</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">LocInfo</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h3 id="46e5f5">Presumed行号查询</h3>
<p><code>SpellingLineNumber</code>和<code>ExpansionLineNumber</code>可以比较直接利用前面的函数进行处理，但是对于<code>PresumedLineNumber</code>来说，就没这么简单了。</p>
<div class="codehilite"><pre><span></span><span class="kt">unsigned</span> <span class="n">SourceManager</span><span class="o">::</span><span class="n">getPresumedLineNumber</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="o">*</span><span class="n">Invalid</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isInvalid</span><span class="p">(</span><span class="n">Loc</span><span class="p">,</span> <span class="n">Invalid</span><span class="p">))</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="nf">getPresumedLoc</span><span class="p">(</span><span class="n">Loc</span><span class="p">).</span><span class="n">getLine</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p>这里依赖于<code>getPresumeLoc</code>的行为，比较特殊，我们需要进行分析，其函数签名如下：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// getPresumedLoc - This method returns the &quot;presumed&quot; location of a</span>
<span class="c1">/// SourceLocation specifies.  A &quot;presumed location&quot; can be modified by #line</span>
<span class="c1">/// or GNU line marker directives.  This provides a view on the data that a</span>
<span class="c1">/// user should see in diagnostics, for example.</span>
<span class="c1">///</span>
<span class="c1">/// Note that a presumed location is always given as the expansion point of an</span>
<span class="c1">/// expansion location, not at the spelling location.</span>
<span class="n">PresumedLoc</span> <span class="n">SourceManager</span><span class="o">::</span><span class="n">getPresumedLoc</span><span class="p">(</span><span class="n">SourceLocation</span> <span class="n">Loc</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">UseLineDirectives</span><span class="p">)</span> <span class="k">const</span>
</pre></div>


<p>首先需要得到这个<code>loc</code>的展开开始位置来明确行号：</p>
<div class="codehilite"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">Loc</span><span class="p">.</span><span class="n">isInvalid</span><span class="p">())</span> <span class="k">return</span> <span class="n">PresumedLoc</span><span class="p">();</span>

<span class="c1">// Presumed locations are always for expansion points.</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">FileID</span><span class="p">,</span> <span class="kt">unsigned</span><span class="o">&gt;</span> <span class="n">LocInfo</span> <span class="o">=</span> <span class="n">getDecomposedExpansionLoc</span><span class="p">(</span><span class="n">Loc</span><span class="p">);</span>

<span class="kt">bool</span> <span class="n">Invalid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="k">const</span> <span class="n">SLocEntry</span> <span class="o">&amp;</span><span class="n">Entry</span> <span class="o">=</span> <span class="n">getSLocEntry</span><span class="p">(</span><span class="n">LocInfo</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Invalid</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Invalid</span> <span class="o">||</span> <span class="o">!</span><span class="n">Entry</span><span class="p">.</span><span class="n">isFile</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">PresumedLoc</span><span class="p">();</span>

<span class="k">const</span> <span class="n">SrcMgr</span><span class="o">::</span><span class="n">FileInfo</span> <span class="o">&amp;</span><span class="n">FI</span> <span class="o">=</span> <span class="n">Entry</span><span class="p">.</span><span class="n">getFile</span><span class="p">();</span>
<span class="k">const</span> <span class="n">SrcMgr</span><span class="o">::</span><span class="n">ContentCache</span> <span class="o">*</span><span class="n">C</span> <span class="o">=</span> <span class="n">FI</span><span class="p">.</span><span class="n">getContentCache</span><span class="p">();</span>
<span class="c1">// To get the source name, first consult the FileEntry (if one exists)</span>
<span class="c1">// before the MemBuffer as this will avoid unnecessarily paging in the</span>
<span class="c1">// MemBuffer.</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Filename</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">C</span><span class="o">-&gt;</span><span class="n">OrigEntry</span><span class="p">)</span>
    <span class="n">Filename</span> <span class="o">=</span> <span class="n">C</span><span class="o">-&gt;</span><span class="n">OrigEntry</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">();</span>
<span class="k">else</span>
    <span class="n">Filename</span> <span class="o">=</span> <span class="n">C</span><span class="o">-&gt;</span><span class="n">getBuffer</span><span class="p">(</span><span class="n">Diag</span><span class="p">,</span> <span class="o">*</span><span class="k">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getBufferIdentifier</span><span class="p">();</span>

<span class="kt">unsigned</span> <span class="n">LineNo</span> <span class="o">=</span> <span class="n">getLineNumber</span><span class="p">(</span><span class="n">LocInfo</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">LocInfo</span><span class="p">.</span><span class="n">second</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Invalid</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Invalid</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">PresumedLoc</span><span class="p">();</span>
<span class="kt">unsigned</span> <span class="n">ColNo</span> <span class="o">=</span> <span class="n">getColumnNumber</span><span class="p">(</span><span class="n">LocInfo</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">LocInfo</span><span class="p">.</span><span class="n">second</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Invalid</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Invalid</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">PresumedLoc</span><span class="p">();</span>
</pre></div>


<p>得到这个展开开始区域之后，寻找最近的导言行，然后调整差值并返回：</p>
<div class="codehilite"><pre><span></span><span class="c1">// If we have #line directives in this file, update and overwrite the physical</span>
<span class="c1">// location info if appropriate.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">UseLineDirectives</span> <span class="o">&amp;&amp;</span> <span class="n">FI</span><span class="p">.</span><span class="n">hasLineDirectives</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">LineTable</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Can&#39;t have linetable entries without a LineTable!&quot;</span><span class="p">);</span>
    <span class="c1">// See if there is a #line directive before this.  If so, get it.</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">const</span> <span class="n">LineEntry</span> <span class="o">*</span><span class="n">Entry</span> <span class="o">=</span>
        <span class="n">LineTable</span><span class="o">-&gt;</span><span class="n">FindNearestLineEntry</span><span class="p">(</span><span class="n">LocInfo</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">LocInfo</span><span class="p">.</span><span class="n">second</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="c1">// If the LineEntry indicates a filename, use it.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Entry</span><span class="o">-&gt;</span><span class="n">FilenameID</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">Filename</span> <span class="o">=</span> <span class="n">LineTable</span><span class="o">-&gt;</span><span class="n">getFilename</span><span class="p">(</span><span class="n">Entry</span><span class="o">-&gt;</span><span class="n">FilenameID</span><span class="p">);</span>

        <span class="c1">// Use the line number specified by the LineEntry.  This line number may</span>
        <span class="c1">// be multiple lines down from the line entry.  Add the difference in</span>
        <span class="c1">// physical line numbers from the query point and the line marker to the</span>
        <span class="c1">// total.</span>
        <span class="kt">unsigned</span> <span class="n">MarkerLineNo</span> <span class="o">=</span> <span class="n">getLineNumber</span><span class="p">(</span><span class="n">LocInfo</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">Entry</span><span class="o">-&gt;</span><span class="n">FileOffset</span><span class="p">);</span>
        <span class="n">LineNo</span> <span class="o">=</span> <span class="n">Entry</span><span class="o">-&gt;</span><span class="n">LineNo</span> <span class="o">+</span> <span class="p">(</span><span class="n">LineNo</span> <span class="o">-</span> <span class="n">MarkerLineNo</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

        <span class="c1">// Note that column numbers are not molested by line markers.</span>

        <span class="c1">// Handle virtual #include manipulation.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Entry</span><span class="o">-&gt;</span><span class="n">IncludeOffset</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">IncludeLoc</span> <span class="o">=</span> <span class="n">getLocForStartOfFile</span><span class="p">(</span><span class="n">LocInfo</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
            <span class="n">IncludeLoc</span> <span class="o">=</span> <span class="n">IncludeLoc</span><span class="p">.</span><span class="n">getLocWithOffset</span><span class="p">(</span><span class="n">Entry</span><span class="o">-&gt;</span><span class="n">IncludeOffset</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">PresumedLoc</span><span class="p">(</span><span class="n">Filename</span><span class="p">,</span> <span class="n">LineNo</span><span class="p">,</span> <span class="n">ColNo</span><span class="p">,</span> <span class="n">IncludeLoc</span><span class="p">);</span>
</pre></div>


<h3 id="369b38">由行列号生成SourceLocation</h3>
<p>这个就相当于之前操作的逆函数，在已知文件名和行列号的情况下，得到对应的<code>SourceLocation</code>需要调用下面的函数：</p>
<div class="codehilite"><pre><span></span><span class="c1">/// \brief Get the source location for the given file:line:col triplet.</span>
<span class="c1">///</span>
<span class="c1">/// If the source file is included multiple times, the source location will</span>
<span class="c1">/// be based upon an arbitrary inclusion.</span>
<span class="n">SourceLocation</span> <span class="n">SourceManager</span><span class="o">::</span><span class="n">translateFileLineCol</span><span class="p">(</span><span class="k">const</span> <span class="n">FileEntry</span> <span class="o">*</span><span class="n">SourceFile</span><span class="p">,</span>
    <span class="kt">unsigned</span> <span class="n">Line</span><span class="p">,</span>
    <span class="kt">unsigned</span> <span class="n">Col</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">SourceFile</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Null source file!&quot;</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">Line</span> <span class="o">&amp;&amp;</span> <span class="n">Col</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Line and column should start from 1!&quot;</span><span class="p">);</span>

    <span class="n">FileID</span> <span class="n">FirstFID</span> <span class="o">=</span> <span class="n">translateFile</span><span class="p">(</span><span class="n">SourceFile</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">translateLineCol</span><span class="p">(</span><span class="n">FirstFID</span><span class="p">,</span> <span class="n">Line</span><span class="p">,</span> <span class="n">Col</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>然而这里又需要调用两个底层函数，<code>translateFile</code>这个已经在前面说过了，现在我们需要考虑的是<code>translateLineCol</code>。其实流程上也比较简单，由<code>FileID</code>获得<code>SlocEntry</code>，进而得到<code>ContentCache</code>。然后按需建立<code>SourceLineCache</code></p>
<div class="codehilite"><pre><span></span><span class="c1">// If this is the first use of line information for this buffer, compute the</span>
<span class="c1">// SourceLineCache for it on demand.</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Content</span><span class="o">-&gt;</span><span class="n">SourceLineCache</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">MyInvalid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">ComputeLineNumbers</span><span class="p">(</span><span class="n">Diag</span><span class="p">,</span> <span class="n">Content</span><span class="p">,</span> <span class="n">ContentCacheAlloc</span><span class="p">,</span> <span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">MyInvalid</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">MyInvalid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SourceLocation</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p>如果行号越界，直接返回最后一个位置。。。其实我觉得返回无效位置比较好。</p>
<div class="codehilite"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">Line</span> <span class="o">&gt;</span> <span class="n">Content</span><span class="o">-&gt;</span><span class="n">NumLines</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">Size</span> <span class="o">=</span> <span class="n">Content</span><span class="o">-&gt;</span><span class="n">getBuffer</span><span class="p">(</span><span class="n">Diag</span><span class="p">,</span> <span class="o">*</span><span class="k">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getBufferSize</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="o">--</span><span class="n">Size</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">FileLoc</span><span class="p">.</span><span class="n">getLocWithOffset</span><span class="p">(</span><span class="n">Size</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>后面就是针对列号和行号的加减，如果列号越界了，则返回本行最后一列。</p>
<div class="codehilite"><pre><span></span><span class="n">llvm</span><span class="o">::</span><span class="n">MemoryBuffer</span> <span class="o">*</span><span class="n">Buffer</span> <span class="o">=</span> <span class="n">Content</span><span class="o">-&gt;</span><span class="n">getBuffer</span><span class="p">(</span><span class="n">Diag</span><span class="p">,</span> <span class="o">*</span><span class="k">this</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="n">FilePos</span> <span class="o">=</span> <span class="n">Content</span><span class="o">-&gt;</span><span class="n">SourceLineCache</span><span class="p">[</span><span class="n">Line</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Buf</span> <span class="o">=</span> <span class="n">Buffer</span><span class="o">-&gt;</span><span class="n">getBufferStart</span><span class="p">()</span> <span class="o">+</span> <span class="n">FilePos</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="n">BufLength</span> <span class="o">=</span> <span class="n">Buffer</span><span class="o">-&gt;</span><span class="n">getBufferSize</span><span class="p">()</span> <span class="o">-</span> <span class="n">FilePos</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">BufLength</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FileLoc</span><span class="p">.</span><span class="n">getLocWithOffset</span><span class="p">(</span><span class="n">FilePos</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// Check that the given column is valid.</span>
<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">BufLength</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Col</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">Buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">Buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\r&#39;</span><span class="p">)</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
<span class="k">return</span> <span class="n">FileLoc</span><span class="p">.</span><span class="n">getLocWithOffset</span><span class="p">(</span><span class="n">FilePos</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
</pre></div>


<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
    </div>
    <div id="content-comments">
</div>

</div>
<div class="niu2-right-container col-md-2">
    <div id="niu2-sidebar-meta" class="niu2-sidebar">
        <div class="niu2-sidebar-label"><i class="icon-calendar"></i>Published:</div>
        <div class="niu2-sidebar-value">2015-11-17 19:27</div>
        <div class="niu2-sidebar-label"><i class="icon-open-folder"></i>Category:</div>
        <div class="niu2-sidebar-value"><a href="./category/compiler.html">Compiler</a></div>
        <div class="niu2-sidebar-label"><i class="icon-tag"></i>Tag:</div>
 
            <div class="niu2-sidebar-inter-value niu2-sidebar-tag"><a href="./tag/compiler.html">Compiler</a><sup>2</sup></div>
            <div class="niu2-sidebar-inter-value niu2-sidebar-tag"><a href="./tag/clang.html">Clang</a><sup>2</sup></div>
            <div class="niu2-sidebar-inter-value niu2-sidebar-tag"><a href="./tag/cpp.html">CPP</a><sup>12</sup></div>
    </div>

    <div id="niu2-sidebar-toc" class="niu2-sidebar" data-status="closed">
        <div class="niu2-sidebar-label">
            <i id="niu2-sidebar-toc-ctrl" class="icon-open-tocs"></i>TOC
        </div>
        <ol id="niu2-sidebar-toc-list">
            <li><a href="#content-heading">Clang Basic</a></li>
            <li><a href='#5d961e'>基本类型</a><ol><li><a href='#007513'>FileManager</a><ol><li><a href='#41691b'>FileID</a></li><li><a href='#c8787f'>FileInfo</a></li><li><a href='#a71181'>ContentCache</a></li></ol></li><li><a href='#6c9f9e'>SourceLocation</a><ol><li><a href='#6c9f9e_1'>SourceLocation</a></li><li><a href='#1460b6'>CharSourceRange</a></li><li><a href='#8f4b07'>FullSourceLoc</a></li><li><a href='#b8ce1f'>PresumedLoc</a></li></ol></li><li><a href='#bc4716'>LineTable</a></li><li><a href='#3525a6'>ExpansionInfo</a></li><li><a href='#f2128a'>SLocEntry</a></li><li><a href='#390ca7'>SourceManager</a></li></ol></li><li><a href='#6478fc'>资源管理</a><ol><li><a href='#51bef6'>资源句柄</a></li><li><a href='#e91e3f'>为File构建MemoryBuffer</a></li><li><a href='#2819f8'>为File构建ContentCache</a></li><li><a href='#442ccb'>生成新的FileID</a></li><li><a href='#a16f55'>为ContentCache生成行号索引</a></li><li><a href='#9fd146'>Macro展开位置的建立</a></li><li><a href='#74d66d'>为FileID建立宏参数映射</a></li></ol></li><li><a href='#eb9b5b'>查询访问</a><ol><li><a href='#05ec09'>访问缓存管理与统计</a></li><li><a href='#87424a'>根据SLocOffset查询FileID</a></li><li><a href='#5da256'>根据FileEntry查询FileID</a></li><li><a href='#4a45d7'>Macro展开位置的查询</a></li><li><a href='#348256'>BeforeInTUCache</a></li><li><a href='#6be805'>行列号管理</a><ol><li><a href='#187da1'>列号查询</a></li><li><a href='#ac17d7'>行号查询</a></li><li><a href='#46e5f5'>Presumed行号查询</a></li><li><a href='#369b38'>由行列号生成SourceLocation</a></li></ol></li></ol></li>
        </ol>
    </div>
</div>    </div>

    <div class="niu2-footer">
        <div id="body-footer" class="col-md-6 col-md-offset-2">
<hr/>
<p>
    Powered by <a href="https://github.com/getpelican/pelican">Pelican</a>, 
    <a href="https://github.com/mawenbao/niu-x2-sidebar">theme</a> built with <a href="http://getbootstrap.com">Bootstrap3</a>
    by <a href="http://blog.atime.me">Ma Wenbao</a>, icons by 
    <a href="http://fortawesome.github.io/Font-Awesome">Font Awesome</a>.
</p>
<p>
    ©
            2014-2017
    <a class="niu2-footer-link" href=".">Huiliang Huang</a>
</p>
<p class="niu2-icons">
</p>        </div>
    </div>
    
    <div id="niu2-pygments" data-theme="github"></div>

    <script type="text/javascript" src="./theme/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="./theme/js/niu2.min.js"></script>
    <script type="text/javascript" src="./theme/js/bootstrap.min.js"></script>
    <script type="text/javascript">onContentLoaded();</script>
  </body>
</html>